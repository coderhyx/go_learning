# 2023-8-23 刘常青
## 整理go编程入门

### 基本内置类型
Go支持如下内置基本类型：
一种内置布尔类型：bool。
11种内置整数类型：int8、uint8、int16、uint16、int32、uint32、int64、uint64、int、uint和uintptr。
两种内置浮点数类型：float32和float64。
两种内置复数类型：complex64和complex128。
一种内置字符串类型：string。
内置类型也称为预声明类型。
这17种内置基本类型（type）各自属于一种Go中的类型种类（kind）。 尽管所有的内置基本类型的名称都是非导出标识符， 我们可以不用引入任何代码包而直接使用这些类型。

除了bool和string类型，其它的15种内置基本类型都称为数值类型（整型、浮点数型和复数型）。

Go中有两种内置类型别名（type alias）：
byte是uint8的内置别名。 我们可以将byte和uint8看作是同一个类型。
rune是int32的内置别名。 我们可以将rune和int32看作是同一个类型。
以u开头的整数类型称为无符号整数类型。 无符号整数类型的值都是非负的。 一个数值类型名称中的数字表示每个这个类型的值将在内存中占有多少二进制位（以后简称位）。二进制位常称为比特（bit）。 比如，一个uint8的值将占有8位。 我们称uint8类型的值的尺寸是8位。 因此，最大的uint8值是255（28-1）， 最大的int8值是127（27-1）， 最小的int8值是-128（-27）。

任一个类型的所有值的尺寸都是相同的，所以一个值的尺寸也常称为它的类型的尺寸。

更多的时候，我们使用字节（byte）做为值尺寸的度量单位。 一个字节相当于8个比特。所以uint32类型的尺寸为4，即每个uint32值占用4个字节。

uintptr、int以及uint类型的值的尺寸依赖于具体编译器实现。 通常地，在64位的架构上，int和uint类型的值是64位的；在32位的架构上，它们是32位的。 编译器必须保证uintptr类型的值的尺寸能够存下任意一个内存地址。

一个complex64复数值的实部和虚部都是float32类型的值。 一个complex128复数值的实部和虚部都是float64类型的值。

在内存中，所有的浮点数都使用IEEE-754格式存储。

一个布尔值表示一个真假。在内存中，一个布尔值只有两种可能的状态。 这两种状态使用两个预声明（或称为内置）的常量（false和true）来表示。 关于常量声明，下一篇文章将做详细解释。

从逻辑上说，一个字符串值表示一段文本。 在内存中，一个字符串存储为一个字节（byte）序列。 此字节序列体现了此字符串所表示的文本的UTF-8编码形式。 我们可以从Go中的字符串一文中获取更多关于字符串的知识。

尽管布尔和字符串类型分类各自只有一种内置类型， 我们可以声明定义更多自定义布尔和字符串类型。 所以，Go代码中可以出现很多布尔和字符串类型（数值类型也同样）。 下面是一个类型声明的例子。 在这些例子中，type是一个关键字。
// 一些类型定义声明
type status bool     // status和bool是两个不同的类型
type MyString string // MyString和string是两个不同的类型
type Id uint64       // Id和uint64是两个不同的类型
type real float32    // real和float32是两个不同的类型

// 一些类型别名声明
type boolean = bool // boolean和bool表示同一个类型
type Text = string  // Text和string表示同一个类型
type U8 = uint8     // U8、uint8和 byte表示同一个类型
type char = rune    // char、rune和int32表示同一个类型

我们将上面定义的real类型和内置类型float32都称为float32类型 （注意这里的第二个float32是一个泛指，而第一个高亮的float32是一个特指）。 同样地，MyString和string都被称为字符串（string）类型，status和bool都被称为布尔（bool）类型。

## 零值
每种类型都有一个零值。一个类型的零值可以看作是此类型的默认值。
一个布尔类型的零值表示真假中的假。
数值类型的零值都是零（但是不同类型的零在内存中占用的空间可能不同）。
一个字符串类型的零值是一个空字符串。

# 基本类型的字面量表示形式
一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。

布尔值的字面量形式
Go白皮书没有定义布尔类型值字面量形式。 我们可以将false和true这两个预声明的具名常量当作布尔类型的字面量形式。 但是，我们应该知道，从严格意义上说，它们不属于字面量。具名常量声明将在下一篇文章中介绍和详细解释。

布尔类型的零值可以使用预声明的false来表示。

## 常量和变量

类型不确定值（untyped value）和类型确定值（typed value）
在Go中，有些值的类型是不确定的。换句话说，有些值的类型有很多可能性。 这些值称为类型不确定值。对于大多数类型不确定值来说，它们各自都有一个默认类型， 除了预声明的nil。nil是没有默认类型的。 我们在后续的文章中将了解到很多关于nil的知识。

与类型不确定值相对应的概念称为类型确定值。

上一章提到的字面常量（无名常量）都属于类型不确定值。 事实上，Go中大多数的类型不确定值都属于字面常量和本文即将介绍的具名常量。 少数类型不确定值包括刚提到的nil和以后会逐步接触到的某些操作的布尔返回值。

一个字面（常）量的默认类型取决于它为何种字面量形式：
一个字符串字面量的默认类型是预声明的string类型。
一个布尔字面量的默认类型是预声明的bool类型。
一个整数型字面量的默认类型是预声明的int类型。
一个rune字面量的默认类型是预声明的rune（亦即int32）类型。
一个浮点数字面量的默认类型是预声明的float64类型。
如果一个字面量含有虚部字面量，则此字面量的默认类型是预声明的complex128类型。
类型不确定常量的显式类型转换
和很多语言一样，Go也支持类型转换。 一个显式类型转换的形式为T(v)，其表示将一个值v转换为类型T。 编译器将T(v)的转换结果视为一个类型为T的类型确定值。 当然，对于一个特定的类型T，T(v)并非对任意的值v都合法。

下面介绍的规则同时适用于上一章介绍的字面常量和即将介绍的类型不确定具名常量。

对于一个类型不确定常量值v，有两种情形显式转换T(v)是合法的：
v可以表示为T类型的一个值。 转换结果为一个类型为T的类型确定常量值。
v的默认类型是一个整数类型（int或者rune） 并且T是一个字符串类型。 转换T(v)将v看作是一个Unicode码点。 转换结果为一个类型为T的字符串常量。 此字符串常量只包含一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。 对于不在合法的Unicode码点取值范围内的整数v， 转换结果等同于字符串字面量"\uFFFD"（亦即"\xef\xbf\xbd"）。 0xFFFD是Unicode标准中的（非法码点的）替换字符值。 （但是请注意，今后的Go版本可能只允许rune或者byte整数被转换为字符串。 从Go官方工具链1.15版本开始，go vet命令会对从非rune和非byte整数到字符串的转换做出警告。）
事实上，第二种情形并不要求v必须是一个常量。 如果v是一个常量，则转换结果也是一个常量。 如果v不是一个常量，则转换结果也不是一个常量。

一些合法的转换例子：
// 结果为complex128类型的1.0+0.0i。虚部被舍入了。
complex128(1 + -1e-1000i)
// 结果为float32类型的0.5。这里也舍入了。
float32(0.49999999)
// 只要目标类型不是整数类型，舍入都是允许的。
float32(17000000000000000)
float32(123)
uint(1.0)
int8(-123)
int16(6+0i)
complex128(789)

string(65)          // "A"
string('A')         // "A"
string('\u68ee')    // "森"
string(-1)          // "\uFFFD"
string(0xFFFD)      // "\uFFFD"
string(0x2FFFFFFFF) // "\uFFFD"
下面是一些非法的转换：
int(1.23)     // 1.23不能被表示为int类型值。
uint8(-1)     // -1不能被表示为uint8类型值。
float64(1+2i) // 1+2i不能被表示为float64类型值。

// -1e+1000不能被表示为float64类型值。不允许溢出。
float64(-1e1000)
// 0x10000000000000000做为int值将溢出。
int(0x10000000000000000)

// 字面量65.0的默认类型是float64（不是一个整数类型）。
string(65.0)
// 66+0i的默认类型是complex128（不是一个整数类型）。
string(66+0i)
从上面的例子可以看出，一个类型不确定数字值所表示的值可能溢出它的默认类型的表示范围。 比如上例中的-1e1000和0x10000000000000000。 一个溢出了它的默认类型的表示范围的类型不确定数字值是不能被转换到它的默认类型的（将编译报错）。

注意，有时一个显式转换形式必须被写成(T)(v)以免发生歧义。 这种情况多发生在T不为一个标识符的时候。

我们以后将在其它章节学到更多的显式类型转换规则。

类型推断介绍
Go支持类型推断（type deduction or type inference）。 类型推断是指在某些场合下，程序员可以在代码中使用一些类型不确定值， 编译器会自动推断出这些类型不确定值在特定情景下应被视为某些特定类型的值。

在Go代码中，如果某处需要一个特定类型的值并且一个类型不确定值可以表示为此特定类型的值， 则此类型不确定值可以使用在此处。Go编译器将此类型不确定值视为此特定类型的类型确定值。 这种情形常常出现在运算符运算、函数调用和赋值语句中。

有些场景对某些类型不确定值并没有特定的类型要求。在这种情况下，Go编译器将这些类型不确定值视为它们各自的默认类型的类型确定值。

上述两条类型推断规则可以被视为隐式转换规则。

本文下面的章节将展示一些类型推断的例子。 后续其它文章将会展示更多类型推断的例子和规则。

（具名）常量声明（constant declaration）
和无名字面常量一样，具名常量也必须都是布尔、数字或者字符串值。 在Go中，关键字const用来声明具名常量。 下面是一些常量声明的例子。
package main

// 声明了两个单独的具名常量。（是的，
// 非ASCII字符可以用做标识符。）
const π = 3.1416
const Pi = π // 等价于：const Pi = 3.1416

// 声明了一组具名常量。
const (
No         = !Yes
Yes        = true
MaxDegrees = 360
Unit       = "弧度"
)

func main() {
// 声明了三个局部具名常量。
const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "度"
}
Go白皮书把上面每行含有一个等号=的语句称为一个常量描述（constant specification）。 每个const关键字对应一个常量声明。一个常量声明中可以有若干个常量描述。 上面的例子中含有4个常量声明。除了第3个，其它的常量声明中都各自只有一个常量描述。 第3个常量声明中有4个常量描述。

在上面的例子中，符号*是一个乘法运算符， 符号!是一个布尔取否运算符。 运算符将在下一篇文章中详述。

常量声明中的等号=表示“绑定”而非“赋值”。 每个常量描述将一个或多个字面量绑定到各自对应的具名常量上。 或者说，每个具名常量其实代表着一个字面常量。

在上面的例子中，具名常量π和Pi都绑定到（或者说代表着）字面常量3.1416。 这两个具名常量可以在程序代码中被多次使用，从而有效避免了字面常量3.1416在代码中出现在多处。 如果字面常量3.1416在代码中出现在多处， 当我们以后欲将3.1416改为3.14的时候，所有出现在代码中的3.1416都得逐个修改。 有了具名常量的帮助，我们只需修改对应常量描述中的3.1416即可。 这是常量声明的主要作用。当然常量声明也可常常增加代码的可读性（代码即注释）。

以后，我们使用非常量这一术语表示不是常量的值。 下一节将要介绍的变量就属于非常量。

注意，常量可以直接声明在包中，也可以声明在函数体中。 声明在函数体中的常量称为局部常量（local constant），直接声明在包中的常量称为包级常量（package-level constant）。 包级常量也常常被称为全局常量。

包级常量声明中的常量描述的顺序并不重要。比如在上面的例子中， 常量描述No和Yes的顺序可以掉换一下。

上面例子中声明的所有常量都是类型不确定的。 它们各自的默认类型和它们各自代表的字面量的默认类型是一样的。

类型确定具名常量
我们可以在声明一些常量的时候指定这些常量的确切类型。 这样声明的常量称为类型确定具名常量。 在下面这个例子中，所有这4个声明的常量都是类型确定的。 X和Y的类型都是float32， A和B的类型都是int64。
const X float32 = 3.14

const (
A, B int64   = -3, 5
Y    float32 = 2.718
)
如果一个常量描述中包含多个类型确定常量，则这些常量的类型必然是一样的， 比如上例中的A和B。

我们也可以使用显式类型转换来声明类型确定常量。 下面的例子和上面的例子是完全等价的。
const X = float32(3.14)

const (
A, B = int64(-3), int64(5)
Y    = float32(2.718)
)
欲将一个字面常量绑定到一个类型确定具名常量上，此字面常量必须能够表示为此常量的确定类型的值。 否则，编译将报错。
const a uint8 = 256             // error: 256溢出uint8
const b = uint8(255) + uint8(1) // error: 256溢出uint8
const c = int8(-128) / int8(-1) // error: 128溢出int8
const MaxUint_a = uint(^0)      // error: -1溢出uint
const MaxUint_b uint = ^0       // error: -1溢出uint
在上面的例子中，符号^为位反运算符，符号+为加法运算符，符号/为除法运算符。

下面这个类型确定常量声明在64位的操作系统上是合法的，但在32位的操作系统上是非法的。 因为一个uint值在32位操作系统上的尺寸是32位， (1 << 64) - 1将溢出uint。（这里，符号<<为左移位运算符。）
const MaxUint uint = (1 << 64) - 1
那么如何声明一个代表着最大uint值的常量呢？ 我们可以用下面这个常量声明来替换上面这个。下面这个声明在64位和32位的操作系统上都是合法的。
const MaxUint = ^uint(0)
类似地，我们可以使用下面这个常量声明来声明一个具名常量来表示最大的int值。（这里，符号>>为右移位运算符。）
const MaxInt = int(^uint(0) >> 1)
使用类似的方法，我们可以声明一个常量来表示当前操作系统的位数，或者检查当前操作系统是32位的还是64位的。
const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
const Is64bitOS = ^uint(0) >> 63 != 0
const Is32bitOS = ^uint(0) >> 32 == 0
这里，符号!=和==分别为不等于和等于比较运算符。

常量声明中的自动补全
在一个包含多个常量描述的常量声明中，除了第一个常量描述，其它后续的常量描述都可以只包含标识符列表部分。 Go编译器将通过照抄前面最紧挨的一个完整的常量描述来自动补全不完整的常量描述。 比如，在编译阶段，编译器会将下面的代码
const (
X float32 = 3.14
Y                // 这里必须只有一个标识符
Z                // 这里必须只有一个标识符

	A, B = "Go", "language"
	C, _
	// 上一行中的空标识符是必需的（如果
	// 上一行是一个不完整的常量描述的话）。
)
自动补全为
const (
X float32 = 3.14
Y float32 = 3.14
Z float32 = 3.14

	A, B = "Go", "language"
	C, _ = "Go", "language"
)
在常量声明中使用iota
iota是Go中预声明（内置）的一个特殊的具名常量。 iota被预声明为0，但是它的值在编译阶段并非恒定。 当此预声明的iota出现在一个常量声明中的时候，它的值在第n个常量描述中的值为n（从0开始）。 所以iota只对含有多个常量描述的常量声明有意义。

iota和常量描述自动补全相结合有的时候能够给Go编程带来很大便利。 比如，下面是一个使用了这两个特性的例子。 请阅读代码注释以了解清楚各个常量被绑定的值。
package main

func main() {
const (
k = 3 // 在此处，iota == 0

		m float32 = iota + .5 // m float32 = 1 + .5
		n                     // n float32 = 2 + .5

		p = 9             // 在此处，iota == 3
		q = iota * 2      // q = 4 * 2
		_                 // _ = 5 * 2
		r                 // r = 6 * 2
		s, t = iota, iota // s, t = 7, 7
		u, v              // u, v = 8, 8
		_, w              // _, w = 9, 9
	)

	const x = iota // x = 0 （iota == 0）
	const (
		y = iota // y = 0 （iota == 0）
		z        // z = 1
	)

	println(m)             // +1.500000e+000
	println(n)             // +2.500000e+000
	println(q, r)          // 8 12
	println(s, t, u, v, w) // 7 7 8 8 9
	println(x, y, z)       // 0 0 1
}
上面的例子只是展示了一下如何使用iota。 在实际编程中，我们应该用有意义的方式使用之。比如：
const (
Failed = iota - 1 // == -1
Unknown           // == 0
Succeeded         // == 1
)

const (
Readable = 1 << iota // == 1
Writable             // == 2
Executable           // == 4
)
在上面这段代码中，-是一个减法运算符。

变量声明和赋值操作语句
变量可以被看作是在运行时刻存储在内存中并且可以被更改的具名的值。

所有的变量值都是类型确定值。当声明一个变量的时候，我们必须在代码中给编译器提供足够的信息来让编译器推断出此变量的确切类型。

在一个函数体内声明的变量称为局部变量。 在任何函数体外声明的变量称为包级或者全局变量。

Go语言有两种变量声明形式。一种称为标准形式，另一种称为短声明形式。 短声明形式只能用来声明局部变量。

标准变量声明形式
每条标准变量声明形式语句起始于一个var关键字。 每个var关键字跟随着一个变量名。 每个变量名必须为一个标识符。

下面是几条完整形式的标准变量声明语句。 这些声明确地指定了被声明的变量的类型和初始值。
var lang, website string = "Go", "https://golang.org"
var compiled, dynamic bool = true, false
var announceYear int = 2009
我们可以看到，和常量声明一样，多个同类型的变量可以在一条语句中被声明。

完整形式的标准变量声明使用起来有些罗嗦，因此很少在日常Go编程中使用。 在日常Go编程中，另外两种变种形式用得更广泛一些。 一种变种形式省略了变量类型（但仍指定了变量的初始值），这时编译器将根据初始值的字面量形式来推断出变量的类型。 另一种变种形式省略了初始值（但仍指定了变量类型），这时编译器将使用变量类型的零值做为变量的初始值。

下面是一些第一种变种形式的用例。在这些用例中，如果一个初始值是一个类型确定值，则对应声明的变量的类型将被推断为此初始值的类型； 如果一个初始值是一个类型不确定值，则对应声明的变量的类型将被推断为此初始值的默认类型。 注意在这种变种中，同时声明的多个变量的类型可以不一样。
// 变量lang和dynamic的类型将被推断为内置类型string和bool。
var lang, dynamic = "Go", false

// 变量compiled和announceYear的类型将被推断
// 为内置类型bool和int。
var compiled, announceYear = true, 2009

// 变量website的类型将被推断为内置类型string。
var website = "https://golang.org"
上例中的类型推断可以被视为隐式类型转换。

下例展示了几个省略了初始值的标准变量声明。每个声明的变量的初始值为它们各自的类型的零值。
var lang, website string      // 两者都被初始化为空字符串。
var interpreted, dynamic bool // 两者都被初始化为false。
var n int                     // 被初始化为0。
和常量声明一样，多个变量可以用一对小括号组团在一起被声明。
var (
lang, bornYear, compiled     = "Go", 2007, true
announceAt, releaseAt    int = 2009, 2012
createdBy, website       string
)
上面这个变量声明语句已经被go fmt命令格式化过了。 这个变量声明语句包含三个变量描述（variable specification）。

一般来说，将多个相关的变量声明在一起将增强代码的可读性。

纯赋值语句
在上面展示的变量声明的例子中，等号=表示赋值。 一旦一个变量被声明之后，它的值可以被通过纯赋值语句来修改。 多个变量可以同时在一条赋值语句中被修改。

一个赋值语句等号左边的表达式必须是一个可寻址的值、一个映射元素或者一个空标识符。 内存地址（以及指针）和映射将在以后的文章中介绍。

常量是不可改变的（不可寻址的），所以常量不能做为目标值出现在纯赋值语句的左边，而只能出现在右边用做源值。 变量既可以出现在纯赋值语句的左边用做目标值，也可以出现在右边用做源值。

空标识符也可以出现在纯赋值语句的左边，表示不关心对应的目标值。 空标识符不可被用做源值。

一个包含了很多（合法或者不合法的）纯赋值语句的例子：
const N = 123
var x int
var y, z float32

N = 789 // error: N是一个不可变量
y = N   // ok: N被隐式转换为类型float32
x = y   // error: 类型不匹配
x = N   // ok: N被隐式转换为类型int
y = x   // error: 类型不匹配
z = y   // ok
_ = y   // ok

z, y = y, z               // ok
_, y = y, z               // ok
z, _ = y, z               // ok
_, _ = y, z               // ok
x, y = 69, 1.23           // ok
x, y = y, x               // error: 类型不匹配
x, y = int(y), float32(x) // ok
上例中的最后一行使用了显式类型转换，否则此赋值（见倒数第二行）将不合法。 数字非常量值的类型转换规则将在后边的章节介绍。

Go不支持某些其它语言中的连等语法。下面的赋值语句在Go中是不合法的。
var a, b int
a = b = 123 // 语法错误
短变量声明形式
我们也可以用短变量声明形式来声明一些局部变量。比如下例：
package main

func main() {
// 变量lang和year都为新声明的变量。
lang, year := "Go language", 2007

	// 这里，只有变量createdBy是新声明的变量。
	// 变量year已经在上面声明过了，所以这里仅仅
	// 改变了它的值，或者说它被重新声明了。
	year, createdBy := 2009, "Google Research"

	// 这是一个纯赋值语句。
	lang, year = "Go", 2012

	print(lang, "由", createdBy, "发明")
	print("并发布于", year, "年。")
	println()
}
每个短声明语句中必须至少有一个新声明的变量。

从上面的例子中，我们可以看到短变量声明形式和标准变量声明形式有几个显著的区别：
短声明形式不包含var关键字，并且不能指定变量的类型。
短变量声明中的赋值符号必须为:=。
在一个短声明语句的左侧，已经声明过的变量和新声明的变量可以共存。 但在一个标准声明语句中，所有出现在左侧的变量必须都为新声明的变量。
注意，相对于纯赋值语句，目前短声明语句有一个限制：出现在一个短声明左侧的项必须都为纯标识符。 以后我们将学习到在纯赋值语句的左边可以出现结构体值的字段，指针的解引用和容器类型值的元素索引项等。 但是这些项不能出现在一个变量短声明语句的左边。

关于“赋值”这个术语
以后，当“赋值”这个术语被提到的时候，它可以指一个纯赋值、一个短变量声明或者一个初始值未省略的标准变量声明。 事实上，一个更通用的定义包括后续文章将要介绍的函数传参。

当y = x是一条合法的赋值语句时，我们可以说x可以被赋给y。 假设y的类型为Ty，有时为了叙述方便，我们也可以说x可以被赋给类型Ty。

一般来说，如果x可以被赋给y，则y应该是可修改的，并且x和y的类型相同或者x可以被隐式转换到y的类型。 当然，y也可以是空标识符_。

每个局部声明的变量至少要被有效使用一次
注意，当使用目前的主流Go编译器编译Go代码时，一个局部变量被声明之后至少要被有效使用一次，否则编译器将报错。 包级变量无此限制。 如果一个变量总是被当作赋值语句中的目标值，那么我们认为这个变量没有被有效使用过。

下面这个例子编译不通过。
package main

var x, y, z = 123, true, "foo" // 包级变量

func main() {
var q, r = 789, false
r, s := true, "bar"
r = y // r没有被有效使用。
x = q // q被有效使用了。
}
当编译上面这个程序的时候，编译器将报错（这个程序代码存在一个名为example-unused.go的文件中）：
./example-unused.go:6:6: r declared and not used
./example-unused.go:7:16: s declared and not used
避免编译器报错的方法很简单，要么删除相关的变量声明，要么像下面这样，将未曾有效使用过的变量（这里是r和s）赋给空标识符。
package main

var x, y, z = 123, true, "foo"

func main() {
var q, r = 789, false
r, s := true, "bar"
r = y
x = q

	_, _ = r, s // 将r和s做为源值使用一次。
}
若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序
下面这个例子中的声明的变量的初始化顺序为y = 5、c = y、b = c+1、a = b+1、x = a+1。
var x, y = a+1, 5         // 8 5
var a, b, c = b+1, c+1, y // 7 6 5
包级变量在初始化的时候不能相互依赖。比如，下面这个变量声明语句编译不通过。
var x, y = y, x
值的可寻址性
在Go中，有些值是可以被寻址的。上面已经提到所有变量都是可以寻址的，所有常量都是不可被寻址。 我们可以从后面的指针一文了解更多关于内存地址和指针的知识。

非常量数字值相关的显式类型转换规则
在Go中，两个类型不一样的基本类型值是不能相互赋值的。 我们必须使用显式类型转换将一个值转换为另一个值的类型之后才能进行赋值。

前面某节已经提到了整数（不论常量还是非常量）都可以被显式转换为字符串类型。 这里再介绍两个不同类型数字值之间的转换规则。
一个非常量浮点数和整数可以显式转换到其它任何一个浮点数和整数类型。
一个非常量复数可以显式转换到其它任何一个复数类型。
上面已经提到，常量数字值的类型转换不能溢出。此规则不适用于非常量数字值的类型转换。 非常量数字值的类型转换中，溢出是允许的。 另外当将一个浮点数非常量值（比如一个变量）转换为一个整数类型的时候，舍入（或者精度丢失）也是允许的。 具体规则如下：
当从一个比特位数多的整数类型的非常量整数值向一个比特位数少的整数类型转换的时候，高位的比特将被舍弃，低位的比特将被保留。我们称这种处理方式为截断（truncated）。
当从一个非常量的浮点数向一个整数类型转换的时候，浮点数的小数部分将被舍弃（向零靠拢）。
当从一个非常量整数或者浮点数向一个浮点数类型转换的时候，精度丢失是可以发生的。
当从一个非常量复数向另一个复数类型转换的时候，精度丢失也是可以发生的。
当一个显式转换涉及到非常量浮点数或者复数数字值时，如果源值溢出了目标类型的表示范围，则转换结果取决于具体编译器实现（即行为未定义）。
在下面的例子中，第7行和第15行的隐式转换是不允许的，第5行和第14行的显式转换也是不允许的。
const a = -1.23
// 变量b的类型被推断为内置类型float64。
var b = a
// error: 常量1.23不能被截断舍入到一个整数。
var x = int32(a)
// error: float64类型值不能被隐式转换到int32。
var y int32 = b
// ok: z == -1，变量z的类型被推断为int32。
//     z的小数部分将被舍弃。
var z = int32(b)

const k int16 = 255
var n = k            // 变量n的类型将被推断为int16。
var f = uint8(k + 1) // error: 常量256溢出了uint8。
var g uint8 = n + 1  // error: int16值不能隐式转换为uint8。
var h = uint8(n + 1) // ok: h == 0，变量h的类型为uint8。
// (n+1)溢出uint8，所以只有低8位
// bits（都为0）被保留。
第3行的隐式转换中，a被转换为它的默认类型（float64）；因此b的类型被推断为float64。

变量和常量的作用域
在Go中，我们可以使用一对大括号来显式形成一个（局部）代码块。一个代码块可以内嵌另一个代码块。 最外层的代码块称为包级代码块。 一个声明在一个内层代码块中的常量或者变量将遮挡另一个外层代码块中声明的同名变量或者常量。 比如，下面的代码中声明了3个名为x的变量。 内层的x将遮挡外层的x， 从而外层的x在内层的x声明之后在内层中将不可见。
package main

const y = 70
var x int = 123 // 包级变量

func main() {
// 此x变量遮挡了包级变量x。
var x = true

	// 一个内嵌代码块。
	{
		x, y := x, y-10 // 这里，左边的x和y均为新声明
		                // 的变量。右边的x为外层声明的
		                // bool变量。右边的y为包级变量。

		// 在此内层代码块中，从此开始，
		// 刚声明的x和y将遮挡外层声明x和y。

		x, z := !x, y/10 // z是一个新声明的变量。
		                 // x和y是上一句中声明的变量。
		println(x, y, z) // false 60 6
	}
	println(x) // true
	println(y) // 70 （包级变量y从未修改）
	/*
	println(z) // error: z未定义。
	           // z的作用域仅限于上面的最内层代码块。
	*/
}
刚提到的作用域是指一个标识符的可见范围。 一个包级变量或者常量的作用域为其所处于的整个代码包。 一个局部变量或者常量的作用域开始于此变量或者常量的声明的下一行，结束于最内层包含此变量或者常量的声明语句的代码块的结尾。 这解释了为什么上例中的println(z)将编译不通过。

后面的代码块和作用域一文将详述代码块和标识符的作用域。

更多关于常量声明
一个类型不确定常量所表示的值可以溢出其默认类型
比如，下例中的三个类型不确定常量均溢出了它们各自的默认类型，但是此程序编译和运行都没问题。
package main

// 三个类型不确定常量。
const n = 1 << 64          // 默认类型为int
const r = 'a' + 0x7FFFFFFF // 默认类型为rune
const x = 2e+308           // 默认类型为float64

func main() {
_ = n >> 2
_ = r - 0x7FFFFFFF
_ = x / 2
}
但是下面这个程序编译不通过，因为三个声明的常量为类型确定常量。
package main

// 三个类型确定常量。
const n int = 1 << 64           // error: 溢出int
const r rune = 'a' + 0x7FFFFFFF // error: 溢出rune
const x float64 = 2e+308        // error: 溢出float64

func main() {}
每个常量标识符将在编译的时候被其绑定的字面量所替代
常量声明可以看作是增强型的C语言中的#define宏。 在编译阶段，所有的标识符将被它们各自绑定的字面量所替代。

如果一个运算中的所有运算数都为常量，则此运算的结果也为常量。或者说，此运算将在编译阶段就被估值。 下一篇文章将介绍Go中的常用运算符。

一个例子：
package main

const X = 3
const Y = X + X
var a = X

func main() {
b := Y
println(a, b, X, Y)
}
上面这段程序代码将在编译阶段被重写为下面这样：
package main

var a = 3

func main() {
b := 6
println(a, b, 3, 6)
}

## 运算操作符
关于本文中的内容和一些解释
本文只介绍算术运算符、位运算符、比较运算符、布尔运算符和字符串衔接运算符。 这些运算符要么是二元的（需要两个操作数），要么是一元的（需要一个操作数）。 所有这些运算符运算都只返回一个结果。操作数常常也称为操作值。

本文中的解释不追求描述的完全准确性。 比如，当我们说一个二元运算符运算需要其涉及的两个操作数类型必须一样的时，这指：
如果这两个操作数都是类型确定值，则它们的类型必须相同，或者其中一个操作数可以被隐式转换到另一个操作数的类型。
如果其中只有一个操作数是类型确定的，则要么另外一个类型不确定操作数可以表示为此类型确定操作数的类型的值，要么此类型不确定操作数的默认类型的任何值可以被隐式转换到此类型确定操作数的类型。
如果这两个操作数都是类型不确定的，则它们必须同时都为两个布尔值，同时都为两个字符串值，或者同时都为两个基本数字值。
类似的，当我们说一个运算符（一元或者二元）运算要求其涉及的某个操作数的类型必须为某个特定类型时，这指：
如果这个操作数是类型确定的，则它的类型必须为所要求的特定类型，或者此操作数可以被隐式转换为所要求的特定类型。
如果一个操作数是类型不确定的，则要么此操作数可以表示为所要求的特定类型值，要么此操作数的默认类型的任何值可以被隐式转换为所要求的特定类型。
常量表达式
在继续下面的章节之前，我们需要知道什么叫常量表达式和关于常量表达式估值的一个常识。 表达式的概念将在表达式和语句一文中得到解释。 目前我们只需知道本文中所提及的大多数运算都属于表达式。 当一个表达式中涉及到的所有操作数都是常量时，此表达式称为一个常量表达式。 一个常量表达式的估值是在编译阶段进行的。一个常量表达式的估值结果依然是一个常量。 如果一个表达式中涉及到的操作数中至少有一个不为常量，则此表达式称为非常量表达式。

算术运算符
Go支持五个基本二元算术运算符：

字面形式	名称	对两个运算数的要求
+	加法	两个运算数的类型必须相同并且为基本数值类型。
-	减法
*	乘法
     /	除法
     %	余数	两个运算数的类型必须相同并且为基本整数数值类型。
     Go支持六种位运算符（也属于算术运算）：

字面形式	名称	对两个操作数的要求以及机制解释

&

位与
两个操作数的类型必须相同并且为基本整数数值类型。

机制解释（下标2表明一个字面量为二进制）：
11002 & 10102 得到 10002
11002 | 10102 得到 11102
11002 ^ 10102 得到 01102
11002 &^ 10102 得到 01002

|

位或

^

（位）异或

&^

清位


<<


左移位
左操作数必须为一个整数，右操作数也必须为一个整数（如果它是一个常数，则它必须非负），但它们的类型可以不同。 （注意：在Go 1.13之前，右操作数必须为一个无符号整数类型的类型确定值或者一个可以表示成uint值的类型不确定常数值。）

一个负右操作数（非常数）将在运行时刻造成一个恐慌。

机制解释：
11002 << 3 得到 11000002（低位补零）
11002 >> 3 得到 12（低位被舍弃）
注意，在右移运算中，左边空出来的位（即高位）全部用左操作数的最高位（即正负号位）填充。 比如如果左操作数-128的类型为int8（二进制补码表示为100000002）， 则100000002 >> 2的二进制补码结果为111000002（即-32）。



>>


右移位
Go也支持三个一元算术运算符：

字面形式	名称	解释
+	取正数	+n等价于0 + n.
-	取负数	-n等价于0 - n.
     ^	位反（或位补）	^n等价于m ^ n，其中m和n同类型并且它的二进制表示中所有比特位均为1。 比如如果n的类型为int8，则m的值为-1；如果n的类型为uint8，则m的值为255。
     注意：
     在很多其它流行语言中，位反运算符是用~表示的。
     和一些其它流行语言一样，加号运算符+也可用做字符串衔接运算符（见下）。
     和C及C++语言一样，*除了可以当作乘号运算符，它也可以用做指针解引用运算符； &除了可以当作位与运算符，它也可以用做取地址运算符。 后面的指针一文将详解内存地址和指针类型。
     和Java不一样，Go支持无符号数，所以Go不需要无符号右移运算符>>>。
     Go不支持幂运算符， 我们必须使用math标准库包中的Pow函数来进行幂运算。 下一篇文章将详解包和包引入。
     清位运算符&^是Go中特有的一个运算符。 m &^ n等价于m & (^n)。
     一些运算符的使用示例：
     func main() {
     var (
     a, b float32 = 12.0, 3.14
     c, d int16   = 15, -6
     e	uint8   = 7
     )

	// 这些行编译没问题。
	_ = 12 + 'A' // 两个类型不确定操作数（都为数值类型）
	_ = 12 - a   // 12将被当做a的类型（float32）使用。
	_ = a * b    // 两个同类型的类型确定操作数。
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// 这些行编译将失败。
	_ = a % b   // error: a和b都不是整数
	_ = a | b   // error: a和b都不是整数
	_ = c + e   // error: c和e的类型不匹配
	_ = b >> 5  // error: b不是一个整数
	_ = c >> -5 // error: -5不是一个无符号整数

	_ = e << uint(c) // 编译没问题
	_ = e << c       // 从Go 1.13开始，此行才能编译过
	_ = e << -c      // 从Go 1.13开始，此行才能编译过。
	                 // 将在运行时刻造成恐慌。
	_ = e << -1      // error: 右操作数不能为负（常数）
}
关于溢出
上一篇文章提到了
一个类型确定数字型常量所表示的值是不能溢出它的类型的表示范围的。
一个类型不确定数字型常量所表示的值是可以溢出它的默认类型的表示范围的。 当一个类型不确定数字常量值溢出它的默认类型的表示范围时，此数值不会被截断（亦即回绕）。
将一个非常量数字值转换为其它数字类型时，此非常量数字值可以溢出转化结果的类型。 在此转换中，当溢出发生时，转化结果为此非常量数字值的截断（亦即回绕）表示。
对于一个算数运算的结果，上述规则同样适用。

示例：
// 结果为非常量
var a, b uint8 = 255, 1
var c = a + b  // c==0。a+b是一个非常量表达式，
// 结果中溢出的高位比特将被截断舍弃。
var d = a << b // d == 254。同样，结果中溢出的
// 高位比特将被截断舍弃。

// 结果为类型不确定常量，允许溢出其默认类型。
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // 没问题，尽管X溢出
const R = 'a' + 0x7FFFFFFF          // 没问题，尽管R溢出

// 运算结果或者转换结果为类型确定常量
var e = X                // error: X溢出int。
var h = R                // error: R溢出rune。
const Y = 128 - int8(1)  // error: 128溢出int8。
const Z = uint8(255) + 1 // error: 256溢出uint8。
关于算术运算的结果
除了移位运算，对于一个二元算术运算，
如果它的两个操作数都为类型确定值，则此运算的结果也是一个和这两个操作数类型相同的类型确定值。
如果只有一个操作数是类型确定的，则此运算的结果也是一个和此类型确定操作数类型相同的类型确定值。 另一个类型不确定操作数的类型将被推断为（或隐式转换为）此类型确定操作数的类型。
如果它的两个操作数均为类型不确定值，则此运算的结果也是一个类型不确定值。 在运算中，两个操作数的类型将被设想为它们的默认类型中一个（按照此优先级来选择：complex128高于float64高于rune高于int）。 结果的默认类型同样为此设想类型。 比如，如果一个类型不确定操作数的默认类型为int，另一个类型不确定操作数的默认类型为rune， 则前者的类型在运算中也被视为rune，运算结果为一个默认类型为rune的类型不确定值。
对于移位运算，结果规则有点小复杂。首先移位运算的结果肯定都是整数。
如果左操作数是一个类型确定值（则它的类型必定为整数），则此移位运算的结果也是一个和左操作数类型相同的类型确定值。
如果左操作数是一个类型不确定值并且右操作数是一个常量，则左操作数将总是被视为一个整数。 如果它的默认类型不是一个整数（rune或int），则它的默认类型将被视为int。 此移位运算的结果也是一个类型不确定值并且它的默认类型和左操作数的默认类型一致。
如果左操作数是一个类型不确定值并且右操作数是一个非常量，则左操作数将被首先转化为运算结果的期待设想类型。 如果期待设想类型并没有被指定，则左操作数的默认类型将被视为它的期待设想类型。 如果此期待设想类型不是一个内置整数类型，则编译报错。 当然最终运算结果是一个类型为此期待设想类型的类型确定值。
一些非移位算术运算的例子：
func main() {
// 三个类型不确定常量。它们的默认类型
// 分别为：int、rune和complex64.
const X, Y, Z = 2, 'A', 3i


	var a, b int = X, Y // 两个类型确定值

	// 变量d的类型被推断为Y的默认类型：rune（亦即int32）。
	d := X + Y
	// 变量e的类型被推断为a的类型：int。
	e := Y - a
	// 变量f的类型和a及b的类型一样：int。
	f := a * b
	// 变量g的类型被推断为Z的默认类型：complex64。
	g := Z * Y

	// 2 65 (+0.000000e+000+3.000000e+000i)
	println(X, Y, Z)
	// 67 63 130 (+0.000000e+000+1.950000e+002i)
	println(d, e, f, g)
}
一个移位算术运算的例子：
const N = 2
// A == 12，它是一个默认类型为int的类型不确定值。
const A = 3.0 << N
// B == 12，它是一个类型为int8的类型确定值。
const B = int8(3.0) << N

var m = uint(32)
// 下面的三行是相互等价的。
var x int64 = 1 << m  // 1的类型将被设想为int64，而非int
var y = int64(1 << m) // 同上
var z = int64(1) << m // 同上

// 下面这行编译不通过。
/*
var _ = 1.23 << m // error: 浮点数不能被移位
*/
上面提到的移位运算结果的最后一点类型推断规则有点反常。 这条规则的主要目的是为了防止一些移位运算在32位架构和64位架构的机器上的运算结果出现不一致但不一致却没有被及时发现的情况。 比如如果上面一段代码中第10行（或第9行）的1的类型被推断为它的默认类型int， 则在32位架构的机器上，x的取值在运行时刻将被截断为0，而在64位架构的机器上，x的取值在运行时刻将为232。 因为m是一个变量，在32位架构的机器上，第9行和第10行并不会在编译时刻报错。 这将导致Go程序员在不经意间写出没有料到的和难以觉察的bug。 因此，第9行和第10行中的1的类型被推断为int64（最终的设想结果类型），而不是它们的默认类型int。

下面这段代码展示了对于左操作数为类型不确定值的移位运算，编译结果因右操作数是否为常量而带来的不同结果：
const n = uint(2)
var m = uint(2)

// 这两行编译没问题。
var _ float64 = 1 << n
var _ = float64(1 << n)

// 这两行编译失败。
var _ float64 = 1 << m  // error
var _ = float64(1 << m) // error
上面这段代码最后两行编译失败是因为它们都等价于下面这两行：
var _ = float64(1) << m
var _ = 1.0 << m // error: shift of type float64
另一个例子：
package main

const n = uint(8)
var m = uint(8)

func main() {
println(a, b) // 2 0
}

var a byte = 1 << n / 128
var b byte = 1 << m / 128
上面这个程序打印出2 0，因为最后两行等价于：
var a = byte(int(1) << n / 128)
var b = byte(1) << m / 128
关于除法和余数运算
假设两个操作数x和y的类型为同一个整数类型， 则它们通过除法和余数运算得到的商q（= x / y）和余数r（= x % y）满足x == q*y + r（|r| < |y|）。如果余数r不为零，则它的符号和被除数x相同。商q的结果为x / y向零靠拢截断。

如果除数y是一个常量，则它必须不为0，否则编译不通过。 如果它是一个整数型非常量，则在运行时刻将抛出一个恐慌（panic）。 恐慌类似与某些其它语言中的异常（exception）。 我们将在以后的文章中了解到Go中的恐慌和恐慌恢复机制。 如果除数y非整数型的非常量，则运算结果为一个无穷大（Inf，当被除数不为0时）或者NaN（not a number，当被除数为0时）。

示例：
println( 5/3,   5%3)  // 1 2
println( 5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)     // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // 编译没问题，但在运行时刻将造成恐慌。

// 这两行编译不通过。
println(1.0/0.0) // error: 除数为0
println(0.0/0.0) // error: 除数为0
op=运算符
对于一个二元算数运算符op，语句x = x op y可以被简写为x op= y。 在这个简写的语句中，x只会被估值一次。

示例：
var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b <<= uint(a)
println(b) // 20
自增和自减操作符
和很多其它流行语言一样，Go也支持自增（++）和自减（--）操作符。 不过和其它语言不一样的是，自增（aNumber++）和自减（aNumber--）操作没有返回值， 所以它们不能当做表达式来使用。 另一个显著区别是，在Go中，自增（++）和自减（--）操作符只能后置，不能前置。

一个例子：
package main

func main() {
a, b, c := 12, 1.2, 1+2i
a++ // ok. <=> a += 1 <=> a = a + 1
b-- // ok. <=> b -= 1 <=> b = b - 1
c++ // ok.

	// 下面这些行编译不通过。
	/*
	_ = a++
	_ = b--
	_ = c++
	++a
	--b
	++c
	*/
}
字符串衔接运算符
上面已经提到了，加法运算符也可用做字符串衔接运算符。
字面形式	名称	对两个操作数的要求
+	字符串衔接	两个操作数必须为同一类型的字符串值。
     +=运算符也适用于字符串衔接。

示例：
println("Go" + "lang") // Golang
var a = "Go"
a += "lang"
println(a) // Golang
如果一个字符串衔接运算中的一个操作值为类型确定的，则结果字符串是一个类型和此操作数类型相同的类型确定值。 否则，结果字符串是一个类型不确定值（肯定是一个常量）。

布尔（又称逻辑）运算符
Go支持两种布尔二元运算符和一种布尔一元运算符。

字面形式	名称	对操作值的要求
&&	布尔与（二元）	两个操作值的类型必须为同一布尔类型。
||	布尔或（二元）
!	布尔否（一元）	唯一的一个操作值的类型必须为一个布尔类型。
我们可以用下一小节介绍的不等于操作符!=来做为布尔异或操作符。

机理解释：
// x    y       x && y   x || y   !x      !y
true    true    true     true     false   false
true    false   false    true     false   true
false   true    false    true     true    false
false   false   false    false    true    true
如果一个布尔运算中的一个操作值为类型确定的，则结果为一个和此操作值类型相同的类型确定值。 否则，结果为一个类型不确定布尔值。

比较运算符
Go支持6种比较运算符：

字面形式	名称	对两个操作值的要求


==


等于
如果两个操作数都为类型确定的，则它们的类型必须一样，或者其中一个操作数可以隐式转换为另一个操作数的类型。 两者的类型必须都为可比较类型（将在以后的文章中介绍）。

如果只有一个操作数是类型确定的，则另一个类型不确定操作数必须可以隐式转换到类型确定操作数的类型。

如果两个操作数都是类型不确定的，则它们必须同时为两个类型不确定布尔值、两个类型不确定字符串值或者两个类型不确定数字值。



!=


不等于
<	小于	两个操作值的类型必须相同并且它们的类型必须为整数类型、浮点数类型或者字符串类型。
<=	小于或等于
>	大于
>=	大于或等于
比较运算的结果总是一个类型不确定布尔值。 如果一个比较运算中的两个操作数都为常量，则结果布尔值也为一个常量。

以后，如果我们说两个值可以比较，我们的意思是说这两个值可以用==或者!=运算符来比较。 我们将在以后的文章中，我们将了解到某些类型的值是不能比较的。

注意，并非所有的实数在内存中都可以被精确地表示，所以比较两个浮点数或者复数的结果并不是很可靠。 在编程中，我们常常比较两个浮点数的差值是否小于一个阙值来检查两个浮点数是否相等。

操作符运算的优先级
Go中的操作符运算的优先级和其它流行语言有一些差别。 下面列出了本文介绍的操作符的优先级。 同一行中的操作符的优先级是一样的。优先级逐行递减。

*   /   %   <<  >>  &   &^
+   -   |   ^
        ==  !=  <   <=  >   >=
        &&
        ||
        一个和其它流行语言明显的差别是，移位运算<<和>>的优先级比加减法+和-的优先级要高。

一个表达式（做为一个子表达式）可以出现在另一个表达式中。 这个子表达式的估值结果将成为另一个表达式的一个操作数。 在这样的复杂表达式中，对于相同优先级的运算，它们将从左到右进行估值。 和很多其它语言一样，我们也可用一对小括号()来提升一个子运算的优先级。

更多关于常量表达式
常量子表达式的顺序有可能影响到最终的估值结果。

下面这个声明的变量将被初始化为2.2，而不是2.7。 优先级更高的子表达式3/2是一个常量表达式，所以它将在编译阶段被估值。 根据上面介绍的规则，在运算中，3和2都被视为int，所以3/2的估值结果为1。 在常量表达式1.2 + 1的运算中，两个操作数的类型被视为float64，所以最终的估值结果为2.2。
var x = 1.2 + 3/2
再比如下例，在一个常量声明中，3/2先被估值，其结果为1，所以最终的估值结果为0.1。 在第二个常量声明中，0.1*3先被估值，其结果为0.3，所以最终的估值结果为0.15。
package main

const x = 3/2*0.1
const y = 0.1*3/2

func main() {
println(x) // +1.000000e-001
println(y) // +1.500000e-001
}

## 函数声明和调用

函数声明
让我们来看一个函数声明：
func SquaresOfSumAndDiff(a int64, b int64) (s int64, d int64) {
x, y := a + b, a - b
s = x * x
d = y * y
return // <=> return s, d
}
从上面的例子中，我们可以发现一个函数声明从左到右由以下部分组成：
第一部分是func关键字。
第二部分是函数名称。函数名称必须是一个标识符。 这里的函数名称是SquareOfSumAndDiff。
第三部分是输入参数列表。输入参数声明列表必须用一对小括号括起来。 输入参数声明有时也称为形参声明（对应后面将介绍的函数调用中的实参）。
第四部分是输出结果声明列表。在Go中，一个函数可以有多个返回值。 比如上面这个例子就有两个返回值。 当一个函数的输出结果声明列表为空或者只包含一个匿名结果声明时，此列表可以不用一对小括号括起来（见下面的示例）；否则，小括号是必需的。
最后一部分是函数体。函数体必须用一对大括号括起来。 一对大括号和它其间的代码形成了一个显式代码块。 在一个函数体内，return关键字可以用来结束此函数的正常向前执行流程并进入此函数的退出阶段（详见下下节中的解释）。
在上面的例子中，每个函数参数和结果声明都由一个名字和一个类型组成（变量名字在前，类型在后）。 我们可以把一个参数和结果声明看作是一个省略了var关键字的标准变量声明。 上面这个函数有两个输入参数（a和b）以及两个输出结果（x和y）。 它们的类型都是int64。

输出结果声明列表中的所有声明中的结果名称可以（而且必须）同时出现或者同时省略。 这两种方式在实践中都使用得很广泛。 如果一个返回结果声明中的结果名称没有省略，则这个返回结果称为具名返回结果。否则称为匿名返回结果。

如果一个函数声明的所有返回结果均为匿名的，则在此函数体内的返回语句return关键字后必须跟随一系列返回值，这些返回值和此函数的各个返回结果声明一一对应。比如，下面这个函数声明和上例中的函数声明是等价的。
func SquaresOfSumAndDiff(a int64, b int64) (int64, int64) {
return (a+b) * (a+b), (a-b) * (a-b)
}
事实上，如果一个函数声明中的所有输入参数在此函数体内都没有被使用过，则它们也可以都同时是匿名的。 不过这种情形在实际编程中很少见。

尽管一个函数声明中的输入参数和返回结果看上去是声明在这个函数体的外部，但是在此函数体内，这些输入参数和输出结果被当作局部变量来使用。 但输入参数和输出结果和普通局部变量还是有一点区别的：目前的主流Go编译器不允许一个名称不为_的普通局部变量被声明而不有效使用。

Go不支持输入参数默认值。每个返回结果的默认值是它的类型的零值。 比如，下面的函数在被调用时将打印出（和返回）0 false。
func f() (x int, y bool) {
println(x, y) // 0 false
return
}
和普通的变量声明一样，如果若干连续的输入参数或者返回结果的类型相同，则在它们的声明中可以共用一个类型。 比如，上面的两个SquaresOfSumAndDiff函数声明和下面这个是完全等价的。
func SquaresOfSumAndDiff(a, b int64) (s, d int64) {
return (a+b) * (a+b), (a-b) * (a-b)
// 上面这行等价于下面这行：
// s = (a+b) * (a+b); d = (a-b) * (a-b); return
}
注意，尽管在上面这个函数声明的返回结果都是具名的，函数体内的return关键字后仍然可以跟返回值。

如果一个函数声明只包含一个返回结果，并且此返回结果是匿名的，则此函数声明中的返回结果部分不必用小括号括起来。 如果一个函数声明的返回结果列表为空，则此函数声明中的返回结果部分可以完全被省略掉。 一个函数声明的输入参数列表部分总不能省略掉，即使此函数声明的输入参数列表为空。

下面是更多函数声明的例子：
func CompareLower4bits(m, n uint32) (r bool) {
// 下面这两行等价于：return m&0xFF > n&0xff
r = m&0xF > n&0xf
return
}

// 此函数没有输入参数。它的结果声明列表只包含一个
// 匿名结果声明，因此它不必用()括起来。
func VersionString() string {
return "go1.0"
}

// 此函数没有返回结果。它的所有输入参数都是匿名的。
// 它的结果声明列表为空，因此可以被省略掉。
func doNothing(string, int) {
}
在前面的《Go语言101》文章中，我们已经知道一个程序的main入口函数必须不带任何输入参数和返回结果。

注意，在Go中，所有函数都必须直接声明在包级代码块中。 或者说，任何一个函数都不能被声明在另一个函数体内。 虽然匿名函数（将在下面的某节中介绍）可以定义在函数体内，但匿名函数定义不属于函数声明。

函数调用
一个声明的函数可以通过它的名称和一个实参列表来调用之。 一个实参列表必须用小括号括起来。 实参列表中的每一个单值实参对应着（或称被传递给了）一个形参。

注意：函数传参也属于赋值操作。在传参中，各个实参被赋值给各个对应形参。

一个实参值的类型不必一定要和其对应的形参声明的类型一样。 但如果一个实参值的类型和其对应的形参声明的类型不一致，则此实参必须能够隐式转换到其对应的形参的类型。

如果一个函数带有返回值，则它的一个调用被视为一个表达式。如果此函数返回多个结果，则它的每个调用被视为一个多值表达式。 一个多值表达式可以被同时赋值给多个目标值（数量必须匹配，各个输出结果被赋值给相对应的目标值）。

下面这个例子完整地展示了如何调用几个已经声明了的函数。
package main

func SquaresOfSumAndDiff(a int64, b int64) (int64, int64) {
return (a+b) * (a+b), (a-b) * (a-b)
}

func CompareLower4bits(m, n uint32) (r bool) {
r = m&0xF > n&0xf
return
}

// 使用一个函数调用的返回结果来初始化一个包级变量。
var v = VersionString()

func main() {
println(v) // v1.0
x, y := SquaresOfSumAndDiff(3, 6)
println(x, y) // 81 9
b := CompareLower4bits(uint32(x), uint32(y))
println(b) // false
// "Go"的类型被推断为string；1的类型被推断为int32。
doNothing("Go", 1)
}

func VersionString() string {
return "v1.0"
}

func doNothing(string, int32) {
}
从上例可以看出，一个函数的声明可以出现在它的调用之前，也可以出现在它的调用之后。

一个函数调用可以被延迟执行或者在另一个协程（goroutine，或称绿色线程）中执行。 后面的一文将对这两个特性进行详解。

函数调用的退出阶段
在Go中，当一个函数调用返回后（比如执行了一个return语句或者函数中的最后一条语句执行完毕）， 此调用可能并未立即退出。一个函数调用从返回开始到最终退出的阶段称为此函数调用的退出阶段（exiting phase）。 函数调用的退出阶段的意义将在讲解延迟函数的时候体现出来。

函数调用的退出阶段将在后面的一篇文章中详细解释。

匿名函数
Go支持匿名函数。定义一个匿名函数和声明一个函数类似，但是一个匿名函数的定义中不包含函数名称部分。 注意匿名函数定义不是一个函数声明。

一个匿名函数在定义后可以被立即调用，比如：
package main

func main() {
// 这个匿名函数没有输入参数，但有两个返回结果。
x, y := func() (int, int) {
println("This function has no parameters.")
return 3, 4
}() // 一对小括号表示立即调用此函数。不需传递实参。

	// 下面这些匿名函数没有返回结果。

	func(a, b int) {
		println("a*a + b*b =", a*a + b*b) // a*a + b*b = 25
	}(x, y) // 立即调用并传递两个实参。

	func(x int) {
		// 形参x遮挡了外层声明的变量x。
		println("x*x + y*y =", x*x + y*y) // x*x + y*y = 32
	}(y) // 将实参y传递给形参x。

	func() {
		println("x*x + y*y =", x*x + y*y) // x*x + y*y = 25
	}() // 不需传递实参。
}
注意，上例中的最后一个匿名函数处于变量x和y的作用域内，所以在它的函数体内可以直接使用这两个变量。 这样的函数称为闭包（closure）。事实上，Go中的所有的自定义函数（包括声明的函数和匿名函数）都可以被视为闭包。 这就是为什么Go中的函数使用起来和动态语言中的函数一样灵活。

在后面的文章中，我们将了解到一个匿名函数可以被赋值给某个函数类型的值，从而我们不必在定义完此匿名函数后立即调用它，而是可以在以后合适的时候再调用它。

内置函数
Go支持一些内置函数，比如前面的例子中已经用到过多次的println和print函数。 我们可以不引入任何库包（见下一篇文章）而调用一个内置函数。

我们可以使用内置函数real和imag来得到一个复数的实部和虚部（均为浮点数类型）。 注意，如果这两个函数的任何一个调用的实参是一个常量，则此调用将在编译时刻被估值，其返回结果也是一个常量。 此调用将被视为一个常量表达式。特别地，如果此实参是一个类型不确定值，则返回结果也是一个类型不确定值。

一个例子：
// c是一个类型不确定复数常量。
const c = complex(1.6, 3.3)

// 函数调用real(c)和imag(c)的结果都是类型
// 不确定浮点数值。在下面这句赋值中，它们都
// 被推断为float32类型的值。
var a, b float32 = real(c), imag(c)

// 变量d的类型被推断为内置类型complex64。
// 函数调用real(d)和imag(d)的结果都是
// 类型为float32的类型确定值。
var d = complex(a, b)

// 变量e的类型被推断为内置类型complex128。
// 函数调用real(e)和imag(e)的结果都是
// 类型为float64的类型确定值。
var e = c

## 代码包和包引入
包引入
下面这个简短的程序（假设它存在一个名为simple-import-demo.go的源文件中）引入了一个标准库包。
package main

import "fmt"

func main() {
fmt.Println("Go has", 25, "keywords.")
}
对此程序的一些解释：
第一行指定了源文件simple-import-demo.go所处的包名为main。 程序入口main函数必须处于一个名为main的代码包中。
第三行通过使用import关键字引入了fmt标准库包。 在此源文件中，fmt标准库包将用fmt标识符来表示。 标识符fmt称为fmt标准库包的引入名称。（后续某节将详述代码包的引入名称）。
fmt标准库包中声明了很多终端打印函数供其它代码包使用。 Println函数是其中之一。 它可以将不定数量参数的字符串表示形式输出到标准输出中。 第六行调用了此Println函数。 注意在此调用中，函数名之前需要带上前缀fmt.，其中fmt是Println函数所处的代码包的引入名称。 aImportName.AnExportedIdentifier这种形式称为一个限定标识符（qualified identifier）。
fmt.Println函数调用接受任意数量的实参并且对实参的类型没有任何限制。 所以此程序中的此函数调用的三个实参的类型将被推断为它们各自的默认类型：string、int和string。
对于一个fmt.Println函数调用，任何两个相邻的实参的输出之间将被插入一个空格字符，并且在最后将输出一个空行字符。
下面是上面这个程序的运行结果：
$ go run simple-import-demo.go
Go has 25 keywords.
当一个代码包被引入一个Go源文件时，只有此代码包中的导出代码要素（名称为大写字母的变量、常量、函数、定义类型和类型别名等）可以在此源文件被使用。 比如上例中的Println函数即为一个导出代码要素，所以它可以在上面的程序源文件中使用。

前面几篇文章中使用的内置函数print和println提供了和fmt标准库包中的对应函数相似的功能。 内置函数可以不用引入任何代码包而直接使用。

注意：print和println这两个内置函数不推荐使用在生产环境，因为它们不保证一定会出现在以后的Go版本中。

我们可以访问Go官网（墙内版）来查看各个标准库包的文档， 我们也可以开启一个本地文档服务器来查看这些文档。

一个包引入也可称为一个包声明。一个包声明只在当前包含此声明的源文件内可见。

另外一个例子：
package main

import "fmt"
import "math/rand"

func main() {
fmt.Printf("下一个伪随机数是%v。\n", rand.Uint32())
}
这个例子多引入了一个math/rand标准库包。 此包是math标准库包中的一个子包。 此包提供了一些函数来产生伪随机数序列。

一些解释：
在此例中，math/rand标准库包的引入名是rand。 rand.Uint32()函数调用将返回一个uint32类型的随机数。
Printf函数是fmt标准库包中提供的另外一个常用终端打印函数。 一个Printf函数调用必须带有至少一个实参，并且第一个实参的类型必须为string。 此第一个实参指定了此调用的打印格式。此格式中的%v在打印结果将被对应的后续实参的字符串表示形式所取代。 比如上列中的%v在打印结果中将被rand.Uint32()函数调用所返回的随机数所取代。 打印格式中的\n表示一个换行符，这在基本类型和它们的字面量表示一文中已经解释过。
上面这个程序的输出如下：
下一个伪随机数是2596996162。
注意：在Go 1.20之前，如果我们希望上面的程序每次运行的时候输出一个不同的随机数，我们需要在程序启动的时候调用rand.Seed函数来设置一个不同的随机数种子。

多个包引入语句可以用一对小括号来合并成一个包引入语句。比如下面这例。

package main

// 一条包引入语句引入了三个代码包。
import (
"fmt"
"math/rand"
"time"
)

func main() {
// 设置随机数种子（仅在Go 1.20之前需要）。
rand.Seed(time.Now().UnixNano())
fmt.Printf("下一个伪随机数是%v。\n", rand.Uint32())
}
一些解释：
此例多引入了一个time标准库包。 此包提供了很多和时间相关的函数和类型。 其中time.Time和time.Duration是两个最常用的类型。
函数调用time.Now()将返回一个表示当前时间的类型为time.Time的值。
UnixNano是类型time.Time的一个方法。 我们可以把方法看作是特殊的函数。方法将在Go中的方法一文中详述。 方法调用aTime.UnixNano()将返回从UTC时间的1970年一月一日到aTime所表示的时间之间的纳秒数。 返回结果的类型为int64，这也是rand.Seed函数的参数类型（注意：rand.Seed函数从Go 1.20开始被声明为废弃了）。 在上例中，此方法调用的结果用来设置随机数种子。
更多关于fmt.Printf函数调用的输出格式
从上面的例子中，我们已经了解到fmt.Printf函数调用的第一个实参中的%v在输出中将替换为后续的实参的字符串表示形式。 实际上，这种百分号开头的占位字符组合还有很多。下面是一些常用的占位字符组合：
%v：将被替换为对应实参字符串表示形式。
%T：将替换为对应实参的类型的字符串表示形式。
%x：将替换为对应实参的十六进制表示。实参的类型可以为字符串、整数、整数数组（array）或者整数切片（slice）等。 （数组和切片将在以后的文章中讲解。）
%s：将被替换为对应实参的字符串表示形式。实参的类型必须为字符串或者字节切片（byte slice）类型。
%%：将被替换为一个百分号。
一个例子：
package main

import "fmt"

func main() {
a, b := 123, "Go"
fmt.Printf("a == %v == 0x%x, b == %s\n", a, a, b)
fmt.Printf("type of a: %T, type of b: %T\n", a, b)
fmt.Printf("1%% 50%% 99%%\n")
}
输出：
a == 123 == 0x7b, b == Go
type of a: int, type of b: string
1% 50% 99%
请阅读fmt标准库包的文档以了解更多的占位字符组合。 我们也可以运行go doc fmt命令来在终端中查看fmt标准库包的文档。 运行go doc fmt.Printf命令可以查看fmt.Printf函数的文档。

代码包目录、代码包引入路径和代码包依赖关系
一个代码包可以由若干Go源文件组成。一个代码包的源文件须都处于同一个目录下。 一个目录（不包含子目录）下的所有源文件必须都处于同一个代码包中，亦即这些源文件开头的package pkgname语句必须一致。 所以，一个代码包对应着一个目录（不包含子目录），反之亦然。 对应着一个代码包的目录称为此代码包的目录。 一个代码包目录下的每个子目录对应的都是另外一个独立的代码包。

对于Go官方工具链来说，一个引入路径中包含有internal目录名的代码包被视为一个特殊的代码包。 它只能被此internal目录的直接父目录（和此父目录的子目录）中的代码包所引入。 比如，代码包.../a/b/c/internal/d/e/f和.../a/b/c/internal只能被引入路径含有.../a/b/c前缀的代码包引入。

当一个代码包中的某个文件引入了另外一个代码包，则我们说前者代码包依赖于后者代码包。

Go不支持循环引用（依赖）。 如果一个代码包a依赖于代码包b，同时代码包b依赖于代码包c，则代码包c中的源文件不能引入代码包a和代码包b，代码包b中的源文件也不能引入代码包a。

当然，一个代码包中的源文件不能也没必要引入此代码包本身。

今后，我们称一个程序中含有main入口函数的名称为main的代码包为程序代码包（或者命令代码包），称其它代码包为库代码包。 程序代码包不能被其它代码包引入。一个程序只能有一个程序代码包。

代码包目录的名称并不要求一定要和其对应的代码包的名称相同。 但是，库代码包目录的名称最好设为和其对应的代码包的名称相同。 因为一个代码包的引入路径中包含的是此包的目录名，但是此包的默认引入名为此包的名称。 如果两者不一致，会使人感到困惑。

另一方面，最好给每个程序代码包目录指定一个有意义的名字，而不是它的包名main。

init函数
在一个代码包中，甚至一个源文件中，可以声明若干名为init的函数。 这些init函数必须不带任何输入参数和返回结果。

注意：我们不能声明名为init的包级变量、常量或者类型。

在程序运行时刻，在进入main入口函数之前，每个init函数在此包加载的时候将被（串行）执行并且只执行一遍。

下面这个简单的程序中有两个init函数：
package main

import "fmt"

func init() {
fmt.Println("hi,", bob)
}

func main() {
fmt.Println("bye")
}

func init() {
fmt.Println("hello,", smith)
}

func titledName(who string) string {
return "Mr. " + who
}

var bob, smith = titledName("Bob"), titledName("Smith")
此程序的运行结果：
hi, Mr. Bob
hello, Mr. Smith
bye
程序代码要素初始化顺序
一个程序中所涉及到的所有的在运行时刻要用到的代码包的加载是串行执行的。 在一个程序启动时，每个包中总是在它所有依赖的包都加载完成之后才开始加载。 程序代码包总是最后一个被加载的代码包。每个被用到的包会被而且仅会被加载一次。

在加载一个代码包的过程中，所有的声明在此包中的init函数将被串行调用并且仅调用执行一次。 一个代码包中声明的init函数的调用肯定晚于此代码包所依赖的代码包中声明的init函数。 所有的init函数都将在调用main入口函数之前被调用执行。

在同一个源文件中声明的init函数将按从上到下的顺序被调用执行。 对于声明在同一个包中的两个不同源文件中的两个init函数，Go语言白皮书推荐（但不强求）按照它们所处于的源文件的名称的词典序列（对英文来说，即字母顺序）来调用。 所以最好不要让声明在同一个包中的两个不同源文件中的两个init函数存在依赖关系。

在加载一个代码包的时候，此代码包中声明的所有包级变量都将在此包中的任何一个init函数执行之前初始化完毕。

在同一个包内，包级变量将尽量按照它们在代码中的出现顺序被初始化，但是一个包级变量的初始化肯定晚于它所依赖的其它包级变量。 比如，在下面的代码片段中，四个包级变量的初始化顺序依次为y、z、x、w。
func f() int {
return z + y
}

func g() int {
return y/2
}

var (
w       = x
x, y, z = f(), 123, g()
)
关于更具体的包级变量的初始化顺序，请阅读表达式估值顺序规则一文。

完整的引入声明语句形式
事实上，一个引入声明语句的完整形式为：
import importname "path/to/package"
其中引入名importname是可选的，它的默认值为被引入的包的包名（不是目录名）。

事实上，在本文上面的例子中的包引入声明中，importname部分都被省略掉了，因为它们都分别和引入的代码包的包名相同。 这些引入声明等价于下面这些：
import fmt "fmt"        // <=> import "fmt"
import rand "math/rand" // <=> import "math/rand"
import time "time"      // <=> import "time"
如果一个包引入声明中的importname没有省略，则限定标识符使用的前缀必须为importname，而不是被引入的包的名称。

引入声明语句的完整形式在日常编程中使用的频率不是很高。 但是在某些情况下，完整形式必须被使用。 比如，如果一个源文件引入的两个代码包的包名一样，为了防止使编译器产生困惑，我们至少需要用完整形式为其中一个包指定一个不同的引入名以区分这两个包。

下面是一个使用了完整引入声明语句形式的例子。
package main

import (
format "fmt"
random "math/rand"
"time"
)

func main() {
random.Seed(time.Now().UnixNano())
format.Print("一个随机数:", random.Uint32(), "\n")

	// 下面这行编译不通过，因为rand不可识别。
	/*
	fmt.Print("一个随机数:", rand.Uint32(), "\n")
	*/
}
一些解释：
我们必须使用format和random，而不是fmt和rand，来做为限定标识符的前缀。
Print是fmt标准库包中的另外一个函数。 和Println函数调用一样，一个Print函数调用也接受任意数量实参。 它将逐个打印出每个实参的字符串表示形式。如果相邻的两个实参都不是字符串类型，则在它们中间会打印一个空格字符。
一个完整引入声明语句形式的引入名importname可以是一个句点(.)。 这样的引入称为句点引入。使用被句点引入的包中的导出代码要素时，限定标识符的前缀必须省略。

例子：
package main

import (
. "fmt"
. "time"
)

func main() {
Println("Current time:", Now())
}
在上面这个例子中，Println和Now函数调用不需要带任何前缀。

一般来说，句点引入不推荐使用，因为它们会导致较低的代码可读性。

一个完整引入声明语句形式的引入名importname可以是一个空标识符(_)。 这样的引入称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的代码要素得以初始化。 被匿名引入的包中的init函数将被执行并且仅执行一遍。

在下面这个例子中，net/http/pprof标准库包中的所有init函数将在main入口函数开始执行之前全部执行一遍。
package main

import _ "net/http/pprof"

func main() {
... // 做一些事情
}
每个非匿名引入必须至少被使用一次
除了匿名引入，其它引入必须在代码中被使用一次。 比如，下面的程序编译不通过。
package main

import (
"net/http" // error: 引入未被使用
. "time"   // error: 引入未被使用
)

import (
format "fmt"  // okay: 下面被使用了一次
_ "math/rand" // okay: 匿名引入
)

func main() {
format.Println() // 使用"fmt"包
}

## 表达式、语句和简单语句
一些表达式的例子
Go中大多数的表达式都是单值表达式。一个单值表达式只表示一个值。 某些表达式可以表示多个值，它们被称为多值表达式。

以后（不包括本文），如果没有特殊说明，当表达式这个词被提及的时候，它表示一个单值表达式。

前面的几篇文章介绍的字面量、变量和具名常量等均属于单值表达式。它们可称为基本表达式。

前面的运算操作符一文中介绍的运算符操作（不包括赋值部分）也都属于单值表达式。

如果一个函数至少返回一个值，则它的调用属于表达式。 特别的，如果此函数返回两个或两个以上的值，则对它的调用称为多值表达式。 不返回任何结果的函数的调用不属于表达式。

以后的某篇文章中介绍的方法可以看作是特殊的函数。 所以上述对函数的解释同样适用于方法。

事实上，以后我们将会了解到自定义函数（包括方法）本身都属于函数类型的值，所以它们都是单值表达式。

通道的接收数据操作（不包括赋值部分）也属于表达式。通道将在以后详解。

Go中的一些表达式，包括刚提及的通道的接收数据操作，可能会表示可变数量的值。 根据不同的场景，这样的表达式可能呈现为单值表达式，也可能呈现为多值表达式。 我们将在以后的文章中了解到这样的表达式。

简单语句类型列表
Go中有六种简单语句类型：
变量短声明语句。
纯赋值语句，包括x op= y这种运算形式。
有返回结果的函数或方法调用，以及通道的接收数据操作。 上一节已经提到了，这些语句也可以用做表达式。
通道的发送数据操作。上面已经提到过一次，通道以后将在此文中详解。
空语句。在下一篇文章我们将看到一些空语句的应用。
自增（x++）和自减（x--）语句。
注意：和C/C++不一样，在Go中，自增和自减语句不能被当作表达式使用。

简单语句这个概念在Go中比较重要，所以请牢记这六种简单语句类型。

一些非简单语句
下面是一个非简单语句的不完整列表：
标准变量声明语句。是的，短声明语句属于简单语句，但是标准变量声明语句不属于。
（具名）常量声明语句。
类型声明语句。
（代码）包引入语句。
显式代码块。一个显式代码块起始于一个左大括号{，终止于一个右大括号}。 一个显式代码块中可以包含若干子语句。
函数声明。 一个函数声明中可以包含若干子语句。
流程控制跳转语句。详见下一章。
函数返回（return）语句。
延迟函数调用和协程创建语句。下下篇文章将会介绍。
一些表达式和语句的例子
// 一些非简单语句：
import "time"
var a = 123
const B = "Go"
type Choice bool
func f() int {
for a < 10 {
break
}

	// 这是一个显式代码块。
	{
		// ...
	}
	return 567
}

// 一些简单语句的例子：
c := make(chan bool) // 通道将在以后讲解
a = 789
a += 5
a = f() // 这是一个纯赋值语句
a++
a--
c <- true // 一个通道发送操作
z := <-c  // 一个使用通道接收操作
// 做为源值的变量短声明语句

// 一些表达式的例子：
123
true
B
B + " language"
a - 789
a > 0 // 一个类型不确定布尔值
f     // 一个类型为“func ()”的表达式

// 下面这些即可以被视为简单语句，也可以被视为表达式。
f() // 函数调用
<-c // 通道接收操作

## 基本流程控制语法
Go中的流程控制语句简单介绍
Go语言中有三种基本的流程控制代码块：
if-else条件分支代码块；
for循环代码块；
switch-case多条件分支代码块。
Go中另外还有几种和特定种类的类型相关的流程控制代码块：
容器类型相关的for-range循环代码块。
接口类型相关的type-switch多条件分支代码块。
通道类型相关的select-case多分支代码块。
和很多其它流行语言一样，Go也支持break、continue和goto等跳转语句。 另外，Go还支持一个特有的fallthrough跳转语句。

Go所支持的六种流程控制代码块中，除了if-else条件分支代码块，其它五种称为可跳出代码块。 我们可以在一个可跳出代码块中使用break语句以跳出此代码块。

我们可以在for和for-range两种循环代码块中使用continue语句提前结束一个循环步。 除了这两种循环代码块，其它四种代码块称为分支代码块。

请注意，上面所提及的每种流程控制的一个分支都属于一条语句。这样的语句常常会包含很多子语句。

上面所提及的流程控制语句都属于狭义上的流程控制语句。 下一篇文章中将要介绍的协程、延迟函数调用、以及恐慌和恢复，以及今后要介绍的并发同步技术属于广义上的流程控制语句。

本文余下的部分将只解释三种基本的流程控制语句和各种代码跳转语句。其它上面提及的语句将在后面其它文章中逐渐介绍。

if-else条件分支控制代码块
一个if-else条件分支控制代码块的完整形式如下：
if InitSimpleStatement; Condition {
// do something
} else {
// do something
}
if和else是两个关键字。 和很多其它编程语言一样，else分支是可选的。

在一个if-else条件分支控制代码块中，
InitSimpleStatement部分是可选的，如果它没被省略掉，则它必须为一条简单语句。 如果它被省略掉，它可以被视为一条空语句（简单语句的一种）。 在实际编程中，InitSimpleStatement常常为一条变量短声明语句。
Condition必须为一个结果为布尔值的表达式（它被称为条件表达式）。 Condition部分可以用一对小括号括起来，但大多数情况下不需要。
注意，我们不能用一对小括号将InitSimpleStatement和Condition两部分括在一起。

在执行一个if-else条件分支控制代码块中，如果InitSimpleStatement这条语句没有被省略，则此条语句将被率先执行。 如果InitSimpleStatement被省略掉，则其后跟随的分号;也可一块儿被省略。

每个if-else流程控制包含一个隐式代码块，一个if分支显式代码块和一个可选的else分支代码块。 这两个分支代码块内嵌在这个隐式代码块中。 在程序运行中，如果Condition条件表达式的估值结果为true，则if分支式代码块将被执行；否则，else分支代码块将被执行。

一个例子：
package main

import (
"fmt"
"math/rand"
"time"
)

func main() {
rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要

	if n := rand.Int(); n%2 == 0 {
		fmt.Println(n, "是一个偶数。")
	} else {
		fmt.Println(n, "是一个奇数。")
	}

	n := rand.Int() % 2 // 此n不是上面声明的n
	if n % 2 == 0 {
		fmt.Println("一个偶数。")
	}

	if ; n % 2 != 0 {
		fmt.Println("一个奇数。")
	}
}
如果InitSimpleStatement语句是一个变量短声明语句，则在此语句中声明的变量被声明在外层的隐式代码块中。

可选的else分支代码块一般情况下必须为显式的，但是如果此分支为另外一个if-else块，则此分支代码块可以是隐式的。

另一个例子：
package main

import (
"fmt"
"time"
)

func main() {
if h := time.Now().Hour(); h < 12 {
fmt.Println("现在为上午。")
} else if h > 19 {
fmt.Println("现在为晚上。")
} else {
fmt.Println("现在为下午。")
// 左h是一个新声明的变量，右h已经在上面声明了。
h := h
// 刚声明的h遮掩了上面声明的h。
_ = h
}

	// 上面声明的两个h在此处都不可见。
}
for循环代码块
for循环代码块的完整形式如下：
for InitSimpleStatement; Condition; PostSimpleStatement {
// do something
}
其中for是一个关键字。

在一个for循环代码块中，
InitSimpleStatement（初始化语句）和PostSimpleStatement（步尾语句）两个部分必须均为简单语句，并且PostSimpleStatement不能为一个变量短声明语句。
Condition必须为一个结果为布尔值的表达式（它被称为条件表达式）。
所有这三个刚提到的部分都是可选的。和很多其它流行语言不同，在Go中上述三部分不能用小括号括在一起。

每个for流程控制包括至少两个子代码块。 其中一个是隐式的，另一个是显式的（花括号起始和终止的部分，又称循环体）。 此显式代码块内嵌在隐式代码块之中。

在一个for循环流程控制中，初始化语句（InitSimpleStatement）将被率先执行，并且只会被执行一次。

在每个循环步的开始，Condition条件表达式将被估值。如果估值结果为false，则循环立即结束；否则循环体（即显式代码块）将被执行。

在每个循环步的结尾，步尾语句（PostSimpleStatement）将被执行。

下面是一个使用for循环流程控制的例子。此程序将逐行打印出0到9十个数字。
for i := 0; i < 10; i++ {
fmt.Println(i)
}
在一个for循环流程控制中，如果InitSimpleStatement和PostSimpleStatement两部分同时被省略（可将它们视为空语句），则和它们相邻的两个分号也可被省略。 这样的形式被称为只有条件表达式的for循环。只有条件表达式的for循环和很多其它语言中的while循环类似。
var i = 0
for ; i < 10; {
fmt.Println(i)
i++
}
for i < 20 {
fmt.Println(i)
i++
}
在一个for循环流程控制中，如果条件表达式部分被省略，则编译器视其为true。
for i := 0; ; i++ { // 等价于：for i := 0; true; i++ {
if i >= 10 {
break
}
fmt.Println(i)
}

// 下面这几个循环是等价的。
for ; true; {
}
for true {
}
for ; ; {
}
for {
}
在一个for循环流程控制中，如果初始化语句InitSimpleStatement是一个变量短声明语句，则在此语句中声明的变量被声明在外层的隐式代码块中。 我们可以在内嵌的循环体（显式代码块）中声明同名变量来遮挡在InitSimpleStatement中声明的变量。 比如下面的代码打印出012，而不是0。
for i := 0; i < 3; i++ {
fmt.Print(i)
i := i // 这里声明的变量i遮挡了上面声明的i。
// 右边的i为上面声明的循环变量i。
i = 10 // 新声明的i被更改了。
_ = i
}
一条break语句可以用来提前跳出包含此break语句的最内层for循环。 下面这段代码同样逐行打印出0到9十个数字。
i := 0
for {
if i >= 10 {
break
}
fmt.Println(i)
i++
}
一条continue语句可以被用来提前结束包含此continue语句的最内层for循环的当前循环步（步尾语句仍将得到执行）。 比如下面这段代码将打印出13579。
for i := 0; i < 10; i++ {
if i % 2 == 0 {
continue
}
fmt.Print(i)
}
switch-case流程控制代码块
switch-case流程控制代码块是另外一种多分支代码块。

一个switch-case流程控制代码块的完整形式为：
switch InitSimpleStatement; CompareOperand0 {
case CompareOperandList1:
// do something
case CompareOperandList2:
// do something
...
case CompareOperandListN:
// do something
default:
// do something
}
其中switch、case和default是三个关键字。

在一个switch-case流程控制代码块中，
InitSimpleStatement部分必须为一条简单语句，它是可选的。
CompareOperand0部分必须为一个表达式（如果它没被省略的话，见下）。 此表达式的估值结果总是被视为一个类型确定值。如果它是一个类型不确定值，则它被视为类型为它的默认类型的类型确定值。 因为这个原因，此表达式不能为类型不确定的nil值。 CompareOperand0常被称为switch表达式。
每个CompareOperandListX部分（X表示1到N）必须为一个用（英文）逗号分隔开来的表达式列表。 其中每个表达式都必须能和CompareOperand0表达式进行比较。 每个这样的表达式常被称为case表达式。 如果其中case表达式是一个类型不确定值，则它必须能够自动隐式转化为对应的switch表达式的类型，否则编译将失败。
每个case CompareOperandListX:部分和default:之后形成了一个隐式代码块。 每个这样的隐式代码块和它对应的case CompareOperandListX:或者default:形成了一个分支。 每个分支都是可选的。

每个switch-case流程控制代码块中最多只能有一个default分支（默认分支）。

除了刚提到的分支代码块，每个switch-case流程控制至少包括其它两个代码块。 其中一个是隐式的，另一个是显式的。此显式的代码块内嵌在隐式的代码块之中。 所有的分支代码块都内嵌在此显式代码块之中（因此也间接内嵌在刚提及的隐式代码块中）。

switch-case代码块属于可跳出流程控制。 break可以使用在一个switch-case流程控制的任何分支代码块之中以提前跳出此switch-case流程控制。

当一个switch-case流程控制被执行到的时候，其中的简单语句InitSimpleStatement将率先被执行（只执行一次）。 随后switch表达式CompareOperand0将被估值（仅一次）。上面已经提到，此估值结果一定为一个类型确定值。 然后此结果值将从上到下从左到右和各个CompareOperandListX表达式列表中的各个case表达式逐个依次比较（使用==运算符）。 一旦发现某个表达式和CompareOperand0相等，比较过程停止并且此表达式对应的分支代码块将得到执行。 如果没有任何一个表达式和CompareOperand0相等，则default默认分支将得到执行（如果此分支存在的话）。

一个switch-case流程控制的例子：
package main

import (
"fmt"
"math/rand"
"time"
)

func main() {
rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
switch n := rand.Intn(100); n%9 {
case 0:
fmt.Println(n, "is a multiple of 9.")

		// 和很多其它语言不一样，程序不会自动从一个
		// 分支代码块跳到下一个分支代码块去执行。
		// 所以，这里不需要一个break语句。
	case 1, 2, 3:
		fmt.Println(n, "mod 9 is 1, 2 or 3.")
		break // 这里的break语句可有可无的，效果
		      // 是一样的。执行不会跳到下一个分支。
	case 4, 5, 6:
		fmt.Println(n, "mod 9 is 4, 5 or 6.")
	// case 6, 7, 8:
		// 上一行可能编译不过，因为6和上一个case中的
		// 6重复了。是否能编译通过取决于具体编译器实现。
	default:
		fmt.Println(n, "mod 9 is 7 or 8.")
	}
}
在上例中，rand.Intn函数将返回一个从0到所传实参之间类型为int的随机数。

注意，编译器可能会不允许一个switch-case流程控制中有任何两个case表达式可以在编译时刻确定相等。 比如，当前的官方标准编译器（1.20版本）认为上例中的case 6, 7, 8一行是不合法的（如果此行未被注释掉）。但是其它编译器未必这么认为。 事实上，当前的官方标准编译器允许重复的布尔case表达式在同一个switch-case流程控制中出现， 而gccgo（v8.2）允许重复的布尔和字符串类型的case表达式在同一个switch-case流程控制中出现。

上面的例子中的前两个case分支中的注释已经解释了，和很多其它语言不一样，每个分支代码块的结尾不需要一条break语句就可以自动跳出当前的switch-case流程控制。 那么如何让执行从一个case分支代码块的结尾跳入下一个分支代码块？Go提供了一个fallthrough关键字来完成这个任务。 比如，在下面的例子中，所有的分支代码块都将得到执行（从上到下）。
rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
fmt.Println("n =", n)
fallthrough // 跳到下个代码块
case 5, 6, 7, 8:
// 一个新声明的n，它只在当前分支代码快内可见。
n := 99
fmt.Println("n =", n) // 99
fallthrough
default:
// 下一行中的n和第一个分支中的n是同一个变量。
// 它们均为switch表达式"n"。
fmt.Println("n =", n)
}
请注意：
一条fallthrough语句必须为一个分支代码块中的最后一条语句。
一条fallthrough语句不能出现在一个switch-case流程控制中的最后一个分支代码块中。
比如，下面代码的几个fallthrough使用是不合法的。
switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
fmt.Println("n =", n)
// 此整个if代码块为当前分支中的最后一条语句
if true {
fallthrough // error: 不是当前分支中的最后一条语句
}
case 5, 6, 7, 8:
n := 99
fallthrough // error: 不是当前分支中的最后一条语句
_ = n
default:
fmt.Println(n)
fallthrough // error: 不能出现在最后一个分支中
}
一个switch-case流程控制中的InitSimpleStatement语句和CompareOperand0表达式都是可选的。 如果CompareOperand0表达式被省略，则它被认为类型为bool类型的true值。 如果InitSimpleStatement语句被省略，其后的分号也可一并被省略。

上面已经提到了一个switch-case流程控制中的所有分支都可以被省略，所以下面的所有流程控制代码块都是合法的，它们都可以被视为空操作。
switch n := 5; n {
}

switch 5 {
}

switch _ = 5; {
}

switch {
}
上例中的后两个switch-case流程控制中的CompareOperand0表达式都为bool类型的true值。 同理，下例中的代码将打印出hello。
switch { // <=> switch true {
case true: fmt.Println("hello")
default: fmt.Println("bye")
}
Go中另外一个和其它语言的显著不同点是default分支不必一定为最后一个分支。 比如，下面的三个switch-case流程控制代码块是相互等价的。
switch n := rand.Intn(3); n {
case 0: fmt.Println("n == 0")
case 1: fmt.Println("n == 1")
default: fmt.Println("n == 2")
}

switch n := rand.Intn(3); n {
default: fmt.Println("n == 2")
case 0: fmt.Println("n == 0")
case 1: fmt.Println("n == 1")
}

switch n := rand.Intn(3); n {
case 0: fmt.Println("n == 0")
default: fmt.Println("n == 2")
case 1: fmt.Println("n == 1")
}
goto跳转语句和跳转标签声明
和很多其它语言一样，Go也支持goto跳转语句。 在一个goto跳转语句中，goto关键字后必须跟随一个表明跳转到何处的跳转标签。 我们使用LabelName:这样的形式来声明一个名为LabelName的跳转标签，其中LabelName必须为一个标识符。 一个不为空标识符的跳转标签声明后必须被使用至少一次。

一条跳转标签声明之后必须立即跟随一条语句。 如果此声明的跳转标签使用在一条goto语句中，则当此条goto语句被执行的时候，执行将跳转到此跳转标签声明后跟随的语句。

一个跳转标签必须声明在一个函数体内，此跳转标签的使用可以在此跳转标签的声明之后或者之前，但是此跳转标签的使用不能出现在此跳转标签声明所处的最内层代码块之外。

下面这个例子使用跳转标签声明和goto跳转语句来实现了一个循环：
package main

import "fmt"

func main() {
i := 0

Next: // 跳转标签声明
fmt.Println(i)
i++
if i < 5 {
goto Next // 跳转
}
}
上面刚提到了一个跳转标签的使用不能出现在此跳转标签声明所处的最内层代码块之外，所以下面的代码片段中的跳转标签使用都是不合法的。
package main

func main() {
goto Label1 // error
{
Label1:
goto Label2 // error
}
{
Label2:
}
}
另外要注意的一点是，如果一个跳转标签声明在某个变量的作用域内，则此跳转标签的使用不能出现在此变量的声明之前。 关于变量的作用域，请阅读后面的文章代码块和作用域

下面这个程序编译不通过：
package main

import "fmt"

func main() {
i := 0
Next:
if i >= 5 {
// error: goto Exit jumps over declaration of k
goto Exit
}

	k := i + i
	fmt.Println(k)
	i++
	goto Next
Exit: // 此标签声明在k的作用域内，但
// 它的使用在k的作用域之外。
}
刚提到的这条规则可能会在今后放宽。 目前，有两种途径可以对上面的程序略加修改以使之编译通过。

第一种途径是缩小变量k的作用域：
func main() {
i := 0
Next:
if i >= 5 {
goto Exit
}
// 创建一个显式代码块以缩小k的作用域。
{
k := i + i
fmt.Println(k)
}
i++
goto Next
Exit:
}
第二种途径是放大变量k的作用域：
func main() {
var k int // 将变量k的声明移到此处。
i := 0
Next:
if i >= 5 {
goto Exit
}

	k = i + i
	fmt.Println(k)
	i++
	goto Next
Exit:
}
包含跳转标签的break和continue语句
一个goto语句必须包含一个跳转标签名。 一个break或者continue语句也可以包含一个跳转标签名，但此跳转标签名是可选的。 包含跳转标签名的break语句一般用于跳出外层的嵌套可跳出流程控制代码块。 包含跳转标签名的continue语句一般用于提前结束外层的嵌套循环流程控制代码块的当前循环步。

如果一条break语句中包含一个跳转标签名，则此跳转标签必须刚好声明在一个包含此break语句的可跳出流程控制代码块之前。 我们可以把此跳转标签名看作是其后紧跟随的可跳出流程控制代码块的名称。 此break语句将立即结束此可跳出流程控制代码块的执行。

如果一条continue语句中包含一个跳转标签名，则此跳转标签必须刚好声明在一个包含此continue语句的循环流程控制代码块之前。 我们可以把此跳转标签名看作是其后紧跟随的循环流程控制代码块的名称。 此continue语句将提前结束此循环流程控制代码块的当前步的执行。

下面是一个使用了包含跳转标签名的break和continue语句的例子。
package main

import "fmt"

func FindSmallestPrimeLargerThan(n int) int {
Outer:
for n++; ; n++{
for i := 2; ; i++ {
switch {
case i * i > n:
break Outer
case n % i == 0:
continue Outer
}
}
}
return n
}

func main() {
for i := 90; i < 100; i++ {
n := FindSmallestPrimeLargerThan(i)
fmt.Print("最小的比", i, "大的素数为", n)
fmt.Println()
}
}

## 协程、延迟函数调用、以及恐慌和恢复
协程（goroutine）
现代CPU一般含有多个核，并且一个核可能支持多线程。换句话说，现代CPU可以同时执行多条指令流水线。 为了将CPU的能力发挥到极致，我们常常需要使我们的程序支持并发（concurrent）计算。

并发计算是指若干计算可能在某些时间片段内同时运行的情形。 下面这两张图描绘了两种并发计算的场景。在此图中，A和B表示两个计算。 在第一种情形中，两个计算只在某些时间片段同时运行。 第二种情形称为并行（parallel）计算。在并行计算中，多个计算在任何时间点都在同时运行。并行计算属于特殊的并发计算。

并发和并行
并发计算可能发生在同一个程序中、同一台电脑上、或者同一个网络中。 在《Go语言101》中，我们只谈及发生在同一个程序中的并发计算。 在Go编程中，协程是创建计算的唯一途径。

协程有时也被称为绿色线程。绿色线程是由程序的运行时（runtime）维护的线程。一个绿色线程的内存开销和情景转换（context switching）时耗比一个系统线程常常小得多。 只要内存充足，一个程序可以轻松支持上万个并发协程。

Go不支持创建系统线程，所以协程是一个Go程序内部唯一的并发实现方式。

每个Go程序启动的时候只有一个对用户可见的协程，我们称之为主协程。 一个协程可以开启更多其它新的协程。在Go中，开启一个新的协程是非常简单的。 我们只需在一个函数调用之前使用一个go关键字，即可让此函数调用运行在一个新的协程之中。 当此函数调用退出后，这个新的协程也随之结束了。我们可以称此函数调用为一个协程调用（或者为此协程的启动调用）。 一个协程调用的所有返回值（如果存在的话）必须被全部舍弃。

在下面的例子程序中，主协程创建了两个新的协程。在此例中，time.Duration是一个在time标准库包中定义的类型。 此类型的底层类型为内置类型int64。 底层类型这个概念将在下一篇文章中介绍。
package main

import (
"log"
"math/rand"
"time"
)

func SayGreetings(greeting string, times int) {
for i := 0; i < times; i++ {
log.Println(greeting)
d := time.Second * time.Duration(rand.Intn(5)) / 2
time.Sleep(d) // 睡眠片刻（随机0到2.5秒）
}
}

func main() {
rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
log.SetFlags(0)
go SayGreetings("hi!", 10)
go SayGreetings("hello!", 10)
time.Sleep(2 * time.Second)
}
非常简单！我们编写了一个并发程序！ 此程序在运行的时候在某一时刻将很可能会有三个协程并存。 运行之，可能会得到如下的结果（也可能是其它结果）：
hi!
hello!
hello!
hello!
hello!
hi!
当一个程序的主协程退出后，此程序也就退出了，即使还有一些其它协程在运行。

和前面的几篇文章不同，上面的例子程序使用了log标准库而不是fmt标准库中的Println函数。 原因是log标准库中的打印函数是经过了同步处理的（下一节将解释什么是并发同步），而fmt标准库中的打印函数却没有被同步。 如果我们在上例中使用fmt标准库中的Println函数，则不同协程的打印可能会交织在一起。（虽然对此例来说，交织的概率很低。）

并发同步（concurrency synchronization）
不同的并发计算可能共享一些资源，其中共享内存资源最为常见。 在一个并发程序中，常常会发生下面的情形：
在一个计算向一段内存写数据的时候，另一个计算从此内存段读数据，结果导致读出的数据的完整性得不到保证。
在一个计算向一段内存写数据的时候，另一个计算也向此段内存写数据，结果导致被写入的数据的完整性得不到保证。
这些情形被称为数据竞争（data race）。并发编程的一大任务就是要调度不同计算，控制它们对资源的访问时段，以使数据竞争的情况不会发生。 此任务常称为并发同步（或者数据同步）。Go支持几种并发同步技术，这些并发同步技术将在后面的章节中逐一介绍。

并发编程中的其它任务包括：
决定需要开启多少计算；
决定何时开启、阻塞、解除阻塞和结束哪些计算；
决定如何在不同的计算中分担工作负载。
上一节中这个并发程序是有缺陷的。我们本期望每个新创建的协程打印出10条问候语，但是主协程（和程序）在这20条问候语还未都打印出来的时候就退出了。 如何确保主协程在这20条问候语都打印完毕之后才退出呢？我们必须使用某种并发同步技术来达成这一目标。

Go支持几种并发同步技术。 其中， 通道是最独特和最常用的。 但是，为了简单起见，这里我们将使用sync标准库包中的WaitGroup来同步上面这个程序中的主协程和两个新创建的协程。

WaitGroup类型有三个方法（特殊的函数，将在以后的文章中详解）：Add、Done和Wait。 此类型将在后面的某篇文章中详细解释，目前我们可以简单地认为：
Add方法用来注册新的需要完成的任务数。
Done方法用来通知某个任务已经完成了。
一个Wait方法调用将阻塞（等待）到所有任务都已经完成之后才继续执行其后的语句。
示例：
package main

import (
"log"
"math/rand"
"time"
"sync"
)

var wg sync.WaitGroup

func SayGreetings(greeting string, times int) {
for i := 0; i < times; i++ {
log.Println(greeting)
d := time.Second * time.Duration(rand.Intn(5)) / 2
time.Sleep(d)
}
wg.Done() // 通知当前任务已经完成。
}

func main() {
rand.Seed(time.Now().UnixNano()) // Go 1.20之前需要
log.SetFlags(0)
wg.Add(2) // 注册两个新任务。
go SayGreetings("hi!", 10)
go SayGreetings("hello!", 10)
wg.Wait() // 阻塞在这里，直到所有任务都已完成。
}
运行这个修改后的程序，我们将会发现所有的20条问候语都将在程序退出之前打印出来。

协程的状态
从上面这个的例子，我们可以看到一个活动中的协程可以处于两个状态：运行状态和阻塞状态。一个协程可以在这两个状态之间切换。 比如上例中的主协程在调用wg.Wait方法的时候，将从运行状态切换到阻塞状态；当两个新协程完成各自的任务后，主协程将从阻塞状态切换回运行状态。

下面的图片显示了一个协程的生命周期。

协程状态
注意，一个处于睡眠中的（通过调用time.Sleep）或者在等待系统调用返回的协程被认为是处于运行状态，而不是阻塞状态。

当一个新协程被创建的时候，它将自动进入运行状态，一个协程只能从运行状态而不能从阻塞状态退出。 如果因为某种原因而导致某个协程一直处于阻塞状态，则此协程将永远不会退出。 除了极个别的应用场景，在编程时我们应该尽量避免出现这样的情形。

一个处于阻塞状态的协程不会自发结束阻塞状态，它必须被另外一个协程通过某种并发同步方法来被动地结束阻塞状态。 如果一个运行中的程序当前所有的协程都出于阻塞状态，则这些协程将永远阻塞下去，程序将被视为死锁了。 当一个程序死锁后，官方标准编译器的处理是让这个程序崩溃。

比如下面这个程序将在运行两秒钟后崩溃。
package main

import (
"sync"
"time"
)

var wg sync.WaitGroup

func main() {
wg.Add(1)
go func() {
time.Sleep(time.Second * 2)
wg.Wait() // 阻塞在此
}()
wg.Wait() // 阻塞在此
}
它的输出：
fatal error: all goroutines are asleep - deadlock!

...
以后我们将学习到更多可以让一个协程进入到阻塞状态的操作。

协程的调度
并非所有处于运行状态的协程都在执行。在任一时刻，只能最多有和逻辑CPU数目一样多的协程在同时执行。 我们可以调用runtime.NumCPU函数来查询当前程序可利用的逻辑CPU数目。 每个逻辑CPU在同一时刻只能最多执行一个协程。Go运行时（runtime）必须让逻辑CPU频繁地在不同的处于运行状态的协程之间切换，从而每个处于运行状态的协程都有机会得到执行。 这和操作系统执行系统线程的原理是一样的。

下面这张图显示了一个协程的更详细的生命周期。在此图中，运行状态被细分成了多个子状态。 一个处于排队子状态的协程等待着进入执行子状态。一个处于执行子状态的协程在被执行一会儿（非常短的时间片）之后将进入排队子状态。

协程详细状态
请注意，为了解释的简单性，在以后其它的《Go语言101》文章中，上图中所示的子状态将不会再提及。 重申一下，睡眠和等待系统调用返回子状态被认为是运行状态，而不是阻塞状态。

标准编译器采纳了一种被称为M-P-G模型的算法来实现协程调度。 其中，M表示系统线程，P表示逻辑处理器（并非上述的逻辑CPU），G表示协程。 大多数的调度工作是通过逻辑处理器（P）来完成的。 逻辑处理器像一个监工一样通过将不同的处于运行状态协程（G）交给不同的系统线程（M）来执行。 一个协程在同一时刻只能在一个系统线程中执行。一个执行中的协程运行片刻后将自发地脱离让出一个系统线程，从而使得其它处于等待子状态的协程得到执行机会。

在运行时刻，我们可以调用runtime.GOMAXPROCS函数来获取和设置逻辑处理器的数量。 对于官方标准编译器，在Go 1.5之前，默认初始逻辑处理器的数量为1；自从Go 1.5之后，默认初始逻辑处理器的数量和逻辑CPU的数量一致。 此新的默认设置在大多数情况下是最佳选择。但是对于某些文件操作十分频繁的程序，设置一个大于runtime.NumCPU()的GOMAXPROCS值可能是有好处的。

我们也可以通过设置GOMAXPROCS环境变量来设置一个Go程序的初始逻辑处理器数量。

延迟函数调用（deferred function call）
在Go中，一个函数调用可以跟在一个defer关键字后面，成为一个延迟函数调用。 此defer关键字和此延迟函数调用一起形成一个延迟调用语句。 和协程调用类似，被延迟的函数调用的所有返回值（如果存在）必须全部被舍弃。

当一个延迟调用语句被执行时，其中的延迟函数调用不会立即被执行，而是被推入由当前协程维护的一个延迟调用队列（一个后进先出队列）。 当一个函数调用返回（此时可能尚未完全退出）并进入它的退出阶段后，所有在执行此函数调用的过程中已经被推入延迟调用队列的调用将被按照它们被推入的顺序逆序被弹出队列并执行。 当所有这些延迟调用执行完毕后，此函数调用也就完全退出了。

下面这个例子展示了如何使用延迟调用函数。
package main

import "fmt"

func main() {
defer fmt.Println("The third line.")
defer fmt.Println("The second line.")
fmt.Println("The first line.")
}
输出结果：
The first line.
The second line.
The third line.
下面是另一个略微复杂一点的使用了延迟调用的例子程序。此程序将按照自然数的顺序打印出0到9十个数字。
package main

import "fmt"

func main() {
defer fmt.Println("9")
fmt.Println("0")
defer fmt.Println("8")
fmt.Println("1")
if false {
defer fmt.Println("not reachable")
}
defer func() {
defer fmt.Println("7")
fmt.Println("3")
defer func() {
fmt.Println("5")
fmt.Println("6")
}()
fmt.Println("4")
}()
fmt.Println("2")
return
defer fmt.Println("not reachable")
}
一个延迟调用可以修改包含此延迟调用的最内层函数的返回值
一个例子：
package main

import "fmt"

func Triple(n int) (r int) {
defer func() {
r += n // 修改返回值
}()

	return n + n // <=> r = n + n; return
}

func main() {
fmt.Println(Triple(5)) // 15
}
延迟函数调用的必要性和好处
事实上，上面的几个使用了延迟函数调用的例子中的延迟函数调用并非绝对必要。 但是延迟调用对于下面将要介绍的恐慌/恢复特性是必要的。

另外延迟函数调用可以帮助我们写出更整洁和更鲁棒的代码。我们可以在后面的更多关于延迟调用一文中读到这样的例子。

协程和延迟调用的实参的估值时刻
一个延迟调用的实参是在此调用对应的延迟调用语句被执行时被估值的。 或者说，它们是在此延迟调用被推入延迟调用队列时被估值的。 这些被估值的结果将在以后此延迟调用被执行的时候使用。

一个匿名函数体内的表达式是在此函数被执行的时候才会被逐渐估值的，不管此函数是被普通调用还是延迟/协程调用。

一个例子：
package main

import "fmt"

func main() {
func() {
for i := 0; i < 3; i++ {
defer fmt.Println("a:", i)
}
}()
fmt.Println()
func() {
for i := 0; i < 3; i++ {
defer func() {
fmt.Println("b:", i)
}()
}
}()
}
运行之，将得到如下结果：
a: 2
a: 1
a: 0

b: 3
b: 3
b: 3
第一个匿名函数中的循环打印出2、1和0这个序列，但是第二个匿名函数中的循环打印出三个3。 因为第一个循环中的i是在fmt.Println函数调用被推入延迟调用队列的时候估的值，而第二个循环中的i是在第二个匿名函数调用的退出阶段估的值（此时循环变量i的值已经变为3）。

我们可以对第二个循环略加修改（使用两种方法），使得它和第一个循环打印出相同的结果。
for i := 0; i < 3; i++ {
defer func(i int) {
// 此i为形参i，非实参循环变量i。
fmt.Println("b:", i)
}(i)
}
或者
for i := 0; i < 3; i++ {
i := i // 在下面的调用中，左i遮挡了右i。
// <=> var i = i
defer func() {
// 此i为上面的左i，非循环变量i。
fmt.Println("b:", i)
}()
}
同样的估值时刻规则也适用于协程调用。下面这个例子程序将打印出123 789。
package main

import "fmt"
import "time"

func main() {
var a = 123
go func(x int) {
time.Sleep(time.Second)
fmt.Println(x, a) // 123 789
}(a)

	a = 789

	time.Sleep(2 * time.Second)
}
顺便说一句，使用time.Sleep调用来做并发同步不是一个好的方法。 如果上面这个程序运行在一个满负荷运行的电脑上，此程序可能在新启动的协程可能还未得到执行机会的时候就已经退出了。 在正式的项目中，我们应该使用并发同步技术一文中列出的方法来实现并发同步。

恐慌（panic）和恢复（recover）
Go不支持异常抛出和捕获，而是推荐使用返回值显式返回错误。 不过，Go支持一套和异常抛出/捕获类似的机制。此机制称为恐慌/恢复（panic/recover）机制。

我们可以调用内置函数panic来产生一个恐慌以使当前协程进入恐慌状况。

进入恐慌状况是另一种使当前函数调用开始返回的途径。 一旦一个函数调用产生一个恐慌，此函数调用将立即进入它的退出阶段。

通过在一个延迟函数调用之中调用内置函数recover，当前协程中的一个恐慌可以被消除，从而使得当前协程重新进入正常状况。

如果一个协程在恐慌状况下退出，它将使整个程序崩溃。

内置函数panic和recover的声明原型如下：
func panic(v interface{})
func recover() interface{}
接口（interface）类型和接口值将在以后的文章接口中详解。 目前，我们可以暂时将空接口类型interface{}视为很多其它语言中的any或者Object类型。 换句话说，在一个panic函数调用中，我们可以传任何实参值。

一个recover函数的返回值为其所恢复的恐慌在产生时被一个panic函数调用所消费的参数。

下面这个例子展示了如何产生一个恐慌和如何消除一个恐慌。
package main

import "fmt"

func main() {
defer func() {
fmt.Println("正常退出")
}()
fmt.Println("嗨！")
defer func() {
v := recover()
fmt.Println("恐慌被恢复了：", v)
}()
panic("拜拜！") // 产生一个恐慌
fmt.Println("执行不到这里")
}
它的输出结果：
嗨！
恐慌被恢复了： 拜拜！
正常退出
下面的例子在一个新协程里面产生了一个恐慌，并且此协程在恐慌状况下退出，所以整个程序崩溃了。
package main

import (
"fmt"
"time"
)

func main() {
fmt.Println("hi!")

	go func() {
		time.Sleep(time.Second)
		panic(123)
	}()

	for {
		time.Sleep(time.Second)
	}
}
运行之，输出如下：
hi!
panic: 123

goroutine 5 [running]:
...
Go运行时（runtime）会在若干情形下产生恐慌，比如一个整数被0除的时候。下面这个程序将崩溃退出。
package main

func main() {
a, b := 1, 0
_ = a/b
}
它的输出：
panic: runtime error: integer divide by zero

goroutine 1 [running]:
...
一般说来，恐慌用来表示正常情况下不应该发生的逻辑错误。 如果这样的一个错误在运行时刻发生了，则它肯定是由于某个bug引起的。 另一方面，非逻辑错误是现实中难以避免的错误，它们不应该导致恐慌。 我们必须正确地对待和处理非逻辑错误。

更多可能由Go运行时产生的恐慌将在以后其它文章中提及。

以后，我们可以了解一些恐慌/恢复用例和更多关于恐慌/恢复机制的细节。

一些致命性错误不属于恐慌
对于官方标准编译器来说，很多致命性错误（比如栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。

