# 2023-8-23 刘常青
## 整理redis常见面试题


## Go类型系统概述

概念：基本类型（basic type）
内置基本类型已经在前面的文章基本类型和它们的字面量表示一文中介绍过了。 为了本文的完整性，这些内置类型重新被列在这里：
内置字符串类型：string.
内置布尔类型：bool.
内置数值类型：
int8、uint8（byte）、int16、uint16、int32（rune）、uint32、int64、uint64、int、uint、uintptr。
float32、float64。
complex64、complex128。
注意，byte是uint8的一个内置别名，rune是int32的一个内置别名。 下面将要提到如何声明自定义的类型别名。

除了字符串类型，《Go语言101》后续其它文章将不再对其它基本类型做详细讲解。

这17个内置基本类型属于预声明类型（predeclared type）。

概念：组合类型（composite type）
Go支持下列组合类型：
指针类型 - 类C指针
结构体类型 - 类C结构体
函数类型 - 函数类型在Go中是一种一等公民类别
容器类型，包括:
数组类型 - 定长容器类型
切片类型 - 动态长度和容量容器类型
映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。
通道类型 - 通道用来同步并发的协程
接口类型 - 接口在反射和多态中发挥着重要角色
无名组合类型可以用它们各自的字面表示形式来表示。 下面是一些各种不同种类的无名组合类型字面表示形式的例子（具名和无名类型将在下面解释）：
// 假设T为任意一个类型，Tkey为一个支持比较的类型。

*T         // 一个指针类型
[5]T       // 一个元素类型为T、元素个数为5的数组类型
[]T        // 一个元素类型为T的切片类型
map[Tkey]T // 一个键值类型为Tkey、元素类型为T的映射类型

// 一个结构体类型
struct {
name string
age  int
}

// 一个函数类型
func(int) (bool, string)

// 一个接口类型
interface {
Method0(string) int
Method1() (int, bool)
}

// 几个通道类型
chan T
chan<- T
<-chan T
支持和不支持比较的类型将在下面介绍。

事实：类型的种类
每种上面提到的基本类型和组合类型都对应着一个类型种类（kind）。除了这些种类，今后将要介绍的非类型安全指针类型属于另外一个新的类型种类。

所以，目前（Go 1.20），Go有26个类型种类。

语法：类型定义（type definition declaration）
（类型定义又称类型定义声明。在Go 1.9之前，类型定义被称为类型声明并且是唯一的一种类型声明形式。 但是自从Go 1.9，类型定义变成了两种类型声明形式之一。另一种新的类型声明形式为后面的一节中将要介绍的类型别名声明。）

在Go中，我们可以用如下形式来定义新的类型。在此语法中，type为一个关键字。
// 定义单个类型。
type NewTypeName SourceType

// 定义多个类型（将多个类型描述合并在一个声明中）。
type (
NewTypeName1 SourceType1
NewTypeName2 SourceType2
)
新的类型名必须为标识符。但是请注意：包级类型（以及下一节将要介绍的类型别名）的名称不能为init。

上例中的第二个类型声明中包含两个类型描述（type specification）。 如果一个类型声明包含多于一个的类型描述，这些类型描述必须用一对小括号()括起来。

每个类型描述创建了一个全新的定义类型（defined type）。

注意：
一个新定义的类型和它的源类型为两个不同的类型。
在两个不同的类型定义中所定义的两个类型肯定是两个不同的类型。
一个新定义的类型和它的源类型的底层类型（将在下面介绍）一致并且它们的值可以相互显式转换。
类型定义可以出现在函数体内。
一些类型定义的例子：
// 下面这些新定义的类型和它们的源类型都是基本类型。
// 它们的源类型均为预声明类型。
type (
MyInt int
Age   int
Text  string
)

// 下面这些新定义的类型和它们的源类型都是组合类型。
// 它们的源类型均为无名类型（见下下节）。
type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

func f() {
// 这三个新定义的类型名称只能在此函数内使用。
type PersonAge map[string]int
type MessageQueue chan string
type Reader interface{Read([]byte) int}
}
请注意：从Go 1.9到Go 1.17，Go白皮书曾经把预声明类型视为定义类型。 但是从Go 1.18开始，Go白皮书明确说明预声明类型不再属于定义类型。

概念：自定义泛型类型和实例化类型（generic type and instantiated types）
从Go 1.18开始，Go开始支持自定义泛型类型（和函数）。 一个泛型类型必须被实例化才能被用做值类型。

一个泛型类型是一个定义类型；它的实例化类型为具名类型。具名类型将在下一节解释。

自定义泛型中的另外两个重要的概念为类型约束（constarint）和类型参数（type parameter）。

本书不详细阐述自定义泛型。关于如何声明和使用泛型类型和函数，请阅读《Go自定义泛型101》。

概念：具名类型和无名类型（named type and unnamed type）
在Go 1.9之前，具名类型这个术语在Go白皮书中是精确定义的。 在那时，一个具名类型被定义为一个可以用标识符表示的类型。 随着在Go 1.9中引入了自定义类型别名（见下一节），具名类型这个术语被从白皮书中删除了；取而代之的是定义类型。 随着Go 1.18中引入了自定义泛型，具名类型这个术语又被重新加回到白皮书。

一个具名类型可能为
一个预声明类型；
一个定义（非自定义泛型）类型；
一个（泛型类型的）实例化类型；
一个类型参数类型（使用在自定义泛型中）。
其它类型称为无名类型。一个无名类型肯定是一个组合类型（反之则未必）。

语法：类型别名声明（type alias declaration）
从Go 1.9开始，我们可以使用下面的语法来声明自定义类型别名。此语法和类型定义类似，但是请注意每个类型描述中多了一个等号=。
type (
Name = string
Age  = int
)

type table = map[string]int
type Table = map[Name]Age
类型别名也必须为标识符。同样地，类型别名可以被声明在函数体内。

在上面的类型别名声明的例子中，Name是内置类型string的一个别名，它们表示同一个类型。 同样的关系对下面的几对类型表示也成立：
别名Age和内置类型int。
别名table和映射类型map[string]int。
别名Table和映射类型map[Name]Age。
事实上，文字表示形式map[string]int和map[Name]Age也表示同一类型。 所以，table和Table一样表示同一个类型。

注意：尽管一个类型别名有一个名字，但是它可能表示一个无名类型。 比如，table和Table这两个别名都表示同一个无名类型map[string]int。

概念：底层类型（underlying type）
在Go中，每个类型都有一个底层类型。规则：
一个内置类型的底层类型为它自己。
unsafe标准库包中定义的Pointer类型的底层类型是它自己。 （至少我们可以认为是这样。事实上，关于unsafe.Pointer类型的底层类型，官方文档中并没有清晰的说明。我们也可以认为unsafe.Pointer类型的底层类型为*T，其中T表示一个任意类型。） unsafe.Pointer也被视为一个内置类型。
一个无名类型（必为一个组合类型）的底层类型为它自己。
在一个类型声明中，新声明的类型和源类型共享底层类型。
一个例子：
// 这四个类型的底层类型均为内置类型int。
type (
MyInt int
Age   MyInt
)

// 下面这三个新声明的类型的底层类型各不相同。
type (
IntSlice   []int   // 底层类型为[]int
MyIntSlice []MyInt // 底层类型为[]MyInt
AgeSlice   []Age   // 底层类型为[]Age
)

// 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。
type Ages AgeSlice
如何溯源一个声明的类型的底层类型？规则很简单，在溯源过程中，当遇到一个内置类型或者无名类型时，溯源结束。 以上面这几个声明的类型为例，下面是它们的底层类型的溯源过程：
MyInt → int
Age → MyInt → int
IntSlice → []int
MyIntSlice → []MyInt → []int
AgeSlice → []Age → []MyInt → []int
Ages → AgeSlice → []Age → []MyInt → []int
在Go中，
底层类型为内置类型bool的类型称为布尔类型；
底层类型为任一内置整数类型的类型称为整数类型；
底层类型为内置类型float32或者float64的类型称为浮点数类型；
底层类型为内置类型complex64或complex128的类型称为复数类型；
整数类型、浮点数类型和复数类型统称为数字值类型；
底层类型为内置类型string的类型称为字符串类型。
底层类型这个概念在类型转换、赋值和比较规则中扮演着重要角色。

概念：值（value）
一个类型的一个实例称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。 同一类型的不同值共享很多相同的属性。

每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。 预声明的标识符nil可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。 我们以后可以在Go中的nil一文中了解到关于nil的各种事实。

在源代码中，值可以呈现为若干种形式，包括字面量、具名常量、变量和表达式。前三种形式可以看作是最后一种形式的特例。

值分为类型确定的和类型不确定的。

基本类型和它们的字面量表示已经在前面一文中介绍过了。 另外，Go中还有另外两种的字面量表示形式：函数字面量表示形式和组合字面量表示形式（composite literal）。

函数字面量表示形式用来表示函数值。事实上，一个函数声明是由一个标识符（函数名）和一个函数字面量表示形式组成。

组合字面量表示形式用来表示结构体类型值和容器类型（数组、切片和映射）值。 详见结构体和容器类型两文。

指针类型、通道类型和接口类型的值没有字面量表示形式。

概念：值部（value part）
在运行时刻，很多值是存储在内存的。每个这样的值都有一个直接部分，但是有一些值还可能有一个或多个间接部分。每个值部分在内存中都占据一段连续空间。 通过安全或者非安全指针，一个值的间接部分被此值的直接部分所引用。

值部这个术语并没有在Go白皮书中定义。它仅使用在《Go语言101》这本书中，用来简化一些解释并帮助Go程序员更好地理解Go类型和值。

概念：值尺寸（value size）
一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在Go中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。

我们可以用unsafe标准库包中的Sizeof函数来取得任何一个值的尺寸。

Go白皮书没有规定非数值类型值的尺寸。对数值类型值的尺寸的要求已经在基本类型和它们的字面量表示一文中提及了。

概念：指针类型的基类型（base type）
如果一个指针类型的底层类型表示为*T，则此指针类型的基类型为T所表示的类型。

指针类一文详细解释了指针类类型和指针值。

概念：结构体类型的字段（field）
一个结构体类型由若干成员变量组成。每个这样的成员变量称为此结构体的一个字段。 比如，下面这个结构体类型含有三个字段：author、title和pages。
struct {
author string
title  string
pages  int
}
结构体一文详细解释了结构体类型和结构体值。

概念：函数类型的签名（signature）
一个函数和其类型的签名由此函数的输入参数和返回结果的类型列表组成。 函数名称和函数体不属于函数签名的构成部分。

函数一文详细解释了函数类型和函数值。

概念：类型的方法（method）和方法集（method set）
在Go中，我们可以给满足某些条件的类型声明方法。方法也常被称为成员函数。 一个类型的所有方法组成了此类型的方法集。

概念：接口类型的动态类型和动态值
接口类型的值称为接口值。一个接口值可以包裹装载一个非接口值。包裹在一个接口值中的非接口值称为此接口值的动态值。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。

一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。

如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型实现了此接口类型。

接口一文详细解释了接口类型和接口值。

概念：一个值的具体类型（concrete type）和具体值（concrete value）
对于一个（类型确定的）非接口值，它的具体类型就是它的类型，它的具体值就是它自己。

一个零值接口值没有具体类型和具体值。 对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。

概念：容器类型
数组、切片和映射是Go中的三种正式意义上的内置容器类型。

有时候，字符串和通道类型也可以被非正式地看作是容器类型。

（正式和非正式的）容器类型的每个值都有一个长度属性。

数组、切片和映射一文详细解释了各种正式容器类型和它们的值。

概念：映射类型的键值（key）类型
如果一个映射类型的底层类型表示为map[Tkey]T，则此映射类型的键值类型为Tkey。 Tkey必须为一个可比较类型（见下）。

概念：容器类型的元素（element）类型
存储在一个容器值中的所有元素的类型必须为同一个类型。此同一类型称为此容器值的（容器）类型的元素类型。
如果一个数组类型的底层类型表示为[N]T，则此数组类型的元素类型为T所表示的类型。
如果一个切片类型的底层类型表示为[]T，则此切片类型的元素类型为T所表示的类型。
如果一个映射类型的底层类型表示为map[Tkey]T，则此映射类型的元素类型为T所表示的类型。
如果一个通道类型的底层类型表示为chan T、chan<- T或者<-chan T，则此通道类型的元素类型为T所表示的类型。
一个字符串类型的元素类型总是内置类型byte（亦即uint8）。
概念：通道类型的方向
一个通道值可以被看作是先入先出（first-in-first-out，FIFO）队列。一个通道值可能是可读可写的、只读的（receive-only）或者只写的（send-only）。
一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为chan T。
我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为chan<- T。
我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为<-chan T。
通道一文详细解释了通道类型和通道值。

事实：可比较类型和不可比较类型
目前（Go 1.20），下面这些类型的值不支持（使用==和!=运算标识符）比较。这些类型称为不可比较类型。
切片类型
映射类型
函数类型
任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型。
其它类型称为可比较类型。

映射类型的键值类型必须为可比较类型。


## 指针
指针
虽然Go吸收融合了很多其语言中的各种特性，但是Go主要被归入C语言家族。其中一个重要的原因就是Go和C一样，也支持指针。 当然Go中的指针相比C指针有很多限制。本篇文章将介绍指针相关的各种概念和Go指针相关的各种细节。

内存地址
在编程中，一个内存地址用来定位一段内存。

通常地，一个内存地址用一个操作系统原生字（native word）来存储。 一个原生字在32位操作系统上占4个字节，在64位操作系统上占8个字节。 所以，32位操作系统上的理论最大支持内存容量为4GB（1GB == 230字节），64位操作系统上的理论最大支持内存容量为264Byte，即16EB（EB：艾字节，1EB == 1024PB, 1PB == 1024TB, 1TB == 1024GB）。

内存地址的字面形式常用整数的十六进制字面量来表示，比如0x1234CDEF。

以后我们常简称内存地址为地址。

值的地址
一个值的地址是指此值的直接部分占据的内存的起始地址。在Go中，每个值都包含一个直接部分，但有些值可能还包含一个或多个间接部分，下下章将对此详述。

什么是指针？
指针是Go中的一种类型分类（kind）。 一个指针可以存储一个内存地址；从地址通常为另外一个值的地址。

和C指针不一样，为了安全起见，Go指针有很多限制，详见下面的章节。

指针类型和值
在Go中，一个无名指针类型的字面形式为*T，其中T为一个任意类型。类型T称为指针类型*T的基类型（base type）。 如果一个指针类型的基类型为T，则我们可以称此指针类型为一个T指针类型。

虽然我们可以声明具名指针类型，但是一般不推荐这么做，因为无名指针类型的可读性更高。

如果一个指针类型的底层类型是*T，则它的基类型为T。

如果两个无名指针类型的基类型为同一类型，则这两个无名指针类型亦为同一类型。

一些指针类型的例子：
*int  // 一个基类型为int的无名指针类型。
**int // 一个多级无名指针类型，它的基类型为*int。

type Ptr *int // Ptr是一个具名指针类型，它的基类型为int。
type PP *Ptr  // PP是一个具名多级指针类型，它的基类型为Ptr。
指针类型的零值的字面量使用预声明的nil来表示。一个nil指针（常称为空指针）中不存储任何地址。

如果一个指针类型的基类型为T，则此指针类型的值只能存储类型为T的值的地址。

关于引用（reference）这个术语
在《Go语言101》中，术语“引用”暗示着一个关系。比如，如果一个指针中存储着另外一个值的地址，则我们可以说此指针值引用着另外一个值；同时另外一个值当前至少有一个引用。 本书对此术语的使用和Go白皮书是一致的。

当一个指针引用着另外一个值，我们也常说此指针指向另外一个值。

如何获取一个指针值？
有两种方式来得到一个指针值：
我们可以用内置函数new来为任何类型的值开辟一块内存并将此内存块的起始地址做为此值的地址返回。 假设T是任一类型，则函数调用new(T)返回一个类型为*T的指针值。 存储在返回指针值所表示的地址处的值（可被看作是一个匿名变量）为T的零值。
我们也可以使用前置取地址操作符&来获取一个可寻址的值的地址。 对于一个类型为T的可寻址的值t，我们可以用&t来取得它的地址。&t的类型为*T。
一般说来，一个可寻址的值是指被放置在内存中某固定位置处的一个值（但放置在某固定位置处的一个值并非一定是可寻址的）。 目前，我们只需知道所有变量都是可以寻址的；但是所有常量、函数返回值和强制转换结果都是不可寻址的。 当一个变量被声明的时候，Go运行时将为此变量开辟一段内存。此内存的起始地址即为此变量的地址。

更多可被（或不可被）寻址的值将在以后的文章中逐渐提及。 如果你已经对Go比较熟悉，你可以阅读此条总结来了解在Go中哪些值可以或不可以被寻址。

下一节中的例子将展示如何获取一些值的地址。

指针（地址）解引用
我们可以使用前置解引用操作符*来访问存储在一个指针所表示的地址处的值（即此指针所引用着的值）。 比如，对于基类型为T的指针类型的一个指针值p，我们可以用*p来表示地址p处的值。 此值的类型为T。*p称为指针p的解引用。解引用是取地址的逆过程。

解引用一个nil指针将产生一个恐慌。

下面这个例子展示了如何取地址和解引用。
package main

import "fmt"

func main() {
p0 := new(int)   // p0指向一个int类型的零值
fmt.Println(p0)  // （打印出一个十六进制形式的地址）
fmt.Println(*p0) // 0

	x := *p0              // x是p0所引用的值的一个复制。
	p1, p2 := &x, &x      // p1和p2中都存储着x的地址。
	                      // x、*p1和*p2表示着同一个int值。
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
	p3 := &*p0            // <=> p3 := &(*p0)
	                      // <=> p3 := p0
	                      // p3和p0中存储的地址是一样的。
	fmt.Println(p0 == p3) // true
	*p0, *p1 = 123, 789
	fmt.Println(*p2, x, *p3) // 789 789 123

	fmt.Printf("%T, %T \n", *p0, x) // int, int
	fmt.Printf("%T, %T \n", p0, p1) // *int, *int
}
下面这张图描绘了上面这个例子中各个值之间的关系。

指针值
我们为什么需要指针？
让我们先看一个例子：
package main

import "fmt"

func double(x int) {
x += x
}

func main() {
var a = 3
double(a)
fmt.Println(a) // 3
}
我们本期望上例中的double函数将变量a的值放大为原来的两倍，但是事实证明我们的期望没有得到实现。 为什么呢？因为在Go中，所有的赋值（包括函数调用传参）过程都是一个值复制过程。 所以在上面的double函数体内修改的是变量a的一个副本，而没有修改变量a本身。

当然我们可以让double函数返回输入参数的两倍数，但是此方法并非适用于所有场合。 下面这个例子通过将输入参数的类型改为一个指针类型来达到同样的目的。
package main

import "fmt"

func double(x *int) {
*x += *x
x = nil // 此行仅为讲解目的
}

func main() {
var a = 3
double(&a)
fmt.Println(a) // 6
p := &a
double(p)
fmt.Println(a, p == nil) // 12 false
}
从上例可以看出，通过将double函数的输入参数的类型改为*int，传入的实参&a和它在此函数体内的一个副本x都引用着变量a。 所以对*x的修改等价于对*p（也就是变量a）的修改。 换句话说，新版本的double函数内的操作可以反映到此函数外了。

当然，在此函数体内对传入的指针实参的修改x = nil依旧不能反映到函数外，因为此修改发生在此指针的一个副本上。 所以在double函数调用之后，局部变量p的值并没有被修改为nil。

简而言之，指针提供了一种间接的途径来访问和修改一些值。 虽然很多语言中没有指针这个概念，但是指针被隐藏其它概念之中。

在Go中返回一个局部变量的地址是安全的
和C不一样，Go是支持垃圾回收的，所以一个函数返回其内声明的局部变量的地址是绝对安全的。比如：
func newInt() *int {
a := 3
return &a
}
Go指针的一些限制
为了安全起见，Go指针在使用上相对于C指针有很多限制。 通过施加这些限制，Go指针保留了C指针的好处，同时也避免了C指针的危险性。

Go指针不支持算术运算
在Go中，指针是不能参与算术运算的。比如，对于一个指针p， 运算p++和p-2都是非法的。

如果p为一个指向一个数值类型值的指针，*p++将被编译器认为是合法的并且等价于(*p)++。 换句话说，解引用操作符*的优先级都高于自增++和自减--操作符。

例子：
package main

import "fmt"

func main() {
a := int64(5)
p := &a

	// 下面这两行编译不通过。
	/*
	p++
	p = (&a) + 8
	*/

	*p++
	fmt.Println(*p, a)   // 6 6
	fmt.Println(p == &a) // true

	*&a++
	*&*&a++
	**&p++
	*&*p++
	fmt.Println(*p, a) // 10 10
}
一个指针类型的值不能被随意转换为另一个指针类型
在Go中，只有如下某个条件被满足的情况下，一个类型为T1的指针值才能被显式转换为另一个指针类型T2：
类型T1和T2的底层类型必须一致（忽略结构体字段的标签）。 特别地，如果类型T1和T2中只要有一个是无名类型并且它们的底层类型一致（考虑结构体字段的标签），则此转换可以是隐式的。 关于结构体，请参阅下一篇文章。
类型T1和T2都为无名类型并且它们的基类型的底层类型一致（忽略结构体字段的标签）。
比如，
type MyInt int64
type Ta    *int64
type Tb    *MyInt
对于上面所示的这些指针类型，下面的事实成立：
类型*int64的值可以被隐式转换到类型Ta，反之亦然（因为它们的底层类型均为*int64）。
类型 *MyInt的值可以被隐式转换到类型Tb，反之亦然（因为它们的底层类型均为*MyInt）。
类型*MyInt的值可以被显式转换为类型*int64，反之亦然（因为它们都是无名的并且它们的基类型的底层类型均为int64）。
类型Ta的值不能直接被转换为类型Tb，即使是显式转换也是不行的。 但是，通过上述三条事实，通过三层显式转换Tb((*MyInt)((*int64)(ta)))，一个类型为Ta的值ta可以被间接地转换为类型Tb。
这些指针类型的任何值都无法被转换到类型*uint64。

一个指针值不能和其它任一指针类型的值进行比较
Go指针值是支持（使用比较运算符==和!=）比较的。 但是，两个指针只有在下列任一条件被满足的时候才可以比较：
这两个指针的类型相同。
其中一个指针可以被隐式转换为另一个指针的类型。换句话说，这两个指针的类型的底层类型必须一致并且至少其中一个指针类型为无名的（考虑结构体字段的标签）。
其中一个并且只有一个指针用类型不确定的nil标识符表示。
例子：
package main

func main() {
type MyInt int64
type Ta    *int64
type Tb    *MyInt

	// 4个不同类型的指针：
	var pa0 Ta
	var pa1 *int64
	var pb0 Tb
	var pb1 *MyInt

	// 下面这6行编译没问题。它们的比较结果都为true。
	_ = pa0 == pa1
	_ = pb0 == pb1
	_ = pa0 == nil
	_ = pa1 == nil
	_ = pb0 == nil
	_ = pb1 == nil

	// 下面这三行编译不通过。
	/*
	_ = pa0 == pb0
	_ = pa1 == pb1
	_ = pa0 == Tb(nil)
	*/
}
一个指针值不能被赋值给其它任意类型的指针值
一个指针值可以被赋值给另一个指针值的条件和这两个指针值可以比较的条件（见上一小节）是一致的。

上述Go指针的限制是可以被打破的
unsafe标准库包中提供的非类型安全指针（unsafe.Pointer）机制可以被用来打破上述Go指针的安全限制。 unsafe.Pointer类型类似于C语言中的void*。 但是，通常地，非类型安全指针机制不推荐在Go日常编程中使用。

## 结构体
结构体类型和结构体字面量表示形式
每个无名结构体类型的字面形式均由struct关键字开头，后面跟着用一对大括号{}，其中包裹着的一系列字段（field）声明。 一般来说，每个字段声明由一个字段名和字段类型组成。一个结构体类型的字段数目可以为0。下面是一个无名结构体类型的字面形式：
struct {
title  string
author string
pages  int
}
上面这个结构体类型含有三个字段。前两个字段（title和author）的类型均为string。 最后一个字段pages的类型为int。

有时字段也称为成员变量。

相邻的同类型字段可以声明在一起。比如上面这个类型也可表示成下面这样：
struct {
title, author string
pages         int
}
一个结构体类型的尺寸为它的所有字段的（类型）尺寸之和加上一些填充字节的数目。 常常地，编译器（和运行时）会在一个结构体值的两个相邻字段之间填充一些字节来保证一些字段的地址总是某个整数的倍数。 我们可以在后面的内存布局一文中了解到字节填充（padding）和内存地址对齐（memory address alignment）。

一个零字段结构体的尺寸为零。

每个结构体字段在它的声明中可以被指定一个标签（tag）。从语法上讲，字段标签可以是任意字符串，它们是可选的，默认为空字符串。 但在实践中，它们应该被表示成用空格分隔的键值对形式，并且每个标签尽量使用直白字面形式（`...`）表示，而键值对中的值使用解释型字面形式（"..."）表示。 比如下例：
struct {
Title  string `json:"title" myfmt:"s1"`
Author string `json:"author,omitempty" myfmt:"s2"`
Pages  int    `json:"pages,omitempty" myfmt:"n1"`
X, Y   bool   `myfmt:"b1"`
}
注意：上例中的X和Y字段的标签是一样的（尽管在实践中基本上从不会这样使用字段标签）。

我们可以使用反射来检视字段的标签信息。

每个字段标签的目的取决于具体应用。上面这个例子中的字段标签用来帮助encoding/json标准库包来将上面这个结构体类型的某个值编码成JSON数据或者从一份JSON数据解码到上面这个结构体类型的某个值中。在编码和解码过程中，encoding/json标准库包中的函数将只考虑导出的结构体字段。这是为什么上面这个结构体的字段均为导出的。

把字段标签当成字段注释来使用不是一个好主意。

和C语言不一样，Go结构体不支持字段联合（union）。

上面的例子中展示的结构体类型都是无名的。在实践中，具名结构体类型用得更流行。

只有导出字段可以被使用在其它代码包中。非导出字段类以于很多其它语言中的私有或者保护型的成员变量。

一个结构体类型中的字段标签和字段的声明顺序对此结构体类型的身份识别很重要。 如果两个无名结构体类型的各个对应字段声明都相同（按照它们的出现顺序），则此两个无名结构体类型是等同的。 两个字段声明只有在它们的名称、类型和标签都等同的情况下才相同。 注意：两个声明在不同的代码包中的非导出字段将总被认为是不同的字段。

一个结构体类型不能（直接或者间接）含有一个类型为此结构类型的字段。

结构体字面量表示形式和结构体值的使用
在Go中，语法形式T{...}称为一个组合字面量形式（composite literal），其中T必须为一个类型名或者类型字面形式。 组合字面量形式可以用来表示结构体类型和内置容器类型（将在后面的文章中介绍）的值。

注意：组合字面量T{...}是一个类型确定值，它的类型为T。

假设S是一个结构体类型并且它的底层类型为struct{x int; y bool}，S的零值可以表示成下面所示的组合字面量两种变种形式：
S{0, false}。在此变种形式中，所有的字段名称均不出现，但每个字段的值必须指定，并且每个字段的出现顺序和它们的声明顺序必须一致。
S{x: 0, y: false}、S{y: false, x: 0}、S{x: 0}、S{y: false}和S{}。 在此变种形式中，字段的名称和值必须成对出现，但是每个字段都不是必须出现的，并且字段的出现顺序并不重要。 没有出现的字段的值被编译器认为是它们各自类型的零值。S{}是最常用的类型S的零值的表示形式。
如果S是声明在另一个代码包中的一个结构体类型，则推荐使用上面所示的第二种变种形式来表示它的值。 因为另一个代码包的维护者今后可能会在此结构体中添加新的字段，从而导致当前使用的第一种变种形式在今后可能编译不通过。

当然，上面所示的结构体值的组合字面量也可以用来表示结构体类型的非零值。

对于类型S的一个值v，我们可以用v.x和v.y来表示它的字段。 v.x（或v.y）这种形式称为一个选择器（selector）。其中的v称为此选择器的属主。 今后，我们称一个选择器中的句点.为属性选择操作符。

一个例子：
package main

import (
"fmt"
)

type Book struct {
title, author string
pages         int
}

func main() {
book := Book{"Go语言101", "老貘", 256}
fmt.Println(book) // {Go语言101 老貘 256}

	// 使用带字段名的组合字面量来表示结构体值。
	book = Book{author: "老貘", pages: 256, title: "Go语言101"}
	// title和author字段的值都为空字符串""，pages字段的值为0。
	book = Book{}
	// title字段空字符串""，pages字段为0。
	book = Book{author: "老貘"}

	// 使用选择器来访问和修改字段值。
	var book2 Book // <=> book2 := Book{}
	book2.author = "Tapir"
	book2.pages = 300
	fmt.Println(book2.pages) // 300
}
如果一个组合字面量中最后一项和结尾的}处于同一行，则此项后的逗号,是可选的；否则此逗号不可省略。 我们可以阅读后面的Go代码断行规则一文了解更多断行规则。
var _ = Book {
author: "老貘",
pages: 256,
title: "Go语言101", // 这里行尾的逗号不可省略
}

// 下行}前的逗号可以省略。
var _ = Book{author: "老貘", pages: 256, title: "Go语言101",}
关于结构体值的赋值
当一个（源）结构体值被赋值给另外一个（目标）结构体值时，其效果和逐个将源结构体值的各个字段赋值给目标结构体值的各个对应字段的效果是一样的。
func f() {
book1 := Book{pages: 300}
book2 := Book{"Go语言101", "老貘", 256}

	book2 = book1
	// 上面这行和下面这三行是等价的。
	book2.title = book1.title
	book2.author = book1.author
	book2.pages = book1.pages
}
如果两个结构体值的类型不同，则只有在它们的底层类型相同（要考虑字段标签）并且其中至少有一个结构体值的类型为无名类型时（换句话说，只有它们可以被隐式转换为对方的类型的时候，见下）才可以互相赋值。

结构体字段的可寻址性
如果一个结构体值是可寻址的，则它的字段也是可寻址的；反之，一个不可寻址的结构体值的字段也是不可寻址的。 不可寻址的字段的值是不可更改的。所有的组合字面量都是不可寻址的。

一个例子：
package main

import "fmt"

func main() {
type Book struct {
Pages int
}
var book = Book{} // 变量值book是可寻址的
p := &book.Pages
*p = 123
fmt.Println(book) // {123}

	// 下面这两行编译不通过，因为Book{}是不可寻址的，
	// 继而Book{}.Pages也是不可寻址的。
	/*
	Book{}.Pages = 123
	p = &Book{}.Pages // <=> p = &(Book{}.Pages)
	*/
}
注意：选择器中的属性选择操作符.的优先级比取地址操作符&的优先级要高。

组合字面量不可寻址但可被取地址
一般来说，只有可被寻址的值才能被取地址，但是Go中有一个语法糖（语法例外）：虽然所有的组合字面量都是不可寻址的，但是它们都可被取地址。

例子：
package main

func main() {
type Book struct {
Pages int
}
// Book{100}是不可寻址的，但是它可以被取地址。
p := &Book{100} // <=> tmp := Book{100}; p := &tmp
p.Pages = 200
}
在字段选择器中，属主结构体值可以是指针，它将被隐式解引用
比如，在下面的例子中，为了简洁，(*bookN).pages可以被写成bookN.pages。 换句话说，在这种简写形式中，bookN将被隐式解引用。
package main

func main() {
type Book struct {
pages int
}
book1 := &Book{100} // book1是一个指针
book2 := new(Book)  // book2是另外一个指针
// 像使用结构值一样来使用结构体值的指针。
book2.pages = book1.pages
// 上一行等价于下一行。换句话说，上一行
// 两个选择器中的指针属主将被自动解引用。
(*book2).pages = (*book1).pages
}
关于结构体值的比较
如果一个结构体类型是可比较的，则它肯定不包含不可比较类型的字段（这里不忽略名为空标识符_的字段）。

和结构体值的赋值规则类似，如果两个不同类型的结构体值均为可比较的，则它们仅在它们的底层类型相同（要考虑字段标签）并且其中至少有一个结构体值的类型为无名类型时（换句话说，只有它们可以被隐式转换为对方的类型的时候，见下）才可以互相比较。

如果两个结构体值可以相互比较，则它们的比较结果等同于逐个比较它们的相应字段（按照字段在代码中的声明顺序）。 两个结构体值只有在它们的相应字段都相等的情况下才相等；当一对字段被发现不相等的或者在比较中产生恐慌的时候，对结构体的比较将提前结束结束。 在比较中，名为空标识符_的字段将被忽略掉。

关于结构体值的类型转换
两个类型分别为S1和S2的结构体值只有在S1和S2的底层类型相同（忽略掉字段标签）的情况下才能相互转换为对方的类型。 特别地，如果S1和S2的底层类型相同（要考虑字段标签）并且只要它们其中有一个为无名类型，则此转换可以是隐式的。

比如，对于下面的代码片段中所示的五个结构体类型：S0、S1、S2、S3和S4：
类型S0的值不能被转换为其它四个类型中的任意一个，原因是它与另外四个类型的对应字段名不同（因此底层类型不同）。
类型S1、S2、S3和S4的任意两个值可以转换为对方的类型。
特别地，
S2表示的类型的值可以被隐式转化为类型S3，反之亦然。
S2表示的类型的值可以被隐式转换为类型S4，反之亦然。
但是，
S2表示的类型的值必须被显式转换为类型S1，反之亦然。
类型S3的值必须被显式转换为类型S4，反之亦然。
package main

type S0 struct {
y int "foo"
x bool
}

type S1 = struct { // S1是一个无名类型
x int "foo"
y bool
}

type S2 = struct { // S2也是一个无名类型
x int "bar"
y bool
}

type S3 S2 // S3是一个定义类型（因而具名）。
type S4 S3 // S4是一个定义类型（因而具名）。
// 如果不考虑字段标签，S3（S4）和S1的底层类型一样。
// 如果考虑字段标签，S3（S4）和S1的底层类型不一样。

var v0, v1, v2, v3, v4 = S0{}, S1{}, S2{}, S3{}, S4{}
func f() {
v1 = S1(v2); v2 = S2(v1)
v1 = S1(v3); v3 = S3(v1)
v1 = S1(v4); v4 = S4(v1)
v2 = v3; v3 = v2 // 这两个转换可以是隐式的
v2 = v4; v4 = v2 // 这两个转换也可以是隐式的
v3 = S3(v4); v4 = S4(v3)
}
事实上，两个结构体值只有在它们可以相互隐式转换为对方的类型的时候才能相互赋值和比较。

匿名结构体类型可以使用在结构体字段声明中
匿名结构体类型允许出现在结构体字段声明中。匿名结构体类型也允许出现在组合字面量中。

一个例子：
var aBook = struct {
author struct { // 此字段的类型为一个匿名结构体类型
firstName, lastName string
gender              bool
}
title string
pages int
}{
author: struct {
firstName, lastName string
gender              bool
}{
firstName: "Mark",
lastName: "Twain",
}, // 此组合字面量中的类型为一个匿名结构体类型
title: "The Million Pound Note",
pages: 96,
}
通常来说，为了代码可读性，最好少使用匿名结构体类型。

## 值部
Go类型分为两大类别（category）
Go可以被看作是一门C语言血统的语言，这可以通过此前的指针和结构体两篇文章得以验证。 Go中的指针和结构体类型的内存结构和C语言很类似。

另一方面，Go也可以被看作是C语言的一个扩展框架。 在C中，值的内存结构都是很透明的；但在Go中，对于某些类型的值，其内存结构却不是很透明。 在C中，每个值在内存中只占据一个内存块（一段连续内存）；但是，一些Go类型的值可能占据多个内存块。

以后，我们称一个Go值分布在不同内存块上的部分为此值的各个值部（value part）。 一个分布在多个内存块上的值含有一个直接值部和若干被此直接值部引用着的间接值部。

上面的段落描述了两个类别的Go类型。下表将列出这两个类别（category）中的类型（type）种类（kind）：
每个值在内存中只分布在一个内存块上的类型	每个值在内存中会分布在多个内存块上的类型
单值部	多值部
布尔类型
各种数值类型
指针类型
非类型安全指针类型
结构体类型
数组类型
切片类型
映射类型
通道类型
函数类型
接口类型
字符串类型
表中列出的很多类型将在后续文章中逐一详细讲解。本文的目的就是为了给后续的讲解做一个铺垫。

注意：
接口类型和字符串类型值是否包含间接部分取决于具体编译器实现。 如果不使用今后将介绍的非类型安全途径，我们无法从这两类类型的值的外在表现来判定它们的值是否含有间接部分。 在《Go语言101》中，我们认为这两类类型的值是可能包含间接值部的。
同样地，函数类型的值是否包含间接部分几乎也是不可能验证的。 在《Go语言101》中，我们认为函数值是可能包含间接值部的。
通过封装了很多具体的实现细节，第二个类别中的类型给Go编程带来了很大的便利。 不同的编译器实现会采用不同的内部结构来实现这些类型，但是这些类型的值的外在表现必须满足Go白皮书中的要求。 此分类中的类型对于编程来说并非是很基础的类型。 我们可以使用第一个分类中的类型来实现此分类中的类型。 但是，通过将一些常用或者很独特的功能封装到此第二个分类中的类型里，使用Go编程的效率将得到大大提升，体验将得到大大增强。

另一方面，这些封装同时也隐藏了这些类型的值的内部结构，使得Go程序员不能对这些类型有一个更全局更深刻的认识。有时候这会对更好地理解Go带来了一些障碍。

为了帮助Go程序员更好的理解第二个分类中的类型和它们的值，本文余下的内容将对这些类型的内在实现做一个简单介绍。 这些实现的细节将不会在本文中谈及。本文的介绍主要基于（但并不完全符合）官方标准编译器的实现。

Go中的两种指针类型
在继续下面的内容之前，我们先了解一下Go中的两种指针类型并明确一下“引用”这个词的含义。

我们已经在上上篇文章中了解了Go中的指针。 那篇文章中所介绍的指针属于类型安全的指针。事实上，Go还支持另一种称为非类型安全的指针类型。 非类型安全的指针类型提供在unsafe标准库包中。 非类型安全指针类型通常使用unsafe.Pointer来表示。 unsafe.Pointer类似于C语言中的void*。

在《Go语言101》中的大多数文章中，如果没有特别说明，当一个指针类型被谈及，它表示一个类型安全指针。 但是在本文的余下内容中，当一个指针被谈及，它可能表示一个类型安全指针，也可能表示一个非类型安全指针。

一个指针值存储着另一个值的地址，除非此指针值是一个nil空指针。 我们可以说此指针引用着另外一个值，或者说另外一个值正被此指针所引用。 一个值可能被间接引用，比如
如果一个结构体值a含有一个指针字段b并且这个指针字段b引用着另外一个值c，那么我们可以说结构体值a也引用着值c。
如果一个值x（直接或者间接地）引用着另一个值y，并且值y（直接或者间接地）引用着第三个值z，则我们可以说值x间接地引用着值z。
以后，我们将一个含有（直接或者间接）指针字段的结构体类型称为一个指针包裹类型，将一个含有（直接或者间接）指针的类型称为指针持有者类型。 指针类型和指针包裹类型都属于指针持有者类型。元素类型为指针持有者类型的数组类型也是指针持有者类型（数组将在下一篇文章中介绍）。

第二个分类中的类型的（可能的）内部实现结构定义
为了更好地理解第二个分类中的类型的值的运行时刻行为，我们可以认为这些类型在内部是使用第一个分类中的类型来定义的（如下所示）。 如果你以前并没有很多使用过Go中各种类型的经验，目前你不必深刻地理解这些定义。 对这些定义拥有一个粗糙的印象足够对理解后续文章中将要讲解的类型有所帮助。 你可以在今后有了更多的Go编程经验之后再重读一下本文。

映射、通道和函数类型的内部定义
映射、通道和函数类型的内部定义很相似：
// 映射类型
type _map *hashtableImpl // 目前，官方标准编译器是使用
// 哈希表来实现映射的。

// 通道类型
type _channel *channelImpl

// 函数类型
type _function *functionImpl
从这些定义，我们可以看出来，这三个种类的类型的内部结构其实是一个指针类型。 或者说，这些类型的值的直接部分在内部是一个指针。 这些类型的每个值的直接部分引用着它的具体实现的底层间接部分。

切片类型的内部定义
切片类型的内部定义：
type _slice struct {
elements unsafe.Pointer // 引用着底层的元素
len      int            // 当前的元素个数
cap      int            // 切片的容量
}
从这个定义可以看出来，一个切片类型在内部可以看作是一个指针包裹类型。 每个非零切片值包含着一个底层间接部分用来存储此切片的元素。 一个切片值的底层元素序列（间接部分）被此切片值的elements字段所引用。

字符串类型的内部结构
type _string struct {
elements *byte // 引用着底层的byte元素
len      int   // 字符串的长度
}
从此定义可以看出，每个字符串类型在内部也可以看作是一个指针包裹类型。 每个非零字符串值含有一个指针字段 elements。 这个指针字段引用着此字符串值的底层字节元素序列。

接口类型的内部定义
我们可以认为接口类型在内部是如下定义的：
type _interface struct {
dynamicType  *_type         // 引用着接口值的动态类型
dynamicValue unsafe.Pointer // 引用着接口值的动态值
}
从这个定义来看，接口类型也可以看作是一个指针包裹类型。一个接口类型含有两个指针字段。 每个非零接口值的（两个）间接部分分别存储着此接口值的动态类型和动态值。 这两个间接部分被此接口值的直接字段dynamicType和dynamicValue所引用。

事实上，上面这个内部定义只用于表示空接口类型的值。空接口类型没有指定任何方法。 后面的接口一文详细解释了接口类型和值。 非空接口类型的内部定义如下：
type _interface struct {
dynamicTypeInfo *struct {
dynamicType *_type       // 引用着接口值的动态类型
methods     []*_function // 引用着动态类型的对应方法列表
}
dynamicValue unsafe.Pointer // 引用着动态值
}
一个非空接口类型的值的dynamicTypeInfo字段的methods字段引用着一个方法列表。 此列表中的每一项为此接口值的动态类型上定义的一个方法，此方法对应着此接口类型所指定的一个的同描述的方法。

在赋值中，底层间接值部将不会被复制
现在我们了解了第二个分类中的类型的内部结构是一个指针持有（指针或者指针包裹）类型。 这对于我们理解Go中的值复制行为有很大帮助。

在Go中，每个赋值操作（包括函数调用传参等）都是一个值的浅复制过程（假设源值和目标值的类型相同）。 换句话说，在一个赋值操作中，只有源值的直接部分被复制给了目标值。 如果源值含有间接部分，则在此赋值操作完成之后，目标值和源值的直接部分将引用着相同的间接部分。 换句话说，两个值将共享底层的间接值部，如下图所示：

值复制
事实上，对于字符串值和接口值的赋值，上述描述在理论上并非百分百正确。 官方FAQ明确说明了在一个接口值的赋值中，接口的底层动态值将被复制到目标值。 但是，因为一个接口值的动态值是只读的，所以在接口值的赋值中，官方标准编译器并没有复制底层的动态值。这可以被视为是一个编译器优化。 对于字符串值的赋值，道理是一样的。所以对于官方标准编译器来说，上一段的描述是100%正确的。

因为一个间接值部可能并不专属于任何一个值，所以在使用unsafe.Sizeof函数计算一个值的尺寸的时候，此值的间接部分所占内存空间未被计算在内。

关于术语“引用类型”和“引用值”
“引用”这个术语在Go社区中使用得有些混乱。很多Go程序员在Go编程中可能由此产生了一些困惑。 一些文档或者网络文章，包括一些官方文档，把“引用”（reference）看作是“值”（value）的一个对立面。 《Go语言101》强烈不推荐这种定义。在这一点上，本人不想争论什么。这里仅仅列出一些肯定错误地使用了“引用”这个术语的例子：
在Go中，只有切片、映射、通道和函数类型属于引用类型。 （如果我们确实需要引用类型这个术语，那么我们不应把其它指针持有者类型排除在引用类型之外。）
一些函数调用的参数是通过引用来传递的。 （对不起，在Go中，所有的函数调用的参数都是通过值复制直接值部的方式来传递的。）

## 数组、切片和映射
容器类型和容器值概述
每个容器（值）用来表示和存储一个元素（element）序列或集合。一个容器中的所有元素的类型是相同的。此相同的类型称为此容器的类型的元素类型（或简称此容器的元素类型）。

存储在一个容器中的每个元素值都关联着一个键值（key）。每个元素可以通过它的键值而被访问到。 一个映射类型的键值类型必须为一个可比较类型。 数组和切片类型的键值类型均为内置类型int。 一个数组或切片的一个元素对应的键值总是一个非负整数下标，此非负整数表示该元素在该数组或切片所有元素中的顺序位置。此非负整数下标亦常称为一个元素索引（index）。

每个容器值有一个长度属性，用来表明此容器中当前存储了多少个元素。 一个数组或切片中的每个元素所关联的非负整数索引键值的合法取值范围为左闭右开区间[0, 此数组或切片的长度)。 一个映射值类型的容器值中的元素关联的键值可以是任何此映射类型的键值类型的任何值。

这三种容器类型的值在使用上有很多的差别。这些差别多源于它们的内存结构的差异。 通过上一篇文章值部，我们得知每个数组值仅由一个直接部分组成，而一个切片或者映射值是由一个直接部分和一个可能的被此直接部分引用着的间接部分组成。

一个数组或者切片的所有元素紧挨着存放在一块连续的内存中。一个数组中的所有元素均存放在此数组值的直接部分，一个切片中的所有元素均存放在此切片值的间接部分。 在官方标准编译器和运行时中，映射是使用哈希表算法来实现的。所以一个映射中的所有元素也均存放在一块连续的内存中，但是映射中的元素并不一定紧挨着存放。 另外一种常用的映射实现算法是二叉树算法。无论使用何种算法，一个映射中的所有元素的键值也存放在此映射值（的间接部分）中。

我们可以通过一个元素的键值来访问此元素。 对于这三种容器，元素访问的时间复杂度均为O(1)。 但是一般来说，映射元素访问消耗的时长要数倍于数组和切片元素访问消耗的时长。 但是映射相对于数组和切片有两个优点：
映射的键值类型可以是任何可比较类型。
对于大多数元素为零值的情况，使用映射可以节省大量的内存。
从上一篇文章中，我们已经了解到，在任何赋值中，源值的底层间接部分不会被复制。 换句话说，当一个赋值结束后，一个含有间接部分的源值和目标值将共享底层间接部分。 这就是数组和切片/映射值会有很多行为差异（将在下面逐一介绍）的原因。

无名容器类型的字面表示形式
无名容器类型的字面表示形式如下：
数组类型：[N]T
切片类型：[]T
映射类型：map[K]T
其中，
T可为任意类型。它表示一个容器类型的元素类型。某个特定容器类型的值中只能存储此容器类型的元素类型的值。
N必须为一个非负整数常量。它指定了一个数组类型的长度，或者说它指定了此数组类型的任何一个值中存储了多少个元素。 一个数组类型的长度是此数组类型的一部分。比如[5]int和[8]int是两个不同的类型。
K必须为一个可比较类型。它指定了一个映射类型的键值类型。
下面列出了一些无名容器类型的字面表示：
const Size = 32

type Person struct {
name string
age  int
}

// 数组类型
[5]string
[Size]int
[16][]byte  // 元素类型为一个切片类型：[]byte
[100]Person // 元素类型为一个结构体类型：Person

// 切片类型
[]bool
[]int64
[]map[int]bool // 元素类型为一个映射类型：map[int]bool
[]*int         // 元素类型为一个指针类型：*int

// 映射类型
map[string]int
map[int]bool
map[int16][6]string     // 元素类型为一个数组类型：[6]string
map[bool][]string       // 元素类型为一个切片类型：[]string
map[struct{x int}]*int8 // 元素类型为一个指针类型：*int8；
// 键值类型为一个结构体类型。
所有切片类型的尺寸都是一致的，所有映射类型的尺寸也都是一致的。 一个数组类型的尺寸等于它的元素类型的尺寸和它的长度的乘积。长度为零的数组的尺寸为零；元素类型尺寸为零的任意长度的数组类型的尺寸也为零。

容器字面量的表示形式
和结构体值类似，容器值的文字表示也可以用组合字面量形式（composite literal）来表示。 比如对于一个容器类型T，它的值可以用形式T{...}来表示（除了切片和映射的零值外）。 下面是一些容器字面量：
// 一个含有4个布尔元素的数组值。
[4]bool{false, true, true, false}

// 一个含有三个字符串值的切片值。
[]string{"break", "continue", "fallthrough"}

// 一个映射值。
map[string]int{"C": 1972, "Python": 1991, "Go": 2009}
映射组合字面量中大括号中的每一项称为一个键值对（key-value pair），或者称为一个条目（entry）。

数组和切片组合字面量有一些微小的变种：
// 下面这些切片字面量都是等价的。
[]string{"break", "continue", "fallthrough"}
[]string{0: "break", 1: "continue", 2: "fallthrough"}
[]string{2: "fallthrough", 1: "continue", 0: "break"}
[]string{2: "fallthrough", 0: "break", "continue"}

// 下面这些数组字面量都是等价的。
[4]bool{false, true, true, false}
[4]bool{0: false, 1: true, 2: true, 3: false}
[4]bool{1: true, true}
[4]bool{2: true, 1: true}
[...]bool{false, true, true, false}
[...]bool{3: false, 1: true, true}
上例中最后两行中的...表示让编译器推断出相应数组值的类型的长度。

从上面的例子中，我们可以看出数组和切片组合字面量中的索引下标（即数组和切片的键值）是可选的。 在一个数组或者切片组合字面量中：
如果一个索引下标出现，它的类型不必是数组和切片类型的键值类型int，但它必须是一个可以表示为int值的非负常量； 如果它是一个类型确定值，则它的类型必须为一个内置整数类型。
在一个数组或切片组合字面量中，如果一个元素的索引下标缺失，则编译器认为它的索引下标为出现在它之前的元素的索引下标加一。
如果出现的第一个元素的索引下标缺失，则它的索引下标被认为是0。
映射组合字面量中元素对应的键值不可缺失，并且它们可以为非常量。

var a uint = 1
var _ = map[uint]int {a : 123} // 没问题
var _ = []int{a: 100}          // error: 下标必须为常量
var _ = [5]int{a: 100}         // error: 下标必须为常量
一个容器组合字面量中的常量键值（包括索引下标）不可重复。

容器类型零值的字面量表示形式
和结构体类似，一个数组类型A的零值可以表示为A{}。 比如，数组类型[100]int的零值可以表示为[100]int{}。 一个数组零值中的所有元素均为对应数组元素类型的零值。

和指针一样，所有切片和映射类型的零值均用预声明的标识符nil来表示。

顺便说一句，除了刚提到的三种类型，以后将介绍的函数、通道和接口类型的零值也用预声明的标识符nil来表示。

在运行时刻，即使一个数组变量在声明的时候未指定初始值，它的元素所占的内存空间也已经被开辟出来。 但是一个nil切片或者映射值的元素的内存空间尚未被开辟出来。

注意：[]T{}表示类型[]T的一个空切片值，它和[]T(nil)是不等价的。 同样，map[K]T{}和map[K]T(nil)也是不等价的。

容器字面量是不可寻址的但可以被取地址
我们已经了解到结构体（组合）字面量是不可寻址的但却是可以被取地址的。 容器字面量也不例外。

一个例子：
package main

import "fmt"

func main() {
pm := &map[string]int{"C": 1972, "Go": 2009}
ps := &[]string{"break", "continue"}
pa := &[...]bool{false, true, true, false}
fmt.Printf("%T\n", pm) // *map[string]int
fmt.Printf("%T\n", ps) // *[]string
fmt.Printf("%T\n", pa) // *[4]bool
}
内嵌组合字面量可以被简化
在某些情形下，内嵌在其它组合字面量中的组合字面量可以简化为{...}（即类型部分被省略掉了）。 内嵌组合字面量前的取地址操作符&有时也可以被省略。

比如，下面的组合字面量
// heads为一个切片值。它的类型的元素类型为*[4]byte。
// 此元素类型为一个基类型为[4]byte的指针类型。
// 此指针基类型为一个元素类型为byte的数组类型。
var heads = []*[4]byte{
&[4]byte{'P', 'N', 'G', ' '},
&[4]byte{'G', 'I', 'F', ' '},
&[4]byte{'J', 'P', 'E', 'G'},
}
可以被简化为
var heads = []*[4]byte{
{'P', 'N', 'G', ' '},
{'G', 'I', 'F', ' '},
{'J', 'P', 'E', 'G'},
}
下面这个数组组合字面量
type language struct {
name string
year int
}

var _ = [...]language{
language{"C", 1972},
language{"Python", 1991},
language{"Go", 2009},
}
可以被简化为
var _ = [...]language{
{"C", 1972},
{"Python", 1991},
{"Go", 2009},
}
下面这个映射组合字面量
type LangCategory struct {
dynamic bool
strong  bool
}

// 此映射值的类型的键值类型为一个结构体类型，
// 元素类型为另一个映射类型：map[string]int。
var _ = map[LangCategory]map[string]int{
LangCategory{true, true}: map[string]int{
"Python": 1991,
"Erlang": 1986,
},
LangCategory{true, false}: map[string]int{
"JavaScript": 1995,
},
LangCategory{false, true}: map[string]int{
"Go":   2009,
"Rust": 2010,
},
LangCategory{false, false}: map[string]int{
"C": 1972,
},
}
可以被简化为
var _ = map[LangCategory]map[string]int{
{true, true}: {
"Python": 1991,
"Erlang": 1986,
},
{true, false}: {
"JavaScript": 1995,
},
{false, true}: {
"Go":   2009,
"Rust": 2010,
},
{false, false}: {
"C": 1972,
},
}
注意，在上面的几个例子中，最后一个元素后的逗号不能被省略。原因详见后面的断行规则一文。

容器值的比较
在Go类型系统概述一文中，我们已经了解到映射和切片类型都属于不可比较类型。 所以任意两个映射值（或切片值）是不能相互比较的。

尽管两个映射值和切片值是不能比较的，但是一个映射值或者切片值可以和预声明的nil标识符进行比较以检查此映射值或者切片值是否为一个零值。

大多数数组类型都是可比较类型，除了元素类型为不可比较类型的数组类型。

当比较两个数组值时，它们的对应元素将按照逐一被比较（可以认为按照下标顺序比较）。这两个数组只有在它们的对应元素都相等的情况下才相等；当一对元素被发现不相等的或者在比较中产生恐慌的时候，对数组的比较将提前结束。

一个例子：
package main

import "fmt"

func main() {
var a [16]byte
var s []int
var m map[string]int

	fmt.Println(a == a)   // true
	fmt.Println(m == nil) // true
	fmt.Println(s == nil) // true
	fmt.Println(nil == map[string]int{}) // false
	fmt.Println(nil == []int{})          // false

	// 下面这些行编译不通过。
	/*
	_ = m == m
	_ = s == s
	_ = m == map[string]int(nil)
	_ = s == []int(nil)
	var x [16][]int
	_ = x == x
	var y [16]map[int]bool
	_ = y == y
	*/
}
查看容器值的长度和容量
除了上面已提到的容器长度属性（此容器中含有有多少个元素），每个容器值还有一个容量属性。 一个数组值的容量总是和它的长度相等；一个非零映射值的容量可以被认为是无限大的。切片值的容量的含义将在后续章节介绍。 一个切片值的容量总是不小于此切片值的长度。在编程中，只有切片值的容量有实际意义。

我们可以调用内置函数len来获取一个容器值的长度，或者调用内置函数cap来获取一个容器值的容量。 这两个函数都返回一个int类型确定结果值或者一个默认类型为int的类型不确定结果，具体取决于传递给它们的实参是否为常量表达式。 因为非零映射值的容量是无限大，所以cap并不适用于映射值。

一个数组值的长度和容量永不改变。同一个数组类型的所有值的长度和容量都总是和此数组类型的长度相等。 切片值的长度和容量可在运行时刻改变（一般只能通过被赋值的途径来修改，两者一般不可单独被修改）。 因为此原因，切片可以被认为是动态数组。 切片在使用上相比数组更为灵活，所以切片（相对数组）在编程用得更为广泛。

一个例子：
package main

import "fmt"

func main() {
var a [5]int
fmt.Println(len(a), cap(a)) // 5 5
var s []int
fmt.Println(len(s), cap(s)) // 0 0
s, s2 := []int{2, 3, 5}, []bool{}
fmt.Println(len(s), cap(s), len(s2), cap(s2)) // 3 3 0 0
var m map[int]bool
fmt.Println(len(m)) // 0
m, m2 := map[int]bool{1: true, 0: false}, map[int]int{}
fmt.Println(len(m), len(m2)) // 2 0
}
上面这个特定的例子中的每个切片值的长度和容量都相等，但这并不是一个普遍定律。 我们将在后面的章节中展示一些长度和容量不相等的切片值。

读取和修改容器的元素
一个容器值v中存储的对应着键值k的元素用语法形式v[k]来表示。 今后我们称v[k]为一个元素索引表达式。

假设v是一个数组或者切片，在v[k]中，
如果k是一个常量，则它必须满足上面列出的对出现在组合字面量中的索引的要求。 另外，如果v是一个数组，则k必须小于此数组的长度。
如果k不是一个常量，则它必须为一个整数。 另外它必须为一个非负数并且小于len(v)，否则，在运行时刻将产生一个恐慌。
如果v是一个零值切片，则在运行时刻将产生一个恐慌。
假设v是一个映射值，在v[k]中，k的类型必须为（或者可以隐式转换为）v的类型的元素类型。另外，
如果k是一个动态类型为不可比较类型的接口值，则v[k]在运行时刻将造成一个恐慌；
如果v[k]被用做一个赋值语句中的目标值并且v是一个零值nil映射，则v[k]在运行时刻将造成一个恐慌；
如果v[k]用来表示读取映射值v中键值k对应的元素，则它无论如何都不会产生一个恐慌，即使v是一个零值nil映射（假设k的估值没有造成恐慌）；
如果v[k]用来表示读取映射值v中键值k对应的元素，并且映射值v中并不含有对应着键值k的条目，则v[k]返回一个此映射值的类型的元素类型的零值。 一般情况下，v[k]被认为是一个单值表达式。但是在一个v[k]被用为唯一源值的赋值语句中，v[k]可以返回一个可选的第二个返回值。 此第二个返回值是一个类型不确定布尔值，用来表示是否有对应着键值k的条目存储在映射值v中。
一个展示了容器元素修改和读取的例子：
package main

import "fmt"

func main() {
a := [3]int{-1, 0, 1}
s := []bool{true, false}
m := map[string]int{"abc": 123, "xyz": 789}
fmt.Println (a[2], s[1], m["abc"])    // 读取
a[2], s[1], m["abc"] = 999, true, 567 // 修改
fmt.Println (a[2], s[1], m["abc"])    // 读取

	n, present := m["hello"]
	fmt.Println(n, present, m["hello"]) // 0 false 0
	n, present = m["abc"]
	fmt.Println(n, present, m["abc"]) // 567 true 567
	m = nil
	fmt.Println(m["abc"]) // 0

	// 下面这两行编译不通过。
	/*
	_ = a[3]  // 下标越界
	_ = s[-1] // 下标越界
	*/

	// 下面这几行每行都会造成一个恐慌。
	_ = a[n]         // panic: 下标越界
	_ = s[n]         // panic: 下标越界
	m["hello"] = 555 // panic: m为一个零值映射
}
重温一下切片的内部结构
为了更好的理解和解释切片类型和切片值，我们最好对切片的内部结构有一个基本的印象。 在上一篇文章值部中，我们已经了解到官方标准编译器对切片类型的内部定义大致如下：
type _slice struct {
elements unsafe.Pointer // 引用着底层存储在间接部分上的元素
len      int            // 长度
cap      int            // 容量
}
虽然其它编译器中切片类型的内部结构可能并不完全和官方标准编译器一致，但应该大体上是相似的。 下面的解释均基于官方标准编译器对切片类型的内部定义。

上面展示的切片的内部定义为切片的直接部分的定义。直接部分的len字段表示一个切片当前存储了多少个元素；直接部分的cap表示一个切片的容量。 下面这张图描绘了一个切片值的内存布局。

切片值内存布局
尽管一个切片值的底层元素部分可能位于一个比较大的内存片段上，但是此切片值只能感知到此内存片段上的一个子片段。 比如，上图中的切片值只能感知到灰色的子片段。

在上图中，从下标len（包含）到下标cap（不包含）对应的元素并不属于图中所示的切片值。 它们只是此切片之中的一些冗余元素槽位，但是它们可能是其它切片（或者数组）值中的有效元素。

下一节将要介绍如何通过调用内置append函数来向一个基础切片添加元素而得到一个新的切片。 这个新的结果切片可能和这个基础切片共享起始元素，也可能不共享，具体取决于基础切片的容量（以及长度）和添加的元素数量。

当一个切片被用做一个append函数调用中的基础切片，
如果添加的元素数量大于此（基础）切片的冗余元素槽位的数量，则一个新的底层内存片段将被开辟出来并用来存放结果切片的元素。 这时，基础切片和结果切片不共享任何底层元素。
否则，不会有底层内存片段被开辟出来。这时，基础切片中的所有元素也同时属于结果切片。两个切片的元素都存放于同一个内存片段上。
下下一节将展示一张包含了上述两种情况的图片。

一些其它切片操作也可能会造成两个切片共享底层内存片段的情况。这些操作将在后续章节逐一介绍。

注意，一般我们不能单独修改一个切片值的某个内部字段，除非使用反射或者非类型安全指针。 换句话说，一般我们只能通过将其它切片赋值给一个切片来同时修改这个切片的三个字段。

容器赋值
当一个映射赋值语句执行完毕之后，目标映射值和源映射值将共享底层的元素。 向其中一个映射中添加（或从中删除）元素将体现在另一个映射中。

和映射一样，当一个切片赋值给另一个切片后，它们将共享底层的元素。它们的长度和容量也相等。 但是和映射不同，如果以后其中一个切片改变了长度或者容量，此变化不会体现到另一个切片中。

当一个数组被赋值给另一个数组，所有的元素都将被从源数组复制到目标数组。赋值完成之后，这两个数组不共享任何元素。

一个例子：
package main

import "fmt"

func main() {
m0 := map[int]int{0:7, 1:8, 2:9}
m1 := m0
m1[0] = 2
fmt.Println(m0, m1) // map[0:2 1:8 2:9] map[0:2 1:8 2:9]

	s0 := []int{7, 8, 9}
	s1 := s0
	s1[0] = 2
	fmt.Println(s0, s1) // [2 8 9] [2 8 9]

	a0 := [...]int{7, 8, 9}
	a1 := a0
	a1[0] = 2
	fmt.Println(a0, a1) // [7 8 9] [2 8 9]
}
添加和删除容器元素
向一个映射中添加一个条目的语法和修改一个映射元素的语法是一样的。 比如，对于一个非零映射值m，如果当前m中尚未存储条目(k, e)，则下面的语法形式将把此条目存入m；否则，下面的语法形式将把键值k对应的元素值更新为e。
m[k] = e
内置函数delete用来从一个映射中删除一个条目。比如，下面的delete调用将把键值k对应的条目从映射m中删除。 如果映射m中未存储键值为k的条目，则此调用为一个空操作，它不会产生一个恐慌，即使m是一个nil零值映射。
delete(m, k)
下面的例子展示了如何向一个映射添加和从一个映射删除条目。
package main

import "fmt"

func main() {
m := map[string]int{"Go": 2007}
m["C"] = 1972     // 添加
m["Java"] = 1995  // 添加
fmt.Println(m)    // map[C:1972 Go:2007 Java:1995]
m["Go"] = 2009    // 修改
delete(m, "Java") // 删除
fmt.Println(m)    // map[C:1972 Go:2009]
}
注意，在Go 1.12之前，映射打印结果中的条目顺序并不固定，两次打印结果可能并不相同。

一个数组中的元素个数总是恒定的，我们无法向其中添加元素，也无法从其中删除元素。但是可寻址的数组值中的元素是可以被修改的。

我们可以通过调用内置append函数，以一个切片为基础，来添加不定数量的元素并返回一个新的切片。 此新的结果切片包含着基础切片中所有的元素和所有被添加的元素。 注意，基础切片并未被此append函数调用所修改。 当然，如果我们愿意（事实上在实践中常常如此），我们可以将结果切片赋值给基础切片以修改基础切片。

Go中并未提供一个内置方式来从一个切片中删除一个元素。 我们必须使用append函数和后面将要介绍的子切片语法一起来实现元素删除操作。 切片元素的删除和插入将在后面的更多切片操作一节中介绍。 本节仅展示如何使用append内置函数。

下面是一个如何使用append内置函数的例子。
package main

import "fmt"

func main() {
s0 := []int{2, 3, 5}
fmt.Println(s0, cap(s0)) // [2 3 5] 3
s1 := append(s0, 7)      // 添加一个元素
fmt.Println(s1, cap(s1)) // [2 3 5 7] 6
s2 := append(s1, 11, 13) // 添加两个元素
fmt.Println(s2, cap(s2)) // [2 3 5 7 11 13] 6
s3 := append(s0)         // <=> s3 := s0
fmt.Println(s3, cap(s3)) // [2 3 5] 3
s4 := append(s0, s0...)  // 以s0为基础添加s0中所有的元素
fmt.Println(s4, cap(s4)) // [2 3 5 2 3 5] 6

	s0[0], s1[0] = 99, 789
	fmt.Println(s2[0], s3[0], s4[0]) // 789 99 2
}
注意，内置append函数是一个变长参数函数（下下篇文章中介绍）。 它有两个参数，其中第二个参数（形参）为一个变长参数。

变长参数函数将在下下篇文章中解释。目前，我们只需知道变长参数函数调用中的实参有两种传递方式。 在上面的例子中，第8行、第10行和第12行使用了同一种方式，第14行使用了另外一种方式。 在第一种方式中，零个或多个实参元素值可以传递给append函数的第二个形参。 在第二种方式中，一个（和第一个实参同元素类型的）实参切片传递给了第二个形参，此切片实参必须跟随三个点...。 关于变长参数函数调用，详见下下篇文章。

在上例中，第14行等价于
s4 := append(s0, s0[0], s0[1], s0[2])
第8行等价于
s1 := append(s0, []int{7}...)
第10行等价于
s2 := append(s1, []int{11, 13}...)
对于三个点方式，append函数并不要求第二个实参的类型和第一个实参一致，但是它们的元素类型必须一致。 换句话说，它们的底层类型必须一致。

在上面的程序中，
第8行的append函数调用将为结果切片s1开辟一段新的内存。 原因是切片s0中没有足够的冗余元素槽位来容纳新添加的元素。 第14行的append函数调用也是同样的情况。
第10行的append函数调用不会为结果切片s2开辟新的内存片段。 原因是切片s1中的冗余元素槽位足够容纳新添加的元素。
所以，上面的程序中在退出之前，切片s1和s2共享一些元素，切片s0和s3共享所有的元素。 下面这张图描绘了在上面的程序结束之前各个切片的状态。

各个切片状态
请注意，当一个append函数调用需要为结果切片开辟内存时，结果切片的容量取决于具体编译器实现。 在这种情况下，对于官方标准编译器，如果基础切片的容量较小，则结果切片的容量至少为基础切片的两倍。 这样做的目的是使结果切片有足够多的冗余元素槽位，以防止此结果切片被用做后续其它append函数调用的基础切片时再次开辟内存。

上面提到了，在实际编程中，我们常常将append函数调用的结果赋值给基础切片。 比如：
package main

import "fmt"

func main() {
var s = append([]string(nil), "array", "slice")
fmt.Println(s)      // [array slice]
fmt.Println(cap(s)) // 2
s = append(s, "map")
fmt.Println(s)      // [array slice map]
fmt.Println(cap(s)) // 4
s = append(s, "channel")
fmt.Println(s)      // [array slice map channel]
fmt.Println(cap(s)) // 4
}
截至目前（Go 1.20），append函数调用的第一个实参不能为类型不确定的nil。

使用内置make函数来创建切片和映射
除了使用组合字面量来创建映射和切片，我们还可以使用内置make函数来创建映射和切片。 数组不能使用内置make函数来创建。

顺便说一句，内置make函数也可以用来创建以后将要介绍的通道值。

假设M是一个映射类型并且n是一个整数，我们可以用下面的两种函数调用来各自生成一个类型为M的映射值。
make(M, n)
make(M)
第一个函数调用形式创建了一个可以容纳至少n个条目而无需再次开辟内存的空映射值。 第二个函数调用形式创建了一个可以容纳一个小数目的条目而无需再次开辟内存的空映射值。此小数目的值取决于具体编译器实现。

注意：第二个参数n可以为负或者零，这时对应的调用将被视为上述第二种调用形式。

假设S是一个切片类型，length和capacity是两个非负整数，并且length小于等于capacity，我们可以用下面的两种函数调用来各自生成一个类型为S的切片值。length和capacity的类型必须均为整数类型（两者可以不一致）。
make(S, length, capacity)
make(S, length) // <=> make(S, length, length)
第一个函数调用创建了一个长度为length并且容量为capacity的切片。 第二个函数调用创建了一个长度为length并且容量也为length的切片。

使用make函数创建的切片中的所有元素值均被初始化为（结果切片的元素类型的）零值。

下面是一个展示了如何使用make函数来创建映射和切片的例子：
package main

import "fmt"

func main() {
// 创建映射。
fmt.Println(make(map[string]int)) // map[]
m := make(map[string]int, 3)
fmt.Println(m, len(m)) // map[] 0
m["C"] = 1972
m["Go"] = 2009
fmt.Println(m, len(m)) // map[C:1972 Go:2009] 2

	// 创建切片。
	s := make([]int, 3, 5)
	fmt.Println(s, len(s), cap(s)) // [0 0 0] 3 5
	s = make([]int, 2)
	fmt.Println(s, len(s), cap(s)) // [0 0] 2 2
}
使用内置new函数来创建容器值
在前面的指针一文中，我们已经了解到内置new函数可以用来为一个任何类型的值开辟内存并返回一个存储有此值的地址的指针。 用new函数开辟出来的值均为零值。因为这个原因，new函数对于创建映射和切片值来说没有任何价值。

使用new函数来用来创建数组值并非是完全没有意义的，但是在实践中很少这么做，因为使用组合字面量来创建数组值更为方便。

一个使用new函数创建容器值的例子：
package main

import "fmt"

func main() {
m := *new(map[string]int)   // <=> var m map[string]int
fmt.Println(m == nil)       // true
s := *new([]int)            // <=> var s []int
fmt.Println(s == nil)       // true
a := *new([5]bool)          // <=> var a [5]bool
fmt.Println(a == [5]bool{}) // true
}
容器元素的可寻址性
一些关于容器元素的可寻址性的事实：
如果一个数组是可寻址的，则它的元素也是可寻址的；反之亦然，即如果一个数组是不可寻址的，则它的元素也是不可寻址的。 原因很简单，因为一个数组只含有一个（直接）值部，并且它的所有元素和此直接值部均承载在同一个内存块上。
一个切片值的任何元素都是可寻址的，即使此切片本身是不可寻址的。 这是因为一个切片的底层元素总是存储在一个被开辟出来的内存片段（间接值部）上。
任何映射元素都是不可寻址的。原因详见此条问答。
一个例子：
package main

import "fmt"

func main() {
a := [5]int{2, 3, 5, 7}
s := make([]bool, 2)
pa2, ps1 := &a[2], &s[1]
fmt.Println(*pa2, *ps1) // 5 false
a[2], s[1] = 99, true
fmt.Println(*pa2, *ps1) // 99 true
ps0 := &[]string{"Go", "C"}[0]
fmt.Println(*ps0) // Go

	m := map[int]bool{1: true}
	_ = m
	// 下面这几行编译不通过。
	/*
	_ = &[3]int{2, 3, 5}[0]
	_ = &map[int]bool{1: true}[1]
	_ = &m[1]
	*/
}
一般来说，一个不可寻址的值的直接部分是不可修改的。但是映射元素是个例外。 映射元素虽然不可寻址，但是每个映射元素可以被整个修改（但不能被部分修改）。 对于大多数做为映射元素类型的类型，在修改它们的值的时候，一般体现不出来整个修改和部分修改的差异。 但是如果一个映射的元素类型为数组或者结构体类型，这个差异是很明显的。

在上一篇文章值部中，我们了解到每个数组或者结构体值都是仅含有一个直接部分。所以
如果一个映射类型的元素类型为一个结构体类型，则我们无法修改此映射类型的值中的每个结构体元素的单个字段。 我们必须整体地同时修改所有结构体字段。
如果一个映射类型的元素类型为一个数组类型，则我们无法修改此映射类型的值中的每个数组元素的单个元素。 我们必须整体地同时修改所有数组元素。
一个例子：
package main

import "fmt"

func main() {
type T struct{age int}
mt := map[string]T{}
mt["John"] = T{age: 29} // 整体修改是允许的
ma := map[int][5]int{}
ma[1] = [5]int{1: 789} // 整体修改是允许的

	// 这两个赋值编译不通过，因为部分修改一个映射
	// 元素是非法的。这看上去确实有些反直觉。
	/*
	ma[1][1] = 123      // error
	mt["John"].age = 30 // error
	*/

	// 读取映射元素的元素或者字段是没问题的。
	fmt.Println(ma[1][1])       // 789
	fmt.Println(mt["John"].age) // 29
}
为了让上例中的两行编译不通过的两行赋值语句编译通过，欲修改的映射元素必须先存放在一个临时变量中，然后修改这个临时变量，最后再用这个临时变量整体覆盖欲修改的映射元素。比如：
package main

import "fmt"

func main() {
type T struct{age int}
mt := map[string]T{}
mt["John"] = T{age: 29}
ma := map[int][5]int{}
ma[1] = [5]int{1: 789}

	t := mt["John"] // 临时变量
	t.age = 30
	mt["John"] = t // 整体修改

	a := ma[1] // 临时变量
	a[1] = 123
	ma[1] = a // 整体修改

	fmt.Println(ma[1][1], mt["John"].age) // 123 30
}
注意：刚提到的这个限制可能会在以后被移除。

从数组或者切片派生切片（取子切片）
我们可以从一个基础切片或者一个可寻址的基础数组派生出另一个切片。此派生操作也常称为一个取子切片操作。 派生出来的切片的元素和基础切片（或者数组）的元素位于同一个内存片段上。或者说，派生出来的切片和基础切片（或者数组）将共享一些元素。

Go中有两种取子切片的语法形式（假设baseContainer是一个切片或者数组）：
baseContainer[low : high]       // 双下标形式
baseContainer[low : high : max] // 三下标形式
上面所示的双下标形式等价于下面的三下标形式：
baseContainer[low : high : cap(baseContainer)]
所以双下标形式是三下标形式的特例。在实践中，双下标形式使用得相对更为广泛。

（注意：三下标形式是从Go 1.2开始支持的。）

上面所示的取子切片表达式的语法形式中的下标必须满足下列关系，否则代码要么编译不通过，要么在运行时刻将造成恐慌。
// 双下标形式
0 <= low <= high <= cap(baseContainer)

// 三下标形式
0 <= low <= high <= max <= cap(baseContainer)
不满足上述关系的取子切片表达式要么编译不通过，要么在运行时刻将导致一个恐慌。

注意：
只要上述关系均满足，下标low和high都可以大于len(baseContainer)。但是它们一定不能大于cap(baseContainer)。
如果baseContainer是一个零值nil切片，只要上面所示的子切片表达式中下标的值均为0，则这两个子切片表达式不会造成恐慌。 在这种情况下，结果切片也是一个nil切片。
子切片表达式的结果切片的长度为high - low、容量为max - low。 派生出来的结果切片的长度可能大于基础切片的长度，但结果切片的容量绝不可能大于基础切片的容量。

在实践中，我们常常在子切片表达式中省略若干下标，以使代码看上去更加简洁。省略规则如下：
如果下标low为零，则它可被省略。此条规则同时适用于双下标形式和三下标形式。
如果下标high等于len(baseContainer)，则它可被省略。此条规则同时只适用于双下标形式。
三下标形式中的下标max在任何情况下都不可被省略。
比如，下面的子切片表达式都是相互等价的：
baseContainer[0 : len(baseContainer)]
baseContainer[: len(baseContainer)]
baseContainer[0 :]
baseContainer[:]
baseContainer[0 : len(baseContainer) : cap(baseContainer)]
baseContainer[: len(baseContainer) : cap(baseContainer)]
一个使用了子切片语法的例子：
package main

import "fmt"

func main() {
a := [...]int{0, 1, 2, 3, 4, 5, 6}
s0 := a[:]     // <=> s0 := a[0:7:7]
s1 := s0[:]    // <=> s1 := s0
s2 := s1[1:3]  // <=> s2 := a[1:3]
s3 := s1[3:]   // <=> s3 := s1[3:7]
s4 := s0[3:5]  // <=> s4 := s0[3:5:7]
s5 := s4[:2:2] // <=> s5 := s0[3:5:5]
s6 := append(s4, 77)
s7 := append(s5, 88)
s8 := append(s7, 66)
s3[1] = 99
fmt.Println(len(s2), cap(s2), s2) // 2 6 [1 2]
fmt.Println(len(s3), cap(s3), s3) // 4 4 [3 99 77 6]
fmt.Println(len(s4), cap(s4), s4) // 2 4 [3 99]
fmt.Println(len(s5), cap(s5), s5) // 2 2 [3 99]
fmt.Println(len(s6), cap(s6), s6) // 3 4 [3 99 77]
fmt.Println(len(s7), cap(s7), s7) // 3 4 [3 4 88]
fmt.Println(len(s8), cap(s8), s8) // 4 4 [3 4 88 66]
}
下面这张图描绘了上面的程序在退出之前各个数组和切片的状态。
数字和切片状态
从这张图片可以看出，切片s7和s8共享存储它们的元素的底层内存片段，其它切片和数组a共享同一个存储元素的内存片段。

请注意，子切片操作有可能会造成暂时性的内存泄露。 比如，下面在这个函数中开辟的内存块中的前50个元素槽位在它的调用返回之后将不再可见。 这50个元素槽位所占内存浪费了，这属于暂时性的内存泄露。 当这个函数中开辟的内存块今后不再被任何切片所引用，此内存块将被回收，这时内存才不再继续泄漏。
func f() []int {
s := make([]int, 10, 100)
return s[50:60]
}
请注意，在上面这个函数中，子切片表达式中的起始下标（50）比s的长度（10）要大，这是允许的。

切片转化为数组指针
从Go 1.17开始，一个切片可以被转化为一个相同元素类型的数组的指针类型。 但是如果数组的长度大于被转化切片的长度，则将导致恐慌产生。 转换结果和被转化切片将共享底层元素。 一个例子：
package main

type S []int
type A [2]int
type P *A

func main() {
var x []int
var y = make([]int, 0)
var x0 = (*[0]int)(x) // okay, x0 == nil
var y0 = (*[0]int)(y) // okay, y0 != nil
_, _ = x0, y0

	var z = make([]int, 3, 5)
	var _ = (*[3]int)(z) // okay
	var _ = (*[2]int)(z) // okay
	var _ = (*A)(z)      // okay
	var _ = P(z)         // okay

	var w = S(z)
	var _ = (*[3]int)(w) // okay
	var _ = (*[2]int)(w) // okay
	var _ = (*A)(w)      // okay
	var _ = P(w)         // okay

	var _ = (*[4]int)(z) // 会产生恐慌
}
切片转化为数组
从Go 1.20开始，一个切片可以被转化为一个相同元素类型的数组。 但是如果数组的长度大于被转化切片的长度，则将导致恐慌产生。 转换过程中将复制所需的元素，因此结果数组和被转化切片不共享底层元素。 一个例子：
package main

import "fmt"

func main() {
var s = []int{0, 1, 2, 3}
var a = [3]int(s[1:])
s[2] = 9
fmt.Println(s) // [0 1 9 3]
fmt.Println(a) // [1 2 3]

	_ = [3]int(s[:2]) // panic
}
使用内置copy函数来复制切片元素
我们可以使用内置copy函数来将一个切片中的元素复制到另一个切片。 这两个切片的类型可以不同，但是它们的元素类型必须相同。 换句话说，这两个切片的类型的底层类型必须相同。 copy函数的第一个参数为目标切片，第二个参数为源切片。 传递给一个copy函数调用的两个实参可以共享一些底层元素。 copy函数返回复制了多少个元素，此值（int类型）为这两个切片的长度的较小值。

结合上一节介绍的子切片语法，我们可以使用copy函数来在两个数组之间或者一个数组与一个切片之间复制元素。

一个例子：
package main

import "fmt"

func main() {
type Ta []int
type Tb []int
dest := Ta{1, 2, 3}
src := Tb{5, 6, 7, 8, 9}
n := copy(dest, src)
fmt.Println(n, dest) // 3 [5 6 7]
n = copy(dest[1:], dest)
fmt.Println(n, dest) // 2 [5 5 6]

	a := [4]int{} // 一个数组
	n = copy(a[:], src)
	fmt.Println(n, a) // 4 [5 6 7 8]
	n = copy(a[:], a[2:])
	fmt.Println(n, a) // 2 [7 8 7 8]
}
注意，做为一个特例，copy函数可以用来将一个字符串中的字节复制到一个字节切片。

截至目前（Go 1.20），copy函数调用的两个实参均不能为类型不确定的nil。

遍历容器元素
在Go中，我们可以使用下面的语法形式来遍历一个容器中的键值和元素：
for key, element = range aContainer {
// 使用key和element ...
}
在此语法形式中，for和range为两个关键字，key和element称为循环变量。 如果aContainer是一个切片或者数组（或者数组指针，见后），则key的类型必须为内置类型int。

上面所示的for-range语法形式中的等号=也可以是一个变量短声明符号:=。 当短声明符号被使用的时候，key和element总是两个新声明的变量，这时如果aContainer是一个切片或者数组（或者数组指针），则key的类型被推断为内置类型int。

和传统的for循环流程控制一样，每个for-range循环流程控制形成了两个代码块，其中一个是隐式的，另一个是显式的（花括号之间的部分）。 此显式的代码块内嵌在隐式的代码块之中。

和for循环流程控制一样，break和continue也可以使用在一个for-range循环流程控制中的显式代码块中。

一个例子：
package main

import "fmt"

func main() {
m := map[string]int{"C": 1972, "C++": 1983, "Go": 2009}
for lang, year := range m {
fmt.Printf("%v: %v \n", lang, year)
}

	a := [...]int{2, 3, 5, 7, 11}
	for i, prime := range a {
		fmt.Printf("%v: %v \n", i, prime)
	}

	s := []string{"go", "defer", "goto", "var"}
	for i, keyword := range s {
		fmt.Printf("%v: %v \n", i, keyword)
	}
}
for-range循环代码块有一些变种形式：
// 忽略键值循环变量。
for _, element = range aContainer {
// ...
}

// 忽略元素循环变量。
for key, _ = range aContainer {
element = aContainer[key]
// ...
}

// 舍弃元素循环变量。此形式和上一个变种等价。
for key = range aContainer {
element = aContainer[key]
// ...
}

// 键值和元素循环变量均被忽略。
for _, _ = range aContainer {
// 这个变种形式没有太大实用价值。
}

// 键值和元素循环变量均被舍弃。此形式和上一个变种等价。
for range aContainer {
// 这个变种形式没有太大实用价值。
}
遍历一个nil映射或者nil切片是允许的。这样的遍历可以看作是一个空操作。

一些关于遍历映射条目的细节：
映射中的条目的遍历顺序是不确定的（可以认为是随机的）。或者说，同一个映射中的条目的两次遍历中，条目的顺序很可能是不一致的，即使在这两次遍历之间，此映射并未发生任何改变。
如果在一个映射中的条目的遍历过程中，一个还没有被遍历到的条目被删除了，则此条目保证不会被遍历出来。
如果在一个映射中的条目的遍历过程中，一个新的条目被添加入此映射，则此条目并不保证将在此遍历过程中被遍历出来。
如果可以确保没有其它协程操纵一个映射m，则下面的代码保证将清空m中所有条目。
for key := range m {
delete(m, key)
}
当然，数组和切片元素也可以用传统的for循环来遍历。
for i := 0; i < len(anArrayOrSlice); i++ {
element := anArrayOrSlice[i]
// ...
}
对一个for-range循环代码块
for key, element = range aContainer {...}
有三个重要的事实存在：
被遍历的容器值是aContainer的一个副本。 注意，只有aContainer的直接部分被复制了。 此副本是一个匿名的值，所以它是不可被修改的。
如果aContainer是一个数组，那么在遍历过程中对此数组元素的修改不会体现到循环变量中。 原因是此数组的副本（被真正遍历的容器）和此数组不共享任何元素。
如果aContainer是一个切片（或者映射），那么在遍历过程中对此切片（或者映射）元素的修改将体现到循环变量中。 原因是此切片（或者映射）的副本和此切片（或者映射）共享元素（或条目）。
在遍历中的每个循环步，aContainer副本中的一个键值元素对将被赋值（复制）给循环变量。 所以对循环变量的直接部分的修改将不会体现在aContainer中的对应元素中。 （因为这个原因，并且for-range循环是遍历映射条目的唯一途径，所以最好不要使用大尺寸的映射键值和元素类型，以避免较大的复制负担。）
所有被遍历的键值对将被赋值给同一对循环变量实例。
下面这个例子验证了上述第一个和第二个事实。
package main

import "fmt"

func main() {
type Person struct {
name string
age  int
}
persons := [2]Person {{"Alice", 28}, {"Bob", 25}}
for i, p := range persons {
fmt.Println(i, p)
// 此修改将不会体现在这个遍历过程中，
// 因为被遍历的数组是persons的一个副本。
persons[1].name = "Jack"

		// 此修改不会反映到persons数组中，因为p
		// 是persons数组的副本中的一个元素的副本。
		p.age = 31
	}
	fmt.Println("persons:", &persons)
}
输出结果：
0 {Alice 28}
1 {Bob 25}
persons: &[{Alice 28} {Jack 25}]
如果我们将上例中的数组改为一个切片，则在循环中对此切片的修改将在循环过程中体现出来。 但是对循环变量的修改仍然不会体现在此切片中。
...

	// 改为一个切片。
	persons := []Person {{"Alice", 28}, {"Bob", 25}}
	for i, p := range persons {
		fmt.Println(i, p)
		// 这次，此修改将反映在此次遍历过程中。
		persons[1].name = "Jack"
		// 这个修改仍然不会体现在persons切片容器中。
		p.age = 31
	}
	fmt.Println("persons:", &persons)
}
输出结果变成了：
0 {Alice 28}
1 {Jack 25}
persons: &[{Alice 28} {Jack 25}]
下面这个例子验证了上述的第二个和第三个事实：
package main

import "fmt"

func main() {
langs := map[struct{ dynamic, strong bool }]map[string]int{
{true, false}:  {"JavaScript": 1995},
{false, true}:  {"Go": 2009},
{false, false}: {"C": 1972},
}
// 此映射的键值和元素类型均为指针类型。
// 这有些不寻常，只是为了讲解目的。
m0 := map[*struct{ dynamic, strong bool }]*map[string]int{}
for category, langInfo := range langs {
m0[&category] = &langInfo
// 下面这行修改对映射langs没有任何影响。
category.dynamic, category.strong = true, true
}
for category, langInfo := range langs {
fmt.Println(category, langInfo)
}

	m1 := map[struct{ dynamic, strong bool }]map[string]int{}
	for category, langInfo := range m0 {
		m1[*category] = *langInfo
	}
	// 映射m0和m1中均只有一个条目。
	fmt.Println(len(m0), len(m1)) // 1 1
	fmt.Println(m1) // map[{true true}:map[C:1972]]
}
上面已经提到了，映射条目的遍历顺序是随机的。所以下面前三行的输出顺序可能会略有不同：
{false true} map[Go:2009]
{false false} map[C:1972]
{true false} map[JavaScript:1995]
1 1
map[{true true}:map[Go:2009]]
复制一个切片或者映射的代价很小，但是复制一个大尺寸的数组的代价比较大。 所以，一般来说，range关键字后跟随一个大尺寸数组不是一个好主意。 如果我们要遍历一个大尺寸数组中的元素，我们以遍历从此数组派生出来的一个切片，或者遍历一个指向此数组的指针（详见下一节）。

对于一个数组或者切片，如果它的元素类型的尺寸较大，则一般来说，用第二个循环变量来存储每个循环步中被遍历的元素不是一个好主意。 对于这样的数组或者切片，我们最好忽略或者舍弃for-range代码块中的第二个循环变量，或者使用传统的for循环来遍历元素。 比如，在下面这个例子中，函数fa中的循环效率比函数fb中的循环低得多。
type Buffer struct {
start, end int
data       [1024]byte
}

func fa(buffers []Buffer) int {
numUnreads := 0
for _, buf := range buffers {
numUnreads += buf.end - buf.start
}
return numUnreads
}

func fb(buffers []Buffer) int {
numUnreads := 0
for i := range buffers {
numUnreads += buffers[i].end - buffers[i].start
}
return numUnreads
}
把数组指针当做数组来使用
对于某些情形，我们可以把数组指针当做数组来使用。

我们可以通过在range关键字后跟随一个数组的指针来遍历此数组中的元素。 对于大尺寸的数组，这种方法比较高效，因为复制一个指针比复制一个大尺寸数组的代价低得多。 下面的例子中的两个循环是等价的，它们的效率也基本相同。
package main

import "fmt"

func main() {
var a [100]int

	for i, n := range &a { // 复制一个指针的开销很小
		fmt.Println(i, n)
	}

	for i, n := range a[:] { // 复制一个切片的开销很小
		fmt.Println(i, n)
	}
}
如果一个for-range循环中的第二个循环变量既没有被忽略，也没有被舍弃，并且range关键字后跟随一个nil数组指针，则此循环将造成一个恐慌。 在下面这个例子中，前两个循环都将打印出5个下标，但最后一个循环将导致一个恐慌。
package main

import "fmt"

func main() {
var p *[5]int // nil

	for i, _ := range p { // okay
		fmt.Println(i)
	}

	for i := range p { // okay
		fmt.Println(i)
	}

	for i, n := range p { // panic
		fmt.Println(i, n)
	}
}
我们可以通过数组的指针来访问和修改此数组中的元素。如果此指针是一个nil指针，将导致一个恐慌。
package main

import "fmt"

func main() {
a := [5]int{2, 3, 5, 7, 11}
p := &a
p[0], p[1] = 17, 19
fmt.Println(a) // [17 19 5 7 11]
p = nil
_ = p[0] // panic
}
我们可以从一个数组的指针派生出一个切片。从一个nil数组指针派生切片将导致一个恐慌。
package main

import "fmt"

func main() {
pa := &[5]int{2, 3, 5, 7, 11}
s := pa[1:3]
fmt.Println(s) // [3 5]
pa = nil
s = pa[0:0] // panic
// 如果下一行能被执行到，则它也会产生恐慌。
_ = (*[0]byte)(nil)[:]
}
内置len和cap函数调用接受数组指针做为实参。 nil数组指针实参不会导致恐慌。
var pa *[5]int // == nil
fmt.Println(len(pa), cap(pa)) // 5 5
memclr优化
假设t0是一个类型T的零值字面量，并且a是一个元素类型为T的数组或者切片，则官方标准编译器将把下面的单循环变量for-range代码块优化为一个内部的memclr调用。 大多数情况下，此memclr调用比一个一个地重置元素要快。
for i := range a {
a[i] = t0
}
此优化在官方标准编译器1.5版本中被引入。

从官方Go工具链1.19开始，此优化也适用于a为一个数组指针的情形。

注意：Go 1.21将引入一个clear内置函数，用来清空一个映射中的所有条目或者重置一个切片中的所有元素。

内置函数len和cap的调用可能会在编译时刻被估值
如果传递给内置函数len或者cap的一个调用的实参是一个数组或者数组指针，则此调用将在编译时刻被估值。 此估值结果是一个类型为内置类型int的类型确定常量值。

一个例子：
package main

import "fmt"

var a [5]int
var p *[7]string

// N和M都是类型为int的类型确定值。
const N = len(a)
const M = cap(p)

func main() {
fmt.Println(N) // 5
fmt.Println(M) // 7
}
单独修改一个切片的长度或者容量
上面已经提到了，一般来说，一个切片的长度和容量不能被单独修改。一个切片只有通过赋值的方式被整体修改。 但是，事实上，我们可以通过反射的途径来单独修改一个切片的长度或者容量。 反射将在后面的一篇文章中详解。

一个例子：
package main

import (
"fmt"
"reflect"
)

func main() {
s := make([]int, 2, 6)
fmt.Println(len(s), cap(s)) // 2 6

	reflect.ValueOf(&s).Elem().SetLen(3)
	fmt.Println(len(s), cap(s)) // 3 6

	reflect.ValueOf(&s).Elem().SetCap(5)
	fmt.Println(len(s), cap(s)) // 3 5
}
传递给函数reflect.SetLen调用的第二个实参值必须不大于第一个实参切片值的容量。 传递给函数reflect.SetCap调用的第二个实参值必须不小于第一个实参切片值的长度并且须不大于第一个实参切片值的容量。 否则，在运行时刻将产生一个恐慌。

此反射方法的效率很低，远低于一个切片的赋值。

更多切片操作
Go不支持更多的内置切片操作，比如切片克隆、元素删除和插入。 我们必须用上面提到的各种内置操作来实现这些操作。

在下面当前大节中的例子中，假设s是被谈到的切片、T是它的元素类型、t0是类型T的零值字面量。

切片克隆
对于当前的Go版本（1.20），最简单的克隆一个切片的方法为：
sClone := append(s[:0:0], s...)
我们也可以使用下面这种实现。但是和上面这个实现相比，它有一个不完美之处：如果源切片s是一个空切片（但是非nil），则结果切片是一个nil切片。
sClone := append([]T(nil), s...)
上面这两种append实现都有一个缺点：它们开辟的内存块常常会比需要的略大一些从而可能造成一点小小的不必要的性能损失。 我们可以使用这两种方法来避免这个缺点：
// 两行make+copy实现：
sClone := make([]T, len(s))
copy(sClone, s)

// 或者下面的make+append实现。
// 对于目前的官方Go工具链v1.20来说，这种
// 实现比上面的make+copy实现略慢一点。
sClone := append(make([]T, 0, len(s)), s...)
上面这两种make方法都有一个缺点：如果s是一个nil切片，则使用此方法将得到一个非nil切片。 不过，在编程实践中，我们常常并不需要追求克隆的完美性。如果我们确实需要，则需要多写几行：
var sClone []T
if s != nil {
sClone = make([]T, len(s))
copy(sClone, s)
}
删除一段切片元素
前面已经提到了切片的元素在内存中是连续存储的，相邻元素之间是没有间隙的。所以，当切片的一个元素段被删除时，
如果剩余元素的次序必须保持原样，则被删除的元素段后面的每个元素都得前移。
如果剩余元素的次序不需要保持原样，则我们可以将尾部的一些元素移到被删除的元素的位置上。
在下面的例子中，假设from（包括）和to（不包括）是两个合法的下标，并且from不大于to。
// 第一种方法（保持剩余元素的次序）：
s = append(s[:from], s[to:]...)

// 第二种方法（保持剩余元素的次序）：
s = s[:from + copy(s[from:], s[to:])]

// 第三种方法（不保持剩余元素的次序）：
if n := to-from; len(s)-to < n {
copy(s[from:to], s[to:])
} else {
copy(s[from:to], s[len(s)-n:])
}
s = s[:len(s)-(to-from)]
如果切片的元素可能引用着其它值，则我们应该重置因为删除元素而多出来的元素槽位上的元素值，以避免暂时性的内存泄露：
// "len(s)+to-from"是删除操作之前切片s的长度。
temp := s[len(s):len(s)+to-from]
for i := range temp {
temp[i] = t0 // t0是类型T的零值字面量
}
前面已经提到了，上面这个for-range循环将被官方标准编译器优化为一个memclr调用。

删除一个元素
删除一个元素是删除一个元素段的特例。在实现上可以简化一些。

在下面的例子中，假设i将被删除的元素的下标，并且它是一个合法的下标。
// 第一种方法（保持剩余元素的次序）：
s = append(s[:i], s[i+1:]...)

// 第二种方法（保持剩余元素的次序）：
s = s[:i + copy(s[i:], s[i+1:])]

// 上面两种方法都需要复制len(s)-i-1个元素。

// 第三种方法（不保持剩余元素的次序）：
s[i] = s[len(s)-1]
s = s[:len(s)-1]
如果切片的元素可能引用着其它值，则我们应该重置刚多出来的元素槽位上的元素值，以避免暂时性的内存泄露：
s[len(s):len(s)+1][0] = t0
// 或者
s[:len(s)+1][len(s)] = t0
条件性地删除切片元素
有时，我们需要删除满足某些条件的切片元素。
// 假设T是一个小尺寸类型。
func DeleteElements(s []T, keep func(T) bool, clear bool) []T {
// result := make([]T, 0, len(s))
result := s[:0] // 无须开辟内存
for _, v := range s {
if keep(v) {
result = append(result, v)
}
}
if clear { // 避免暂时性的内存泄露。
temp := s[len(result):]
for i := range temp {
temp[i] = t0 // t0是类型T的零值
}
}
return result
}
注意：如果T是一个大尺寸类型，请慎用T做为参数类型和使用双循环变量for-range代码块遍历元素类型为T的切片。

将一个切片中的所有元素插入到另一个切片中
假设插入位置i是一个合法的下标并且切片elements中的元素将被插入到另一个切片s中。
// 第一种方法:单行实现。
s = append(s[:i], append(elements, s[i:]...)...)

// 上面这种单行实现把s[i:]中的元素复制了两次，并且它可能
// 最多导致两次内存开辟（最少一次）。
// 下面这种繁琐的实现只把s[i:]中的元素复制了一次，并且
// 它最多只会导致一次内存开辟（最少零次）。
// 但是，在当前的官方标准编译器实现中（1.20版本），此
// 繁琐实现中的make调用将会把部分刚开辟出来的元素清零。
// 这其实是没有必要的。所以此繁琐实现并非总是比上面的
// 单行实现效率更高。事实上，它仅在处理小切片时更高效。

if cap(s) >= len(s) + len(elements) {
s = s[:len(s)+len(elements)]
copy(s[i+len(elements):], s[i:])
copy(s[i:], elements)
} else {
x := make([]T, 0, len(elements)+len(s))
x = append(x, s[:i]...)
x = append(x, elements...)
x = append(x, s[i:]...)
s = x
}

// Push（插入到结尾）。
s = append(s, elements...)

// Unshift（插入到开头）。
s = append(elements, s...)
插入若干独立的元素
插入若干独立的元素和插入一个切片中的所有元素类似。 我们可以使用切片组合字面量构建一个临时切片，然后使用上面的方法插入这些元素。

特殊的插入和删除：前推/后推，前弹出/后弹出
假设被推入和弹出的元素为e并且切片s拥有至少一个元素。
// 前弹出（pop front，又称shift）
s, e = s[1:], s[0]
// 后弹出（pop back）
s, e = s[:len(s)-1], s[len(s)-1]
// 前推（push front）
s = append([]T{e}, s...)
// 后推（push back）
s = append(s, e)
请注意：使用append函数来插入元素常常是比较低效的，因为插入点后的所有元素都要向后挪，并且当空余容量不足时还需要开辟一个更大的内存空间来容纳插入完成后所有的元素。 对于元素个数不多的切片来说，这些可能并不是严重的问题；但是在元素个数很多的切片上进行如上的插入操作常常是耗时的。所以如果元素个数很多，最好使用链表来实现元素插入操作。

关于上面各种切片操控的例子
在实践中，需求是各种各样的。对于某些特定的情形，上面的例子中的代码实现可能并非是最优化的，甚至是不满足要求的。 所以，请在实践中根据具体情况来实现代码。或许，这就是Go没有支持更多的内置切片操作的原因。

用映射来模拟集合（set）
Go不支持内置集合（set）类型。但是，集合类型可以用轻松使用映射类型来模拟。 在实践中，我们常常使用映射类型map[K]struct{}来模拟一个元素类型为K的集合类型。 类型struct{}的尺寸为零，所以此映射类型的值中的元素不消耗内存。

## 字符串
字符串类型的内部结构定义
对于标准编译器，字符串类型的内部结构声明如下：
type _string struct {
elements *byte // 引用着底层的字节
len      int   // 字符串中的字节数
}
从这个声明来看，我们可以将一个字符串的内部定义看作为一个字节序列。 事实上，我们确实可以把一个字符串看作是一个元素类型为byte的（且元素不可修改的）切片。

注意，前面的文章已经提到过多次，byte是内置类型uint8的一个别名。

关于字符串的一些简单事实
从前面的若干文章，我们已经了解到下列关于字符串的一些事实：
字符串值（和布尔以及各种数值类型的值）可以被用做常量。
Go支持两种风格的字符串字面量表示形式：双引号风格（解释型字面表示）和反引号风格（直白字面表示）。具体介绍请阅读前文。
字符串类型的零值为空字符串。一个空字符串在字面上可以用""或者``来表示。
我们可以用运算符+和+=来衔接字符串。
字符串类型都是可比较类型。同一个字符串类型的值可以用==和!=比较运算符来比较。 并且和整数/浮点数一样，同一个字符串类型的值也可以用>、<、>=和<=比较运算符来比较。 当比较两个字符串值的时候，它们的底层字节将逐一进行比较。如果一个字符串是另一个字符串的前缀，并且另一个字符串较长，则另一个字符串为两者中的较大者。
一个例子：
package main

import "fmt"

func main() {
const World = "world"
var hello = "hello"

	// 衔接字符串。
	var helloWorld = hello + " " + World
	helloWorld += "!"
	fmt.Println(helloWorld) // hello world!

	// 比较字符串。
	fmt.Println(hello == "hello")   // true
	fmt.Println(hello > helloWorld) // false
}
更多关于字符串类型和值的事实：
和Java语言一样，字符串值的内容（即底层字节）是不可更改的。 字符串值的长度也是不可独立被更改的。 一个可寻址的字符串只能通过将另一个字符串赋值给它来整体修改它。
字符串类型没有内置的方法。我们可以
使用strings标准库提供的函数来进行各种字符串操作。
调用内置函数len来获取一个字符串值的长度（此字符串中存储的字节数）。
使用容器元素索引语法aString[i]来获取aString中的第i个字节。 表达式aString[i]是不可寻址的。换句话说，aString[i]不可被修改。
使用子切片语法aString[start:end]来获取aString的一个子字符串。 这里，start和end均为aString中存储的字节的下标。
对于标准编译器来说，一个字符串的赋值完成之后，此赋值中的目标值和源值将共享底层字节。 一个子切片表达式aString[start:end]的估值结果也将和基础字符串aString共享一部分底层字节。
一个例子：
package main

import (
"fmt"
"strings"
)

func main() {
var helloWorld = "hello world!"

	var hello = helloWorld[:5] // 取子字符串
	// 104是英文字符h的ASCII（和Unicode）码。
	fmt.Println(hello[0])         // 104
	fmt.Printf("%T \n", hello[0]) // uint8

	// hello[0]是不可寻址和不可修改的，所以下面
	// 两行编译不通过。
	/*
	hello[0] = 'H'         // error
	fmt.Println(&hello[0]) // error
	*/

	// 下一条语句将打印出：5 12 true
	fmt.Println(len(hello), len(helloWorld),
			strings.HasPrefix(helloWorld, hello))
}
注意：如果在aString[i]和aString[start:end]中，aString和各个下标均为常量，则编译器将在编译时刻验证这些下标的合法性，但是这样的元素访问和子切片表达式的估值结果总是非常量（这是Go语言设计之初的一个失误，但因为兼容性的原因导致难以弥补）。比如下面这个程序将打引出4 0。
package main

import "fmt"

const s = "Go101.org" // len(s) == 9

// len(s)是一个常量表达式，但len(s[:])却不是。
var a byte = 1 << len(s) / 128
var b byte = 1 << len(s[:]) / 128

func main() {
fmt.Println(a, b) // 4 0
}
a和b两个变量估值不同的具体原因请阅读移位操作类型推断规则和哪些函数调用在编译时刻被估值。

字符串编码和Unicode码点
Unicode标准为全球各种人类语言中的每个字符制定了一个独一无二的值。 但Unicode标准中的基本单位不是字符，而是码点（code point）。大多数的码点实际上就对应着一个字符。 但也有少数一些字符是由多个码点组成的。

码点值在Go中用rune值来表示。 内置rune类型为内置int32类型的一个别名。

在具体应用中，码点值的编码方式有很多，比如UTF-8编码和UTF-16编码等。 目前最流行编码方式为UTF-8编码。在Go中，所有的字符串常量都被视为是UTF-8编码的。 在编译时刻，非法UTF-8编码的字符串常量将导致编译失败。 在运行时刻，Go运行时无法阻止一个字符串是非法UTF-8编码的。

在UTF-8编码中，一个码点值可能由1到4个字节组成。 比如，每个英语码点值（均对应一个英语字符）均由一个字节组成，而每个中文码点值（均对应一个中文字符）均由三个字节组成。

字符串相关的类型转换
在常量和变量一文中，我们已经了解到整数可以被显式转换为字符串类型（但是反之不行）。

这里介绍两种新的字符串相关的类型转换规则：
一个字符串值可以被显式转换为一个字节切片（byte slice），反之亦然。 一个字节切片类型是一个元素类型的底层类型为内置类型byte的切片类型。
一个字符串值可以被显式转换为一个码点切片（rune slice），反之亦然。 一个码点切片类型是一个元素类型的底层类型为内置类型rune的切片类型。
在一个从码点切片到字符串的转换中，码点切片中的每个码点值将被UTF-8编码为一到四个字节至结果字符串中。 如果一个码点值是一个不合法的Unicode码点值，则它将被视为Unicode替换字符（码点）值0xFFFD（Unicode replacement character）。 替换字符值0xFFFD将被UTF-8编码为三个字节0xef 0xbf 0xbd。

当一个字符串被转换为一个码点切片时，此字符串中存储的字节序列将被解读为一个一个码点的UTF-8编码序列。 非法的UTF-8编码字节序列将被转化为Unicode替换字符值0xFFFD。

当一个字符串被转换为一个字节切片时，结果切片中的底层字节序列是此字符串中存储的字节序列的一份深复制。 即Go运行时将为结果切片开辟一块足够大的内存来容纳被复制过来的所有字节。当此字符串的长度较长时，此转换开销是比较大的。 同样，当一个字节切片被转换为一个字符串时，此字节切片中的字节序列也将被深复制到结果字符串中。 当此字节切片的长度较长时，此转换开销同样是比较大的。 在这两种转换中，必须使用深复制的原因是字节切片中的字节元素是可修改的，但是字符串中的字节是不可修改的，所以一个字节切片和一个字符串是不能共享底层字节序列的。

请注意，在字符串和字节切片之间的转换中，
非法的UTF-8编码字节序列将被保持原样不变。
标准编译器做了一些优化，从而使得这些转换在某些情形下将不用深复制。 这样的情形将在下一节中介绍。
Go并不支持字节切片和码点切片之间的直接转换。我们可以用下面列出的方法来实现这样的转换：
利用字符串做为中间过渡。这种方法相对方便但效率较低，因为需要做两次深复制。
使用unicode/utf8标准库包中的函数来实现这些转换。 这种方法效率较高，但使用起来不太方便。
使用bytes标准库包中的Runes函数来将一个字节切片转换为码点切片。 但此包中没有将码点切片转换为字节切片的函数。
一个展示了上述各种转换的例子：
package main

import (
"bytes"
"unicode/utf8"
)

func Runes2Bytes(rs []rune) []byte {
n := 0
for _, r := range rs {
n += utf8.RuneLen(r)
}
n, bs := 0, make([]byte, n)
for _, r := range rs {
n += utf8.EncodeRune(bs[n:], r)
}
return bs
}

func main() {
s := "颜色感染是一个有趣的游戏。"
bs := []byte(s) // string -> []byte
s = string(bs)  // []byte -> string
rs := []rune(s) // string -> []rune
s = string(rs)  // []rune -> string
rs = bytes.Runes(bs) // []byte -> []rune
bs = Runes2Bytes(rs) // []rune -> []byte
}
字符串和字节切片之间的转换的编译器优化
上面已经提到了字符串和字节切片之间的转换将深复制它们的底层字节序列。 标准编译器做了一些优化，从而在某些情形下避免了深复制。 至少这些优化在当前（Go官方工具链1.20）是存在的。 这样的情形包括：
一个for-range循环中跟随range关键字的从字符串到字节切片的转换；
一个在映射元素读取索引语法中被用做键值的从字节切片到字符串的转换（注意：对修改写入索引语法无效）；
一个字符串比较表达式中被用做比较值的从字节切片到字符串的转换；
一个（至少有一个被衔接的字符串值为非空字符串常量的）字符串衔接表达式中的从字节切片到字符串的转换。
一个例子：
package main

import "fmt"

func main() {
var str = "world"
// 这里，转换[]byte(str)将不需要一个深复制。
for i, b := range []byte(str) {
fmt.Println(i, ":", b)
}

	key := []byte{'k', 'e', 'y'}
	m := map[string]string{}
	// 这个string(key)转换仍然需要深复制。
	m[string(key)] = "value"
	// 这里的转换string(key)将不需要一个深复制。
	// 即使key是一个包级变量，此优化仍然有效。
	fmt.Println(m[string(key)]) // value
}
注意：在最后一行中，如果在估值string(key)的时候有数据竞争的情况，则这行的输出有可能并不是value。 但是，无论如何，此行都不会造成恐慌（即使有数据竞争的情况发生）。

另一个例子：
package main

import "fmt"
import "testing"

var s string
var x = []byte{1023: 'x'}
var y = []byte{1023: 'y'}

func fc() {
// 下面的四个转换都不需要深复制。
if string(x) != string(y) {
s = (" " + string(x) + string(y))[1:]
}
}

func fd() {
// 两个在比较表达式中的转换不需要深复制，
// 但两个字符串衔接中的转换仍需要深复制。
// 请注意此字符串衔接和fc中的衔接的差别。
if string(x) != string(y) {
s = string(x) + string(y)
}
}

func main() {
fmt.Println(testing.AllocsPerRun(1, fc)) // 1
fmt.Println(testing.AllocsPerRun(1, fd)) // 3
}
使用for-range循环遍历字符串中的码点
for-range循环控制中的range关键字后可以跟随一个字符串，用来遍历此字符串中的码点（而非字节元素）。 字符串中非法的UTF-8编码字节序列将被解读为Unicode替换码点值0xFFFD。

一个例子：
package main

import "fmt"

func main() {
s := "éक्षिaπ囧"
for i, rn := range s {
fmt.Printf("%2v: 0x%x %v \n", i, rn, string(rn))
}
fmt.Println(len(s))
}
此程序的输出如下：
0: 0x65 e
1: 0x301 ́
3: 0x915 क
6: 0x94d ्
9: 0x937 ष
12: 0x93f ि
15: 0x61 a
16: 0x3c0 π
18: 0x56e7 囧
21
从此输出结果可以看出：
下标循环变量的值并非连续。原因是下标循环变量为字符串中字节的下标，而一个码点可能需要多个字节进行UTF-8编码。
第一个字符é由两个码点（共三字节）组成，其中一个码点需要两个字节进行UTF-8编码。
第二个字符क्षि由四个码点（共12字节）组成，每个码点需要三个字节进行UTF-8编码。
英语字符a由一个码点组成，此码点只需一个字节进行UTF-8编码。
字符π由一个码点组成，此码点只需两个字节进行UTF-8编码。
汉字囧由一个码点组成，此码点只需三个字节进行UTF-8编码。
那么如何遍历一个字符串中的字节呢？使用传统for循环：
package main

import "fmt"

func main() {
s := "éक्षिaπ囧"
for i := 0; i < len(s); i++ {
fmt.Printf("第%v个字节为0x%x\n", i, s[i])
}
}
当然，我们也可以利用前面介绍的编译器优化来使用for-range循环遍历一个字符串中的字节元素。 对于官方标准编译器来说，此方法比刚展示的方法效率更高。
package main

import "fmt"

func main() {
s := "éक्षिaπ囧"
// 这里，[]byte(s)不需要深复制底层字节。
for i, b := range []byte(s) {
fmt.Printf("The byte at index %v: 0x%x \n", i, b)
}
}
从上面几个例子可以看出，len(s)将返回字符串s中的字节数。 len(s)的时间复杂度为O(1)。 如何得到一个字符串中的码点数呢？使用刚介绍的for-range循环来统计一个字符串中的码点数是一种方法，使用unicode/utf8标准库包中的RuneCountInString是另一种方法。 这两种方法的效率基本一致。第三种方法为使用len([]rune(s）)来获取字符串s中码点数。标准编译器从1.11版本开始，对此表达式做了优化以避免一个不必要的深复制，从而使得它的效率和前两种方法一致。 注意，这三种方法的时间复杂度均为O(n)。

更多字符串衔接方法
除了使用+运算符来衔接字符串，我们也可以用下面的方法来衔接字符串：
fmt标准库包中的Sprintf/Sprint/Sprintln函数可以用来衔接各种类型的值的字符串表示，当然也包括字符串类型的值。
使用strings标准库包中的Join函数。
bytes标准库包提供的Buffer类型可以用来构建一个字节切片，然后我们可以将此字节切片转换为一个字符串。
从Go 1.10开始，strings标准库包中的Builder类型可以用来拼接字符串。 和bytes.Buffer类型类似，此类型内部也维护着一个字节切片，但是它在将此字节切片转换为字符串时避免了底层字节的深复制。
标准编译器对使用+运算符的字符串衔接做了特别的优化。 所以，一般说来，在被衔接的字符串的数量是已知的情况下，使用+运算符进行字符串衔接是比较高效的。

语法糖：将字符串当作字节切片使用
在上一篇文章中，我们了解到内置函数copy和append可以用来复制和添加切片元素。 事实上，做为一个特例，如果这两个函数的调用中的第一个实参为一个字节切片的话，那么第二个实参可以是一个字符串。 （对于append函数调用，字符串实参后必须跟随三个点...。） 换句话说，在此特例中，字符串可以当作字节切片来使用。

一个例子：
package main

import "fmt"

func main() {
hello := []byte("Hello ")
world := "world!"

	// helloWorld := append(hello, []byte(world)...) // 正常的语法
	helloWorld := append(hello, world...)            // 语法糖
	fmt.Println(string(helloWorld))

	helloWorld2 := make([]byte, len(hello) + len(world))
	copy(helloWorld2, hello)
	// copy(helloWorld2[len(hello):], []byte(world)) // 正常的语法
	copy(helloWorld2[len(hello):], world)            // 语法糖
	fmt.Println(string(helloWorld2))
}
更多关于字符串的比较
上面已经提到了比较两个字符串事实上逐个比较这两个字符串中的字节。 Go编译器一般会做出如下的优化：
对于==和!=比较，如果这两个字符串的长度不相等，则这两个字符串肯定不相等（无需进行字节比较）。
如果这两个字符串底层引用着字符串切片的指针相等，则比较结果等同于比较这两个字符串的长度。
所以两个相等的字符串的比较的时间复杂度取决于它们底层引用着字符串切片的指针是否相等。 如果相等，则对它们的比较的时间复杂度为O(1)，否则时间复杂度为O(n)。

上面已经提到了，对于标准编译器，一个字符串赋值完成之后，目标字符串和源字符串将共享同一个底层字节序列。 所以比较这两个字符串的代价很小。

一个例子：
package main

import (
"fmt"
"time"
)

func main() {
bs := make([]byte, 1<<26)
s0 := string(bs)
s1 := string(bs)
s2 := s1

	// s0、s1和s2是三个相等的字符串。
	// s0的底层字节序列是bs的一个深复制。
	// s1的底层字节序列也是bs的一个深复制。
	// s0和s1底层字节序列为两个不同的字节序列。
	// s2和s1共享同一个底层字节序列。

	startTime := time.Now()
	_ = s0 == s1
	duration := time.Now().Sub(startTime)
	fmt.Println("duration for (s0 == s1):", duration)

	startTime = time.Now()
	_ = s1 == s2
	duration = time.Now().Sub(startTime)
	fmt.Println("duration for (s1 == s2):", duration)
}
输出如下：
duration for (s0 == s1): 10.462075ms
duration for (s1 == s2): 136ns
1ms等于1000000ns！所以请尽量避免比较两个很长的不共享底层字节序列的相等的（或者几乎相等的）字符串。

## 函数
函数签名（function signature）和函数类型
刚已经提到了，在Go中，函数是一种一等公民类型。 一个函数类型的字面表示形式由一个func关键字和一个函数签名字面表示表示形式组成。 一个函数签名由一个输入参数类型列表和一个输出结果类型列表组成。 参数名称和结果名称可以出现函数签名的字面表示形式中，但是它们并不重要。

func关键字可以出现在函数签名的字面形式中，也可以不出现。 鉴于此，我们常常混淆使用函数类型（见下）和函数签名这两个概念。

下面是一个函数类型的字面形式:
func (a int, b string, c string) (x int, y int, z bool)
从前面的函数声明和调用一文中，我们了解到连续的同类型参数和结果可以声明在一块儿。 所以上面的字面形式等价于：
func (a int, b, c string) (x, y int, z bool)
参数名称和结果名称并不重要，只要它们不重名即可。上面两个字面形式等价于下面这个：
func (x int, y, z string) (a, b int, c bool)
参数名和结果名可以是空标识符_。上面的字面形式等价于：
func (_ int, _, _ string) (_, _ int, _ bool)
函数参数列表中的参数名或者结果列表中的结果名可以同时省略（即匿名）。上面的字面形式等价于：
func (int, string, string) (int, int, bool) // 标准函数字面形式
func (a int, b string, c string) (int, int, bool)
func (x int, _ string, z string) (int, int, bool)
func (int, string, string) (x int, y int, z bool)
func (int, string, string) (a int, b int, _ bool)
所有上面列出的函数类型字面形式表示同一个（无名）函数类型。

参数列表必须用一对小括号()括起来，即使此列表为空。 如果一个函数类型一个结果列表为空，则它可以在函数类型的字面形式中被省略掉。 当一个结果列表含有最多一个结果，则此结果列表的字面形式在它不包含结果名称的时候可以不用括号()括起来。
// 这三个函数类型字面形式是等价的。
func () (x int)
func () (int)
func () int

// 这两个函数类型字面形式是等价的。
func (a int, b string) ()
func (a int, b string)
变长参数和变长参数函数类型
一个函数的最后一个参数可以是一个变长参数。一个函数可以最多有一个变长参数。一个变长参数的类型总为一个切片类型。 变长参数在声明的时候必须在它的（切片）类型的元素类型前面前置三个点...，以示这是一个变长参数。 两个变长函数类型的例子：
func (values ...int64) (sum int64)
func (sep string, tokens ...string) string
一个变长函数类型和一个非变长函数类型绝对不可能是同一个类型。

后面的一节将展示几个变长函数声明和使用的例子。

所有的函数类型都属于不可比较类型
Go类型系统概述一文已经提到了函数类型属于不可比较类型。 但是，和映射值以及切片值类似，一个函数值可以和类型不确定的nil比较。（函数值将在本文最后一节介绍。）

因为函数类型属于不可比较类型，所以函数类型不可用做映射类型的键值类型。

函数原型（function prototype）
一个函数原型由一个函数名称和一个函数类型（或者说一个函数签名）组成。 它的字面形式由一个func关键字、一个函数名和一个函数签名字面形式组成。

一个函数原型的例子：
func Double(n int) (result int)
换句话说，一个函数原型可以看作是一个不带函数体的函数声明； 或者说一个函数声明由一个函数原型和一个函数体组成。

变长函数声明和变长函数调用
普通非变长函数的声明和调用已经在函数声明和调用一文中介绍过了。 本节将介绍变长函数的声明和调用。

变长函数声明
变长函数声明和普通函数声明类似，只不过最后一个参数必须为变长参数。 一个变长参数在函数体内将被视为一个切片。
// Sum返回所有输入实参的和。
func Sum(values ...int64) (sum int64) {
// values的类型为[]int64。
sum = 0
for _, v := range values {
sum += v
}
return
}

// Concat是一个低效的字符串拼接函数。
func Concat(sep string, tokens ...string) string {
// tokens的类型为[]string。
r := ""
for i, t := range tokens {
if i != 0 {
r += sep
}
r += t
}
return r
}
从上面的两个变长参数函数声明可以看出，如果一个变长参数的类型部分为...T，则此变长参数的类型实际为[]T。

事实上，在前面的文章中多次使用过的fmt标准库包中的Print、Println和Printf函数均为变长参数函数。 它们的声明大致如下：
func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int, err error)
func Println(a ...interface{}) (n int, err error)
这三个函数中的变长参数的类型均为[]interface{}。此类型的元素类型为interface{}，这是一个接口类型。 接口类型和接口值将在后面的接口一文中详述。

变长参数函数调用
在变长参数函数调用中，可以使用两种风格的方式将实参传递给类型为[]T的变长形参：
传递一个切片做为实参。此切片必须可以被赋值给类型为[]T的值（或者说此切片可以被隐式转换为类型[]T）。 此实参切片后必须跟随三个点...。
传递零个或者多个可以被隐式转换为T的实参（或者说这些实参可以赋值给类型为T的值）。 这些实参将被添加入一个匿名的在运行时刻创建的类型为[]T的切片中，然后此切片将被传递给此函数调用。
注意，这两种风格的方式不可在同一个变长参数函数调用中混用。

下面这个例子展示了一些变长参数函数调用：
package main

import "fmt"

func Sum(values ...int64) (sum int64) {
sum = 0
for _, v := range values {
sum += v
}
return
}

func main() {
a0 := Sum()
a1 := Sum(2)
a3 := Sum(2, 3, 5)
// 上面三行和下面三行是等价的。
b0 := Sum([]int64{}...) // <=> Sum(nil...)
b1 := Sum([]int64{2}...)
b3 := Sum([]int64{2, 3, 5}...)
fmt.Println(a0, a1, a3) // 0 2 10
fmt.Println(b0, b1, b3) // 0 2 10
}
另一个展示了一些变长参数函数调用的例子：
package main

import "fmt"

func Concat(sep string, tokens ...string) (r string) {
for i, t := range tokens {
if i != 0 {
r += sep
}
r += t
}
return
}

func main() {
tokens := []string{"Go", "C", "Rust"}
langsA := Concat(",", tokens...)        // 风格1
langsB := Concat(",", "Go", "C","Rust") // 风格2
fmt.Println(langsA == langsB)           // true
}
下面这个例子编译不通过，因为两种调用风格混用了。
package main

// 这两个函数的声明见前面几例。
func Sum(values ...int64) (sum int64) {......}
func Concat(sep string, tokens ...string) string {......}

func main() {
// 下面两行报同样的错：实参数目太多了。
_ = Sum(2, []int64{3, 5}...)
_ = Concat(",", "Go", []string{"C", "Rust"}...)
}
更多关于函数声明和函数调用的事实
同一个包中可以同名的函数
一般来说，同一个包中声明的函数的名称不能重复，但有两个例外：
同一个包内可以声明若干个原型为func ()的名称为init的函数。
多个函数的名称可以被声明为空标识符_。这样声明的函数不可被调用。
某些函数调用是在编译时刻被估值的
大多数函数调用都是在运行时刻被估值的。 但unsafe标准库包中的函数的调用都是在编译时刻估值的。 另外，某些其它内置函数（比如len和cap等）的调用在所传实参满足一定的条件的时候也将在编译时刻估值。 详见在编译时刻估值的函数调用。

所有的函数调用的传参均属于值复制
再重申一次，和赋值一样，传参也属于值（浅）复制。当一个值被复制时，只有它的直接部分被复制了。

不含函数体的函数声明
我们可以使用Go汇编（Go assembly）来实现一个Go函数。 Go汇编代码放在后缀为.a的文件中。 一个使用Go汇编实现的函数依旧必须在一个*.go文件中声明，但是它的声明必须不能含有函数体。 换句话说，一个使用Go汇编实现的函数的声明中只含有它的原型。

某些有返回值的函数可以不必返回
如果一个函数有返回值，则它的函数体内的最后一条语句必须为一条终止语句。 Go中有多种终止语句，return语句只是其中一种。所以一个有返回值的函数的体内不一定需要一个return语句。 比如下面两个函数（它们均可编译通过）：
func fa() int {
a:
goto a
}

func fb() bool {
for{}
}
自定义函数的调用返回结果可以被舍弃，但是某些内置函数的调用返回结果不可被舍弃
自定义函数的调用结果都是可以被舍弃掉的。 但是大多数内置函数（除了recover和copy）的调用结果都是不可被舍弃的。 调用结果不可被舍弃的函数是不可以被用做延迟调用函数和协程起始函数的，比如append函数。

有返回值的函数的调用是一种表达式
一个有且只有一个返回值的函数的每个调用总可以被当成一个单值表达式使用。 比如，它可以被内嵌在其它函数调用中当作实参使用，或者可以被当作其它表达式中的操作数使用。

如果一个有多个返回结果的函数的一个调用的返回结果没有被舍弃，则此调用可以当作一个多值表达式使用在两种场合：
此调用可以在一个赋值语句中当作源值来使用，但是它不能和其它源值掺和到一块。
此调用可以内嵌在另一个函数调用中当作实参来使用，但是它不能和其它实参掺和到一块。
一个例子：
package main

func HalfAndNegative(n int) (int, int) {
return n/2, -n
}

func AddSub(a, b int) (int, int) {
return a+b, a-b
}

func Dummy(values ...int) {}

func main() {
// 这几行编译没问题。
AddSub(HalfAndNegative(6))
AddSub(AddSub(AddSub(7, 5)))
AddSub(AddSub(HalfAndNegative(6)))
Dummy(HalfAndNegative(6))
_, _ = AddSub(7, 5)

	// 下面这几行编译不通过。
	/*
	_, _, _ = 6, AddSub(7, 5)
	Dummy(AddSub(7, 5), 9)
	Dummy(AddSub(7, 5), HalfAndNegative(6))
	*/
}
注意，在目前的标准编译器的实现中，有几个内置函数破坏了上述规则的普遍性。

函数值
本文开头已经介绍了函数类型是Go中天然支持的一种类型。函数类型的值称为函数值。 在字面上，函数类型的零值也使用预定义的nil来表示。

当我们声明了一个函数的时候，我们实际上同时声明了一个不可修改的函数值。 此函数值用此函数的名称来标识。此函数值的类型的字面表示形式为此函数的原型刨去函数名部分。

注意：内置函数和init函数不可被用做函数值。

任何函数值都可以被当作普通声明函数来调用。 调用一个nil函数来开启一个协程将产生一个致命的不可恢复的错误，此错误将使整个程序崩溃。 在其它情况下调用一个nil函数将产生一个可恢复的恐慌。

从值部一文，我们得知，当一个函数值被赋给另一个函数值后，这两个函数值将共享底层部分（内部的函数结构）。 换句话说，这两个函数值表示的函数可以看作是同一个函数。调用它们的效果是相同的。

一个例子：
package main

import "fmt"

func Double(n int) int {
return n + n
}

func Apply(n int, f func(int) int) int {
return f(n) // f的类型为"func(int) int"
}

func main() {
fmt.Printf("%T\n", Double) // func(int) int
// Double = nil // error: Double是不可修改的

	var f func(n int) int // 默认值为nil
	f = Double
	g := Apply
	fmt.Printf("%T\n", g) // func(int, func(int) int) int

	fmt.Println(f(9))         // 18
	fmt.Println(g(6, Double)) // 12
	fmt.Println(Apply(6, f))  // 12
}
在上例中，g(6, Double)和Apply(6, f)是等价的。

在实践中，我们常常将一个匿名函数赋值给一个函数类型的变量，从而可以在以后多次调用此匿名函数。
package main

import "fmt"

func main() {
// 此函数返回一个函数类型的结果，亦即闭包（closure）。
isMultipleOfX := func (x int) func(int) bool {
return func(n int) bool {
return n%x == 0
}
}

	var isMultipleOf3 = isMultipleOfX(3)
	var isMultipleOf5 = isMultipleOfX(5)
	fmt.Println(isMultipleOf3(6))  // true
	fmt.Println(isMultipleOf3(8))  // false
	fmt.Println(isMultipleOf5(10)) // true
	fmt.Println(isMultipleOf5(12)) // false

	isMultipleOf15 := func(n int) bool {
		return isMultipleOf3(n) && isMultipleOf5(n)
	}
	fmt.Println(isMultipleOf15(32)) // false
	fmt.Println(isMultipleOf15(60)) // true
}
Go中所有的函数都可以看作是闭包，这是Go函数如此灵活及使用体验如此统一的原因。

## 通道
通道（channel）介绍
Go语言设计团队的首任负责人Rob Pike对并发编程的一个建议是不要让计算通过共享内存来通讯，而应该让它们通过通讯来共享内存。 通道机制就是这种哲学的一个设计结果。（在Go编程中，我们可以认为一个计算就是一个协程。）

通过共享内存来通讯和通过通讯来共享内存是并发编程中的两种编程风格。 当通过共享内存来通讯的时候，我们需要一些传统的并发同步技术（比如互斥锁）来避免数据竞争。

Go提供了一种独特的并发同步技术来实现通过通讯来共享内存。此技术即为通道。 我们可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。

随着一个数据值的传递（发送和接收），一些数据值的所有权从一个协程转移到了另一个协程。 当一个协程发送一个值到一个通道，我们可以认为此协程释放了（通过此发送值可以访问到的）一些值的所有权。 当一个协程从一个通道接收到一个值，我们可以认为此协程获取了（通过此接受值可以访问到的）一些值的所有权。

当然，在通过通道传递数据的时候，也可能没有任何所有权发生转移。

所有权发生转移的值常常被传递的值所引用着，但有时候也并非如此。 在Go中，数据所有权的转移并非体现在语法上，而是体现在逻辑上。 Go通道可以帮助程序员轻松地避免数据竞争，但不会防止程序员因为犯错而写出错误的并发代码的情况发生。

尽管Go也支持几种传统的数据同步技术，但是只有通道为一等公民。 通道是Go中的一种类型，所以我们可以无需引进任何代码包就可以使用通道。 几种传统的数据同步技术提供在sync和sync/atomic标准库包中。

实事求是地说，每种并发同步技术都有它们各自的最佳应用场景，但是通道的应用范围更广。 使用通道来做同步常常可以使得代码看上去更整洁和易于理解。

通道的一个问题是通道的编程体验常常很有趣以至于程序员们经常在并非是通道的最佳应用场景中仍坚持使用通道。

通道类型和值
和数组、切片以及映射类型一样，每个通道类型也有一个元素类型。 一个通道只能传送它的（通道类型的）元素类型的值。

通道可以是双向的，也可以是单向的。
字面形式chan T表示一个元素类型为T的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据。
字面形式chan<- T表示一个元素类型为T的单向发送通道类型。 编译器不允许从此类型的值中接收数据。
字面形式<-chan T表示一个元素类型为T的单向接收通道类型。 编译器不允许向此类型的值中发送数据。
双向通道chan T的值可以被隐式转换为单向通道类型chan<- T和<-chan T，但反之不行（即使显式也不行）。 类型chan<- T和<-chan T的值也不能相互转换。

每个通道值有一个容量属性。此属性的意义将在下一节中得到解释。 一个容量为0的通道值称为一个非缓冲通道（unbuffered channel），一个容量不为0的通道值称为一个缓冲通道（buffered channel）。

通道类型的零值也使用预声明的nil来表示。 一个非零通道值必须通过内置的make函数来创建。 比如make(chan int, 10)将创建一个元素类型为int的通道值。 第二个参数指定了欲创建的通道的容量。此第二个实参是可选的，它的默认值为0。

通道值的比较
所有通道类型均为可比较类型。

从值部一文，我们了解到一个通道值可能含有底层部分。 当一个通道值被赋给另一个通道值后，这两个通道值将共享相同的底层部分。 换句话说，这两个通道引用着同一个底层的内部通道对象。 比较这两个通道的结果为true。

通道操作
Go中有五种通道相关的操作。假设一个通道（值）为ch，下面列出了这五种操作的语法或者函数调用。

调用内置函数close来关闭一个通道：
close(ch)
传给close函数调用的实参必须为一个通道值，并且此通道值不能为单向接收的。

使用下面的语法向通道ch发送一个值v：
ch <- v
v必须能够赋值给通道ch的元素类型。 ch不能为单向接收通道。 <-称为数据发送操作符。

使用下面的语法从通道ch接收一个值：
<-ch
如果一个通道操作不永久阻塞，它总会返回至少一个值，此值的类型为通道ch的元素类型。 ch不能为单向发送通道。 <-称为数据接收操作符，是的它和数据发送操作符的表示形式是一样的。
在大多数场合下，一个数据接收操作可以被认为是一个单值表达式。 但是，当一个数据接收操作被用做一个赋值语句中的唯一的源值的时候，它可以返回第二个可选的类型不确定的布尔值返回值从而成为一个多值表达式。 此类型不确定的布尔值表示第一个返回值是否是在通道被关闭之前被发送的。 （从后面的章节，我们将得知我们可以从一个已关闭的通道中接收到无穷个值。）
数据接收操作在赋值中被用做源值的例子：
v = <-ch
v, sentBeforeClosed = <-ch
查询一个通道的容量：
cap(ch)
其中cap是一个已经在容器类型一文中介绍过的内置函数。 cap的返回值的类型为内置类型int。

查询一个通道的长度：
len(ch)
其中len是一个已经在容器类型一文中介绍过的内置函数。 len的返回值的类型也为内置类型int。 一个通道的长度是指当前有多少个已被发送到此通道但还未被接收出去的元素值。

Go中大多数的基本操作都是未同步的。换句话说，它们都不是并发安全的。 这些操作包括赋值、传参、和各种容器值操作等。 但是，上面列出的五种通道相关的操作都已经同步过了，因此它们可以在并发协程中安全运行而无需其它同步操作。

注意：通道的赋值和其它类型值的赋值一样，是未同步的。 同样，将刚从一个通道接收出来的值赋给另一个值也是未同步的。

如果被查询的通道为一个nil零值通道，则cap和len函数调用都返回0。 这两个操作是如此简单，所以后面将不再对它们进行详解。 事实上，这两个操作在实践中很少使用。

通道的发送、接收和关闭操作将在下一节得到详细解释。

通道操作详解
为了让解释简单清楚，在本文后续部分，通道将被归为三类：
零值（nil）通道；
非零值但已关闭的通道；
非零值并且尚未关闭的通道。
下表简单地描述了三种通道操作施加到三类通道的结果。

操作	一个零值nil通道	一个非零值但已关闭的通道	一个非零值且尚未关闭的通道
关闭	产生恐慌	产生恐慌	成功关闭(C)
发送数据	永久阻塞	产生恐慌	阻塞或者成功发送(B)
接收数据	永久阻塞	永不阻塞(D)	阻塞或者成功接收(A)
对于上表中的五种未打上标的情形，规则很简单：
关闭一个nil通道或者一个已经关闭的通道将产生一个恐慌。
向一个已关闭的通道发送数据也将导致一个恐慌。
向一个nil通道发送数据或者从一个nil通道接收数据将使当前协程永久阻塞。
下面将详细解释其它四种被打了上标（A/B/C/D）的情形。

为了更好地理解通道和为了后续讲解方便，先了解一下通道类型的大致内部实现是很有帮助的。

我们可以认为一个通道内部维护了三个队列（均可被视为先进先出队列）：
接收数据协程队列（可以看做是先进先出队列但其实并不完全是，见下面解释）。此队列是一个没有长度限制的链表。 此队列中的协程均处于阻塞状态，它们正等待着从此通道接收数据。
发送数据协程队列（可以看做是先进先出队列但其实并不完全是，见下面解释）。此队列也是一个没有长度限制的链表。 此队列中的协程亦均处于阻塞状态，它们正等待着向此通道发送数据。 此队列中的每个协程将要发送的值（或者此值的指针，取决于具体编译器实现）和此协程一起存储在此队列中。
数据缓冲队列。这是一个循环队列（绝对先进先出），它的长度为此通道的容量。此队列中存放的值的类型都为此通道的元素类型。 如果此队列中当前存放的值的个数已经达到此通道的容量，则我们说此通道已经处于满槽状态。 如果此队列中当前存放的值的个数为零，则我们说此通道处于空槽状态。 对于一个非缓冲通道（容量为零），它总是同时处于满槽状态和空槽状态。
每个通道内部维护着一个互斥锁用来在各种通道操作中防止数据竞争。

通道操作情形A： 当一个协程R尝试从一个非零且尚未关闭的通道接收数据的时候，此协程R将首先尝试获取此通道的锁，成功之后将执行下列步骤，直到其中一个步骤的条件得到满足。
如果此通道的缓冲队列不为空（这种情况下，接收数据协程队列必为空），此协程R将从缓冲队列取出（接收）一个值。 如果发送数据协程队列不为空，一个发送协程将从此队列中弹出，此协程欲发送的值将被推入缓冲队列。此发送协程将恢复至运行状态。 接收数据协程R继续运行，不会阻塞。对于这种情况，此数据接收操作为一个非阻塞操作。
否则（即此通道的缓冲队列为空），如果发送数据协程队列不为空（这种情况下，此通道必为一个非缓冲通道）， 一个发送数据协程将从此队列中弹出，此协程欲发送的值将被接收数据协程R接收。此发送协程将恢复至运行状态。 接收数据协程R继续运行，不会阻塞。对于这种情况，此数据接收操作为一个非阻塞操作。
对于剩下的情况（即此通道的缓冲队列和发送数据协程队列均为空），此接收数据协程R将被推入接收数据协程队列，并进入阻塞状态。 它以后可能会被另一个发送数据协程唤醒而恢复运行。 对于这种情况，此数据接收操作为一个阻塞操作。
通道操作情形B： 当一个协程S尝试向一个非零且尚未关闭的通道发送数据的时候，此协程S将首先尝试获取此通道的锁，成功之后将执行下列步骤，直到其中一个步骤的条件得到满足。
如果此通道的接收数据协程队列不为空（这种情况下，缓冲队列必为空）， 一个接收数据协程将从此队列中弹出，此协程将接收到发送协程S发送的值。此接收协程将恢复至运行状态。 发送数据协程S继续运行，不会阻塞。对于这种情况，此数据发送操作为一个非阻塞操作。
否则（接收数据协程队列为空），如果缓冲队列未满（这种情况下，发送数据协程队列必为空）， 发送协程S欲发送的值将被推入缓冲队列，发送数据协程S继续运行，不会阻塞。 对于这种情况，此数据发送操作为一个非阻塞操作。
对于剩下的情况（接收数据协程队列为空，并且缓冲队列已满），此发送协程S将被推入发送数据协程队列，并进入阻塞状态。 它以后可能会被另一个接收数据协程唤醒而恢复运行。 对于这种情况，此数据发送操作为一个阻塞操作。
上面已经提到过，一旦一个非零通道被关闭，继续向此通道发送数据将产生一个恐慌。 注意，向关闭的通道发送数据属于一个非阻塞操作。

通道操作情形C： 当一个协程成功获取到一个非零且尚未关闭的通道的锁并且准备关闭此通道时，下面两步将依次执行：
如果此通道的接收数据协程队列不为空（这种情况下，缓冲队列必为空），此队列中的所有协程将被依个弹出，并且每个协程将接收到此通道的元素类型的一个零值，然后恢复至运行状态。
如果此通道的发送数据协程队列不为空，此队列中的所有协程将被依个弹出，并且每个协程中都将产生一个恐慌（因为向已关闭的通道发送数据）。 这就是我们在上面说并发地关闭一个通道和向此通道发送数据这种情形属于不良设计的原因。 事实上，在数据竞争侦测编译选项（-race）打开时，Go官方标准运行时将很可能会对并发地关闭一个通道和向此通道发送数据这种情形报告成数据竞争。
注意：当一个缓冲队列不为空的通道被关闭之后，它的缓冲队列不会被清空，其中的数据仍然可以被后续的数据接收操作所接收到。详见下面的对情形D的解释。

通道操作情形D： 一个非零通道被关闭之后，此通道上的后续数据接收操作将永不会阻塞。 此通道的缓冲队列中存储数据仍然可以被接收出来。 伴随着这些接收出来的缓冲数据的第二个可选返回（类型不确定布尔）值仍然是true。 一旦此缓冲队列变为空，后续的数据接收操作将永不阻塞并且总会返回此通道的元素类型的零值和值为false的第二个可选返回结果。 上面已经提到了，一个接收操作的第二个可选返回（类型不确定布尔）结果表示一个接收到的值是否是在此通道被关闭之前发送的。 如果此返回值为false，则第一个返回值必然是一个此通道的元素类型的零值。

知道哪些通道操作是阻塞的和哪些是非阻塞的对正确理解后面将要介绍的select流程控制机制非常重要。

如果一个协程被从一个通道的某个队列中（不论发送数据协程队列还是接收数据协程队列）弹出，并且此协程是在一个select控制流程中推入到此队列的，那么此协程将在下面将要讲解的select控制流程的执行步骤中的第9步中恢复至运行状态，并且同时它会被从相应的select控制流程中的相关的若干通道的协程队列中移除掉。

根据上面的解释，我们可以得出如下的关于一个通道的内部的三个队列的各种事实：
如果一个通道已经关闭了，则它的发送数据协程队列和接收数据协程队列肯定都为空，但是它的缓冲队列可能不为空。
在任何时刻，如果缓冲队列不为空，则接收数据协程队列必为空。
在任何时刻，如果缓冲队列未满，则发送数据协程队列必为空。
如果一个通道是缓冲的，则在任何时刻，它的发送数据协程队列和接收数据协程队列之一必为空。
如果一个通道是非缓冲的，则在任何时刻，一般说来，它的发送数据协程队列和接收数据协程队列之一必为空， 但是有一个例外：一个协程可能在一个select流程控制中同时被推入到此通道的发送数据协程队列和接收数据协程队列中。
一些通道的使用例子
来看一些通道的使用例子来加深一下对上一节中的解释的理解。

一个简单的通过一个非缓冲通道实现的请求/响应的例子：
package main

import (
"fmt"
"time"
)

func main() {
c := make(chan int) // 一个非缓冲通道
go func(ch chan<- int, x int) {
time.Sleep(time.Second)
// <-ch    // 此操作编译不通过
ch <- x*x  // 阻塞在此，直到发送的值被接收
}(c, 3)
done := make(chan struct{})
go func(ch <-chan int) {
n := <-ch      // 阻塞在此，直到有值发送到c
fmt.Println(n) // 9
// ch <- 123   // 此操作编译不通过
time.Sleep(time.Second)
done <- struct{}{}
}(c)
<-done // 阻塞在此，直到有值发送到done
fmt.Println("bye")
}
输出结果：
9
bye
下面的例子使用了一个缓冲通道。此例子程序并非是一个并发程序，它只是为了展示缓冲通道的使用。
package main

import "fmt"

func main() {
c := make(chan int, 2) // 一个容量为2的缓冲通道
c <- 3
c <- 5
close(c)
fmt.Println(len(c), cap(c)) // 2 2
x, ok := <-c
fmt.Println(x, ok) // 3 true
fmt.Println(len(c), cap(c)) // 1 2
x, ok = <-c
fmt.Println(x, ok) // 5 true
fmt.Println(len(c), cap(c)) // 0 2
x, ok = <-c
fmt.Println(x, ok) // 0 false
x, ok = <-c
fmt.Println(x, ok) // 0 false
fmt.Println(len(c), cap(c)) // 0 2
close(c) // 此行将产生一个恐慌
c <- 7   // 如果上一行不存在，此行也将产生一个恐慌。
}
一场永不休场的足球比赛：
package main

import (
"fmt"
"time"
)

func main() {
var ball = make(chan string)
kickBall := func(playerName string) {
for {
fmt.Print(<-ball, "传球", "\n")
time.Sleep(time.Second)
ball <- playerName
}
}
go kickBall("张三")
go kickBall("李四")
go kickBall("王二麻子")
go kickBall("刘大")
ball <- "裁判"   // 开球
var c chan bool // 一个零值nil通道
<-c             // 永久阻塞在此
}
请阅读通道用例大全来查看更多通道的使用例子。

通道的元素值的传递都是复制过程
在一个值被从一个协程传递到另一个协程的过程中，此值将被复制至少一次。 如果此传递值曾经在某个通道的缓冲队列中停留过，则它在此传递过程中将被复制两次。 一次复制发生在从发送协程向缓冲队列推入此值的时候，另一个复制发生在接收协程从缓冲队列取出此值的时候。 和赋值以及函数调用传参一样，当一个值被传递时，只有它的直接部分被复制。

对于官方标准编译器，最大支持的通道的元素类型的尺寸为65535。 但是，一般说来，为了在数据传递过程中避免过大的复制成本，我们不应该使用尺寸很大的通道元素类型。 如果欲传送的值的尺寸较大，应该改用指针类型做为通道的元素类型。

关于通道和协程的垃圾回收
注意，一个通道被其发送数据协程队列和接收数据协程队列中的所有协程引用着。因此，如果一个通道的这两个队列只要有一个不为空，则此通道肯定不会被垃圾回收。 另一方面，如果一个协程处于一个通道的某个协程队列之中，则此协程也肯定不会被垃圾回收，即使此通道仅被此协程所引用。 事实上，一个协程只有在退出后才能被垃圾回收。

数据接收和发送操作都属于简单语句
数据接收和发送操作都属于简单语句。 另外一个数据接收操作总是可以被用做一个单值表达式。 简单语句和表达式可以被用在一些控制流程的某些部分。

在下面这个例子中，数据接收和发送操作被用在两个for循环的初始化和步尾语句。
package main

import (
"fmt"
"time"
)

func main() {
fibonacci := func() chan uint64 {
c := make(chan uint64)
go func() {
var x, y uint64 = 0, 1
for ; y < (1 << 63); c <- y { // 步尾语句
x, y = y, x+y
}
close(c)
}()
return c
}
c := fibonacci()
for x, ok := <-c; ok; x, ok = <-c { // 初始化和步尾语句
time.Sleep(time.Second)
fmt.Println(x)
}
}
for-range应用于通道
for-range循环控制流程也适用于通道。 此循环将不断地尝试从一个通道接收数据，直到此通道关闭并且它的缓冲队列为空为止。 和应用于数组/切片/映射的for-range语法不同，应用于通道的for-range语法中最多只能出现一个循环变量，此循环变量用来存储接收到的值。
for v := range aChannel {
// 使用v
}
等价于
for {
v, ok = <-aChannel
if !ok {
break
}
// 使用v
}
当然，这里的通道aChannel一定不能为一个单向发送通道。 如果它是一个nil零值，则此for-range循环将使当前协程永久阻塞。

上一节中的例子中的最后一个for循环可以改写为下面这样：
for x := range c {
time.Sleep(time.Second)
fmt.Println(x)
}
select-case分支流程控制代码块
Go中有一个专门为通道设计的select-case分支流程控制语法。 此语法和switch-case分支流程控制语法很相似。 比如，select-case流程控制代码块中也可以有若干case分支和最多一个default分支。 但是，这两种流程控制也有很多不同点。在一个select-case流程控制中，
select关键字和{之间不允许存在任何表达式和语句。
fallthrough语句不能被使用.
每个case关键字后必须跟随一个通道接收数据操作或者一个通道发送数据操作。 通道接收数据操作可以做为源值出现在一条简单赋值语句中。 以后，一个case关键字后跟随的通道操作将被称为一个case操作。
所有的非阻塞case操作中将有一个被随机选择执行（而不是按照从上到下的顺序），然后执行此操作对应的case分支代码块。
在所有的case操作均为阻塞的情况下，如果default分支存在，则default分支代码块将得到执行； 否则，当前协程将被推入所有阻塞操作中相关的通道的发送数据协程队列或者接收数据协程队列中，并进入阻塞状态。
按照上述规则，一个不含任何分支的select-case代码块select{}将使当前协程处于永久阻塞状态。

在下面这个例子中，default分支将铁定得到执行，因为两个case分支后的操作均为阻塞的。
package main

import "fmt"

func main() {
var c chan struct{} // nil
select {
case <-c:             // 阻塞操作
case c <- struct{}{}: // 阻塞操作
default:
fmt.Println("Go here.")
}
}
下面这个例子中实现了尝试发送（try-send）和尝试接收（try-receive）。 它们都是用含有一个case分支和一个default分支的select-case代码块来实现的。
package main

import "fmt"

func main() {
c := make(chan string, 2)
trySend := func(v string) {
select {
case c <- v:
default: // 如果c的缓冲已满，则执行默认分支。
}
}
tryReceive := func() string {
select {
case v := <-c: return v
default: return "-" // 如果c的缓冲为空，则执行默认分支。
}
}
trySend("Hello!") // 发送成功
trySend("Hi!")    // 发送成功
trySend("Bye!")   // 发送失败，但不会阻塞。
// 下面这两行将接收成功。
fmt.Println(tryReceive()) // Hello!
fmt.Println(tryReceive()) // Hi!
// 下面这行将接收失败。
fmt.Println(tryReceive()) // -
}
下面这个程序有50%的几率会因为恐慌而崩溃。 此程序中select-case代码块中的两个case操作均不阻塞，所以随机一个将被执行。 如果第一个case操作（向已关闭的通道发送数据）被执行，则一个恐慌将产生。
package main

func main() {
c := make(chan struct{})
close(c)
select {
case c <- struct{}{}: // 若此分支被选中，则产生一个恐慌
case <-c:
}
}
select-case流程控制的实现机理
select-case流程控制是Go中的一个重要和独特的特性。 下面列出了官方标准运行时中select-case流程控制的实现步骤。

将所有case操作中涉及到的通道表达式和发送值表达式按照从上到下，从左到右的顺序一一估值。 在赋值语句中做为源值的数据接收操作对应的目标值在此时刻不需要被估值。
将所有分支随机排序。default分支总是排在最后。 所有case操作中相关的通道可能会有重复的。
为了防止在下一步中造成（和其它协程互相）死锁，对所有case操作中相关的通道进行排序。 排序依据并不重要，官方Go标准编译器使用通道的地址顺序进行排序。 排序结果中前N个通道不存在重复的情况。 N为所有case操作中涉及到的不重复的通道的数量。 下面，通道锁顺序是针对此排序结果中的前N个通道来说的，通道锁逆序是指此顺序的逆序。
按照上一步中的生成通道锁顺序获取所有相关的通道的锁。
按照第2步中生成的分支顺序检查相应分支：
如果这是一个case分支并且相应的通道操作是一个向关闭了的通道发送数据操作，则按照通道锁逆序解锁所有的通道并在当前协程中产生一个恐慌。 跳到第12步。
如果这是一个case分支并且相应的通道操作是非阻塞的，则按照通道锁逆序解锁所有的通道并执行相应的case分支代码块。 （此相应的通道操作可能会唤醒另一个处于阻塞状态的协程。） 跳到第12步。
如果这是default分支，则按照通道锁逆序解锁所有的通道并执行此default分支代码块。 跳到第12步。
（到这里，default分支肯定是不存在的，并且所有的case操作均为阻塞的。）
将当前协程（和对应case分支信息）推入到每个case操作中对应的通道的发送数据协程队列或接收数据协程队列中。 当前协程可能会被多次推入到同一个通道的这两个队列中，因为多个case操作中对应的通道可能为同一个。
使当前协程进入阻塞状态并且按照通道锁逆序解锁所有的通道。
...，当前协程处于阻塞状态，等待其它协程通过通道操作唤醒当前协程，...
当前协程被另一个协程中的一个通道操作唤醒。 此唤醒通道操作可能是一个通道关闭操作，也可能是一个数据发送/接收操作。 如果它是一个数据发送/接收操作，则（当前正被解释的select-case流程中）肯定有一个相应case操作与之配合传递数据。 在此配合过程中，当前协程将从相应case操作相关的通道的接收/发送数据协程队列中弹出。
按照第3步中的生成的通道锁顺序获取所有相关的通道的锁。
将当前协程从各个case操作中对应的通道的发送数据协程队列或接收数据协程队列中（可能以非弹出的方式）移除。
如果当前协程是被一个通道关闭操作所唤醒，则跳到第5步。
如果当前协程是被一个数据发送/接收操作所唤醒，则相应的case分支已经在第9步中知晓。 按照通道锁逆序解锁所有的通道并执行此case分支代码块。
完毕。
从此实现中，我们得知
一个协程可能同时多次处于同一个通道的发送数据协程队列或接收数据协程队列中。
当一个协程被阻塞在一个select-case流程控制中并在以后被唤醒时，它可能会从多个通道的发送数据协程队列和接收数据协程队列中被移除。
 
## 方法
方法声明
在Go中，我们可以为类型T和*T显式地声明一个方法，其中类型T必须满足四个条件：
T必须是一个定义类型；
T必须和此方法声明定义在同一个代码包中；
T不能是一个指针类型；
T不能是一个接口类型。接口类型将在下一篇文章中讲解。
类型T和*T称为它们各自的方法的属主类型（receiver type）。 类型T被称作为类型T和*T声明的所有方法的属主基类型（receiver base type）。

注意：我们也可以为满足上列条件的类型T和*T的别名声明方法。 这样做的效果和直接为类型T和*T声明方法是一样的。

如果我们为某个类型声明了一个方法，以后我们可以说此类型拥有此方法。

从上面列出的条件，我们得知我们不能为下列类型（显式地）声明方法：
内置基本类型。比如int和string。 因为这些类型声明在内置builtin标准包中，而我们不能在标准包中声明方法。
接口类型。但是接口类型可以拥有方法。详见下一篇文章。
除了满足上面条件的形如*T的指针类型之外的无名组合类型。
一个方法声明和一个函数声明很相似，但是比函数声明多了一个额外的参数声明部分。 此额外的参数声明部分只能含有一个类型为此方法的属主类型的参数，此参数称为此方法声明的属主参数（receiver parameter）。 此属主参数声明必须包裹在一对小括号()之中。 此属主参数声明部分必须处于func关键字和方法名之间。

下面是一个方法声明的例子：
// Age和int是两个不同的类型。我们不能为int和*int
// 类型声明方法，但是可以为Age和*Age类型声明方法。
type Age int
func (age Age) LargerThan(a Age) bool {
return age > a
}
func (age *Age) Increase() {
*age++
}

// 为自定义的函数类型FilterFunc声明方法。
type FilterFunc func(in int) bool
func (ff FilterFunc) Filte(in int) bool {
return ff(in)
}

// 为自定义的映射类型StringSet声明方法。
type StringSet map[string]struct{}
func (ss StringSet) Has(key string) bool {
_, present := ss[key]
return present
}
func (ss StringSet) Add(key string) {
ss[key] = struct{}{}
}
func (ss StringSet) Remove(key string) {
delete(ss, key)
}

// 为自定义的结构体类型Book和它的指针类型*Book声明方法。

type Book struct {
pages int
}

func (b Book) Pages() int {
return b.pages
}

func (b *Book) SetPages(pages int) {
b.pages = pages
}
从上面的例子可以看出，我们可以为各种种类（kind）的类型声明方法，而不仅仅是结构体类型。

在很多其它面向对象的编程语言中，属主参数名总是为隐式声明的this或者self。这样的名称不推荐在Go编程中使用。

指针类型的属主参数称为指针类型属主，非指针类型的属主参数称为值类型属主。 在大多数情况下，我个人非常反对将指针和值这两个术语用做对立面，但是在这里，我并不反对这么用，原因将在下面谈及。

方法名可以是空标识符_。一个类型可以拥有若干名可以是空标识符的方法，但是这些方法无法被调用。 只有导出的方法才可以在其它代码包中调用。 方法调用将在后面的一节中介绍。

每个方法对应着一个隐式声明的函数
对每个方法声明，编译器将自动隐式声明一个相对应的函数。 比如对于上一节的例子中为类型Book和*Book声明的两个方法，编译器将自动声明下面的两个函数：
func Book.Pages(b Book) int {
return b.pages // 此函数体和Book类型的Pages方法体一样
}

func (*Book).SetPages(b *Book, pages int) {
b.pages = pages // 此函数体和*Book类型的SetPages方法体一样
}
在上面的两个隐式函数声明中，它们各自对应的方法声明的属主参数声明被插入到了普通参数声明的第一位。 它们的函数体和各自对应的显式方法的方法体是一样的。

两个隐式函数名Book.Pages和(*Book).SetPages都是aType.MethodName这种形式的。 我们不能显式声明名称为这种形式的函数，因为这种形式中的函数名不属于合法标识符。这样的函数只能由编译器隐式声明。 但是我们可以在代码中调用这些隐式声明的函数：
package main

import "fmt"

type Book struct {
pages int
}

func (b Book) Pages() int {
return b.pages
}

func (b *Book) SetPages(pages int) {
b.pages = pages
}

func main() {
var book Book
// 调用这两个隐式声明的函数。
(*Book).SetPages(&book, 123)
fmt.Println(Book.Pages(book)) // 123
}
事实上，在隐式声明上述两个函数的同时，编译器也将改写这两个函数对应的显式方法（至少，我们可以这样认为），让这两个方法在体内直接调用这两个隐式函数：
func (b Book) Pages() int {
return Book.Pages(b)
}

func (b *Book) SetPages(pages int) {
(*Book).SetPages(b, pages)
}
为指针类型属主隐式声明的方法
对每一个为值类型属主T声明的方法，一个相应的同名方法将自动隐式地为其对应的指针类型属主*T而声明。 以上面的为类型Book声明的Pages方法为例，一个同名方法将自动为类型*Book而声明：
// 注意：这不是合法的Go语法。这里这样表示只是
// 为了解释目的。它表明表达式(&aBook).Pages
// 将被估值为aBook.Pages（见随后几节）。
func (b *Book) Pages = (*b).Pages
正因为如此，我并不排斥使用值类型属主这个术语做为指针类型属主这个术语的对立面。 毕竟，当我们为一个非指针类型显式声明一个方法的时候，事实上两个方法被声明了。 一个方法是为非指针类型显式声明的，另一个是为指针类型隐式声明的。

上一节已经提到了，每一个方法对应着一个编译器隐式声明的函数。 所以对于刚提到的隐式方法，编译器也将隐式声明一个相应的函数：
func (*Book).Pages(b *Book) int {
return Book.Pages(*b)
}
换句话说，对于每一个为值类型属主显式声明的方法，同时将有一个隐式方法和两个隐式函数被自动声明。

方法描述（method specification）和方法集（method set）
一个方法描述可以看作是一个不带func关键字的函数原型。 我们可以把每个方法声明看作是由一个func关键字、一个属主参数声明部分、一个方法描述和一个方法体组成。

比如，上面的例子中的Pages和SetPages的描述如下：
Pages() int
SetPages(pages int)
每个类型都有个方法集。一个非接口类型的方法集由所有为它声明的（不管是显式的还是隐式的，但不包含方法名为空标识符的）方法的描述组成。 接口类型将在下一篇文章详述。

比如，在上面的例子中，Book类型的方法集为：
Pages() int
而*Book类型的方法集为：
Pages() int
SetPages(pages int)
方法集中的方法描述的次序并不重要。

对于一个方法集，如果其中的每个方法描述都处于另一个方法集中，则我们说前者方法集为后者（即另一个）方法集的子集，后者为前者的超集。 如果两个方法集互为子集（或超集），则这两个方法集必等价。

给定一个类型T，假设它既不是一个指针类型也不是一个接口类型，因为上一节中提到的原因，类型T的方法集总是类型*T的方法集的子集。 比如，在上面的例子中，Book类型的方法集为*Book类型的方法集的子集。

请注意：不同代码包中的同名非导出方法将总被认为是不同名的。

方法集在Go中的多态特性中扮演着重要的角色。多态将在下一篇文章中讲解。

下列类型的方法集总为空：
内置基本类型；
定义的指针类型；
基类型为指针类型或者接口类型的指针类型；
无名数组/切片/映射/函数/通道类型。
方法值和方法调用
方法事实上是特殊的函数。方法也常被称为成员函数。 当一个类型拥有一个方法，则此类型的每个值将拥有一个不可修改的函数类型的成员（类似于结构体的字段）。 此成员的名称为此方法名，它的类型和此方法的声明中不包括属主部分的函数声明的类型一致。 一个值的成员函数也可以称为此值的方法。

一个方法调用其实是调用了一个值的成员函数。假设一个值v有一个名为m的方法，则此方法可以用选择器语法形式v.m来表示。

下面这个例子展示了如何调用为Book和*Book类型声明的方法：
package main

import "fmt"

type Book struct {
pages int
}

func (b Book) Pages() int {
return b.pages
}

func (b *Book) SetPages(pages int) {
b.pages = pages
}

func main() {
var book Book

	fmt.Printf("%T \n", book.Pages)       // func() int
	fmt.Printf("%T \n", (&book).SetPages) // func(int)
	// &book值有一个隐式方法Pages。
	fmt.Printf("%T \n", (&book).Pages)    // func() int

	// 调用这三个方法。
	(&book).SetPages(123)
	book.SetPages(123)           // 等价于上一行
	fmt.Println(book.Pages())    // 123
	fmt.Println((&book).Pages()) // 123
}
（和C语言不同，Go中没有->操作符用来通过指针属主值来调用方法。(&book)->SetPages(123)在Go中是非法的。）

等一下，上例中的(&book).SetPages(123)一行为什么可以被简化为book.SetPages(123)呢？ 毕竟，类型Book并不拥有一个SetPages方法。 啊哈，这可以看作是Go中为了让代码看上去更简洁而特别设计的语法糖。此语法糖只对可寻址的值类型的属主有效。 编译器会隐式地将book.SetPages(123)改写为(&book).SetPages(123)。 但另一方面，我们应该总是认为aBookExpression.SetPages是一个合法的选择器（从语法层面讲），即使表达式aBookExpression被估值为一个不可寻址的Book值（在这种情况下，aBookExpression.SetPages是一个无效但合法的选择器）。

如上面刚提到的，当为一个类型声明了一个方法后，每个此类型的值将拥有一个和此方法同名的成员函数。 此类型的零值也不例外，不论此类型的零值是否用nil来表示。

一个例子：
package main

type StringSet map[string]struct{}
func (ss StringSet) Has(key string) bool {
_, present := ss[key] // 永不会产生恐慌，即使ss为nil。
return present
}

type Age int
func (age *Age) IsNil() bool {
return age == nil
}
func (age *Age) Increase() {
*age++ // 如果age是一个空指针，则此行将产生一个恐慌。
}

func main() {
_ = (StringSet(nil)).Has   // 不会产生恐慌
_ = ((*Age)(nil)).IsNil    // 不会产生恐慌
_ = ((*Age)(nil)).Increase // 不会产生恐慌

	_ = (StringSet(nil)).Has("key") // 不会产生恐慌
	_ = ((*Age)(nil)).IsNil()       // 不会产生恐慌

	// 下面这行将产生一个恐慌，但是此恐慌不是在调用方法的时
	// 候产生的，而是在此方法体内解引用空指针的时候产生的。
	((*Age)(nil)).Increase()
}
属主参数的传参是一个值复制过程
和普通参数传参一样，属主参数的传参也是一个值复制过程。 所以，在方法体内对属主参数的直接部分的修改将不会反映到方法体外。

一个例子：
package main

import "fmt"

type Book struct {
pages int
}

func (b Book) SetPages(pages int) {
b.pages = pages
}

func main() {
var b Book
b.SetPages(123)
fmt.Println(b.pages) // 0
}
另一个例子：
package main

import "fmt"

type Book struct {
pages int
}

type Books []Book

func (books Books) Modify() {
// 对属主参数的间接部分的修改将反映到方法之外。
books[0].pages = 500
// 对属主参数的直接部分的修改不会反映到方法之外。
books = append(books, Book{789})
}

func main() {
var books = Books{{123}, {456}}
books.Modify()
fmt.Println(books) // [{500} {456}]
}
有点题外话，如果将上例中Modify方法中的两行代码次序调换，那么此方法中的两处修改都不能反映到此方法之外。
func (books Books) Modify() {
books = append(books, Book{789})
books[0].pages = 500
}

func main() {
var books = Books{{123}, {456}}
books.Modify()
fmt.Println(books) // [{123} {456}]
}
这两处修改都不能反映到Modify方法之外的原因是append函数调用将开辟一块新的内存来存储它返回的结果切片的元素。 而此结果切片的前两个元素是属主参数切片的元素的副本。对此副本所做的修改不会反映到Modify方法之外。

为了将此两处修改反映到Modify方法之外，Modify方法的属主类型应该改为指针类型：
func (books *Books) Modify() {
*books = append(*books, Book{789})
(*books)[0].pages = 500
}

func main() {
var books = Books{{123}, {456}}
books.Modify()
fmt.Println(books) // [{500} {456} {789}]
}
方法值的正规化
在编译阶段，编译器将正规化各个方法值表达式。简而言之，正规化就是将方法值表达式中的隐式取地址和解引用操作均转换为显式操作。

假设值v的类型为T，并且v.m是一个合法的方法值表达式，
如果m是一个为类型*T显式声明的方法，那么编译器将把它正规化(&v).m；
如果m是一个为类型T显式声明的方法，那么v.m已经是一个正规化的方法值表达式。
假设值p的类型为*T，并且p.m是一个合法的方法值表达式，
如果m是一个为类型T显式声明的方法，那么编译器将把它正规化(*p).m；
如果m是一个为类型*T显式声明的方法，那么p.m已经是一个正规化的方法值表达式。
提升方法值的正规化将在随后的类型内嵌一文中解释。

方法值的估值
假设v.m是一个已经正规化的方法值表达式，在运行时刻，当v.m被估值的时候，属主实参v的估值结果的一个副本将被存储下来以供后面调用此方法值的时候使用。

以下面的代码为例：
b.Pages是一个已经正规化的方法值表达式。 在运行时刻对其进行估值时，属主实参b的一个副本将被存储下来。 此副本等于b的当前值：Book{pages: 123}，此后对b值的修改不影响此副本值。 这就是为什么调用f1()打印出123。
在编译时刻，方法值表达式p.Pages将被正规化为(*p).Pages。 在运行时刻，属主实参*p被估值为当前的b值，也就是Book{pages: 123}。 这就是为什么调用f2()也打印出123。
p.Pages2是一个已经正规化的方法值表达式。 在运行时刻对其进行估值时，属主实参p的一个副本将被存储下来，此副本的值为b值的地址。 当b被修改后，此修改可以通过对此地址值解引用而反映出来，这就是为什么调用g1()打印出789。
在编译时刻，方法值表达式b.Pages2将被正规化为(&b).Pages2。 在运行时刻，属主实参&b的估值结果的一个副本将被存储下来，此副本的值为b值的地址。 这就是为什么调用g2()也打印出789。
package main

import "fmt"

type Book struct {
pages int
}

func (b Book) Pages() int {
return b.pages
}

func (b *Book) Pages2() int {
return (*b).Pages()
}

func main() {
var b = Book{pages: 123}
var p = &b
var f1 = b.Pages
var f2 = p.Pages
var g1 = p.Pages2
var g2 = b.Pages2
b.pages = 789
fmt.Println(f1()) // 123
fmt.Println(f2()) // 123
fmt.Println(g1()) // 789
fmt.Println(g2()) // 789
}
一个定义类型不会获取为它的源类型显式声明的方法
举个例子，在下面的代码中，定义类型Age并不像它的源类型MyInt一样拥有一个IsOdd方法。
package main

type MyInt int
func (mi MyInt) IsOdd() bool {
return mi%2 == 1
}

type Age MyInt

func main() {
var x MyInt = 3
_ = x.IsOdd() // okay

	var y Age = 36
	// _ = y.IsOdd() // error: y.IsOdd undefined
	_ = y
}
如何决定一个方法声明使用值类型属主还是指针类型属主？
首先，从上一节中的例子，我们可以得知有时候我们必须在某些方法声明中使用指针类型属主。

事实上，我们总可以在方法声明中使用指针类型属主而不会产生任何逻辑问题。 我们仅仅是为了程序效率考虑有时候才会在函数声明中使用值类型属主。

对于值类型属主还是指针类型属主都可以接受的方法声明，下面列出了一些考虑因素：
太多的指针可能会增加垃圾回收器的负担。
如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。 指针类型都是小尺寸类型。 关于各种不同类型的尺寸，请阅读值复制代价一文。
在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争。
sync标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法。
如果实在拿不定主意在一个方法声明中应该使用值类型属主还是指针类型属主，那么请使用指针类型属主。

##  接口
接口类型介绍和类型集（Type Set）
一个接口类型定义了一些类型条件。 所有满足了全部这些条件的非接口类型形成了一个类型集合。 此类型集合称为此接口类型的类型集。

接口类型是通过内嵌若干接口元素来定义类型条件的。 目前（Go 1.20）支持两种接口元素：方法元素和类型元素。
一个方法元素呈现为一个方法描述（method specification）。 内嵌在接口类型中的方法描述不能使用空标识符_命名。
一个类型元素可以是一个类型名称、一个类型字面表示形式、一个近似类型或者一个类型并集。 本文不过多介绍后两者。对于前两者，也只谈及当它们表示接口类型的情况。
举个例子，预声明的error接口类型的定义如下。 它内嵌了一个方法描述Error() string。 在此定义中，interface{...}称为接口类型的字面表示形式，其中interface为一个关键字。

type error interface {
Error() string
}
我们可以说此error接口类型（直接）指定了一个方法（描述）：Error() string。 它的类型集由所有拥有此同样描述的方法的非接口类型组成。 理论上，此类型集是一个无限集。当然对于一个具体的Go项目，此集合是有限的。

下面是一些其它接口类型定义和别名声明。

// 此接口直接指定了两个方法和内嵌了两个其它接口。
// 其中一个为类型名称，另一个为类型字面表示形式。
type ReadWriteCloser = interface {
Read(buf []byte) (n int, err error)
Write(buf []byte) (n int, err error)
error                      // 一个类型名称
interface{ Close() error } // 一个类型字面表示形式
}

// 此接口类型内嵌了一个近似类型。
// 它的类型集由所有底层类型为[]byte的类型组成。
type AnyByteSlice = interface {
~[]byte
}

// 此接口类型内嵌了一个类型并集。它的类型集包含6个类型：
// uint、uint8、uint16、uint32、uint64和uintptr。
type Unsigned interface {
uint | uint8 | uint16 | uint32 | uint64 | uintptr
}
将一个接口类型（无论呈现为类型名称还是类型字面表示形式）内嵌到另一个接口类型中等价于将前者中的元素（递归）展开放入后者。 比如，别名ReadWriteCloser表示的接口类型等价于下面这个类型字面表示形式表示的直接指定了4个方法的接口类型。

interface {
Read(buf []byte) (n int, err error)
Write(buf []byte) (n int, err error)
Error() string
Close() error
}
上面这个接口类型（即别名ReadWriteCloser表示的接口类型）的类型集由所有拥有全部这4个指定方法的非接口类型组成。 从理论上，这也是一个无限集。它肯定是error接口类型的类型集的子集。

请注意：在Go 1.18之前，只有接口类型名称可以内嵌在接口类型中。

下面的代码片段中展示的接口类型都称为空接口类型。它们什么也没有内嵌。

// 一个无名空接口类型。
interface{}

// Nothing是一个定义空接口类型。
type Nothing interface{}
事实上，Go 1.18引入了一个预声明的类型别名any，用来表示空接口类型interface{}。

一个空接口类型的类型集由所有由非接口类型组成。

类型的方法集
每个类型有一个方法集。
对于一个非接口类型，它的方法集由为此类型（无论显式还是隐式）声明 所有方法的方法描述组成。
对于一个接口类型，它的方法集由此接口类型（无论直接还是间接）指定的所有方法描述组成。
对于上一节中提到的接口类型，
别名ReadWriteCloser表示的接口类型的方法集包含4个方法（描述）。
预声明的error接口类型的方法集包含一个方法（描述）。
一个空接口类型的方法集为空。
为了方便起见，一个类型的方法集常常也称为此方法的任何一个值的方法集。

基本接口类型
基本接口类型是指可以用做值类型的接口类型。 一个非基本接口类型只能为用做（自定义泛型中使用的）约束接口类型（即类型约束）。

目前（Go 1.20），每一个基本接口类型都可以使用一个方法集来完全定义。 换句话说，一个基本接口类型不需要内嵌任何类型元素。

在上上一节中的例子中，别名ReadWriteCloser表示的接口类型为一个基本接口类型， 但是Unsigned接口类型和别名AnyByteSlice表示的接口类型均不是基本接口类型。 后两者均只能用做约束接口类型。

空接口类型和预声明的error接口类型也都是基本接口类型。

如果两个无名基本接口类型的方法集是相同的，则这两个类型肯定为同一个类型。 但是请注意：不同代码包中的同名非导出方法名将总被认为是不同名的。

类型实现（implementation）
如果一个非接口类型处于一个接口类型的类型集中，则我们说此非接口类型实现了此接口类型。 如果一个接口类型的类型集是另一个接口类型的类型集的子集，则我们说前者实现了后者。

因为一个类型集的总是它自己的子集，一个接口类型总是实现了它自己。 类似地，如果两个接口类型的类型集相同，则它们相互实现了对方。 事实上，两个拥有相同类型集的无名接口类型为同一个接口类型。

如果一个（接口或者非接口）类型T实现了一个接口类型X，那么类型T的方法集肯定是接口类型X的方法集的超集。 一般说来，反之并不成立。但是如果X是一个基本接口类型，则反之也成立。 比如，在前面的例子中，别名ReadWriteCloser表示的接口类型实现了预声明的error接口类型。

在Go中，实现关系是隐式的。 两个类型之间的实现关系不需要在代码中显式地表示出来。 Go中没有类似于implements的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。

比如，在下面的例子中，类型*Book、MyInt和*MyInt都拥有一个描述为About() string的方法，所以它们都实现了接口类型Aboutable。
type Aboutable interface {
About() string
}

type Book struct {
name string
// 更多其它字段……
}

func (book *Book) About() string {
return "Book: " + book.name
}

type MyInt int

func (MyInt) About() string {
return "我是一个自定义整数类型"
}
隐式实现关系的设计使得一个声明在另一个代码包（包括标准库包）中的类型可以被动地实现一个用户代码包中的接口类型。 比如，如果我们声明一个像下面这样的接口类型，则database/sql标准库包中声明的DB和Tx类型都实现了这个接口类型，因为它们都拥有此接口类型指定的三个方法。

import "database/sql"

...

type DatabaseStorer interface {
Exec(query string, args ...interface{}) (sql.Result, error)
Prepare(query string) (*sql.Stmt, error)
Query(query string, args ...interface{}) (*sql.Rows, error)
}
注意：因为空接口类型的类型集包含了所有的非接口类型，所以所有类型均实现了空接口类型。 这是Go中的一个重要事实。

值包裹
重申一遍：目前（Go 1.20），接口值的类型必须为一个基本接口类型。 在本文余下的内容里，当一个值类型被提及，此值类型可能是一个非接口类型，也可能是一个基本接口类型，但它肯定不是一个非基本接口类型。

每个接口值都可以看作是一个用来包裹一个非接口值的盒子。 欲将一个非接口值包裹在一个接口值中，此非接口值的类型必须实现了此接口值的类型。

在Go中，如果类型T实现了一个（基本）接口类型I，则类型T的值都可以隐式转换到类型I。 换句话说，类型T的值可以赋给类型I的可修改值。 当一个T值被转换到类型I（或者赋给一个I值）的时候，
如果类型T是一个非接口类型，则此T值的一个复制将被包裹在结果（或者目标）I值中。 此操作的时间复杂度为O(n)，其中n为T值的尺寸。
如果类型T也为一个接口类型，则此T值中当前包裹的（非接口）值将被复制一份到结果（或者目标）I值中。 官方标准编译器为此操作做了优化，使得此操作的时间复杂度为O(1)，而不是O(n)。
包裹在一个接口值中的非接口值的类型信息也和此非接口值一起被包裹在此接口值中（见下面详解）。

当一个非接口值被包裹在一个接口值中，此非接口值称为此接口值的动态值，此非接口值的类型称为此接口值的动态类型。

接口值的动态值的直接部分是不可修改的，除非它的动态值被整体替换为另一个动态值。

接口类型的零值也用预声明的nil标识符来表示。 一个nil接口值中什么也没包裹。将一个接口值修改为nil将清空包裹在此接口值中的非接口值。

（注意，在Go中，很多其它非接口类型的零值也使用nil标识符来表示。 非接口类型的nil零值也可以被包裹在接口值中。 一个包裹了一个nil非接口值的接口值不是一个nil接口值，因为它并非什么都没包裹。）

因为任何类型都实现了空接口类型，所以任何非接口值都可以被包裹在任何一个空接口类型的接口值中。 （以后，一个空接口类型的接口值将被称为一个空接口值。注意空接口值和nil接口值是两个不同的概念。） 因为这个原因，空接口值可以被认为是很多其它语言中的any类型。

当一个类型不确定值（除了类型不确定的nil）被转换为一个空接口类型（或者赋给一个空接口值），此类型不确定值将首先转换为它的默认类型。 （或者说，此类型不确定值将被推断为一个它的默认类型的类型确定值。）

下面这个例子展示了一些目标值为接口类型的赋值。
package main

import "fmt"

type Aboutable interface {
About() string
}

// 类型*Book实现了接口类型Aboutable。
type Book struct {
name string
}
func (book *Book) About() string {
return "Book: " + book.name
}

func main() {
// 一个*Book值被包裹在了一个Aboutable值中。
var a Aboutable = &Book{"Go语言101"}
fmt.Println(a) // &{Go语言101}

	// i是一个空接口值。类型*Book实现了任何空接口类型。
	var i interface{} = &Book{"Rust 101"}
	fmt.Println(i) // &{Rust 101}

	// Aboutable实现了空接口类型interface{}。
	i = a
	fmt.Println(i) // &{Go语言101}
}
请注意，在之前的文章中多次使用过的fmt.Println函数的原型为：
func Println(a ...interface{}) (n int, err error)
这解释了为什么任何类型的实参都可以使用在fmt.Println函数调用中。

下面是另一个展示了一个空接口类型的值包裹着各种非接口值的例子：
package main

import "fmt"

func main() {
var i interface{}
i = []int{1, 2, 3}
fmt.Println(i) // [1 2 3]
i = map[string]int{"Go": 2012}
fmt.Println(i) // map[Go:2012]
i = true
fmt.Println(i) // true
i = 1
fmt.Println(i) // 1
i = "abc"
fmt.Println(i) // abc

	// 将接口值i中包裹的值清除掉。
	i = nil
	fmt.Println(i) // <nil>
}
在编译时刻，Go编译器将构建一个全局表用来存储代码中要用到的各个类型的信息。 对于一个类型来说，这些信息包括：此类型的种类（kind）、此类型的所有方法和字段信息、此类型的尺寸，等等。 这个全局表将在程序启动的时候被加载到内存中。

在运行时刻，当一个非接口值被包裹到一个接口值，Go运行时（至少对于官方标准运行时来说）将分析和构建这两个值的类型的实现关系信息，并将此实现关系信息存入到此接口值内。 对每一对这样的类型，它们的实现关系信息将仅被最多构建一次。并且为了程序效率考虑，此实现关系信息将被缓存在内存中的一个全局映射中，以备后用。 所以此全局映射中的条目数永不减少。 事实上，一个非零接口值在内部只是使用一个指针字段来引用着此全局映射中的一个实现关系信息条目。

对于一个非接口类型和接口类型对，它们的实现关系信息包括两部分的内容：
动态类型（即此非接口类型）的信息。
一个方法表（切片类型），其中存储了所有此接口类型指定的并且为此非接口类型（动态类型）声明的方法。
这两部分的内容对于实现Go中的两个特性起着至关重要的作用。
动态类型信息是实现反射的关键。
方法表是实现多态（见下一节）的关键。
多态（polymorphism）
多态是接口的一个关键功能和Go语言的一个重要特性。

当非接口类型T的一个值t被包裹在接口类型I的一个接口值i中，通过i调用接口类型I指定的一个方法时，事实上为非接口类型T声明的对应方法将通过非接口值t被调用。 换句话说，调用一个接口值的方法实际上将调用此接口值的动态值的对应方法。 比如，当方法i.m被调用时，其实被调用的是方法t.m。 一个接口值可以通过包裹不同动态类型的动态值来表现出各种不同的行为，这称为多态。

当方法i.m被调用时，i存储的实现关系信息的方法表中的方法t.m将被找到并被调用。 此方法表是一个切片，所以此寻找过程只不过是一个切片元素访问操作，不会消耗很多时间。

注意，在nil接口值上调用方法将产生一个恐慌，因为没有具体的方法可被调用。

一个例子：
package main

import "fmt"

type Filter interface {
About() string
Process([]int) []int
}

// UniqueFilter用来删除重复的数字。
type UniqueFilter struct{}
func (UniqueFilter) About() string {
return "删除重复的数字"
}
func (UniqueFilter) Process(inputs []int) []int {
outs := make([]int, 0, len(inputs))
pusheds := make(map[int]bool)
for _, n := range inputs {
if !pusheds[n] {
pusheds[n] = true
outs = append(outs, n)
}
}
return outs
}

// MultipleFilter用来只保留某个整数的倍数数字。
type MultipleFilter int
func (mf MultipleFilter) About() string {
return fmt.Sprintf("保留%v的倍数", mf)
}
func (mf MultipleFilter) Process(inputs []int) []int {
var outs = make([]int, 0, len(inputs))
for _, n := range inputs {
if n % int(mf) == 0 {
outs = append(outs, n)
}
}
return outs
}

// 在多态特性的帮助下，只需要一个filteAndPrint函数。
func filteAndPrint(fltr Filter, unfiltered []int) []int {
// 在fltr参数上调用方法其实是调用fltr的动态值的方法。
filtered := fltr.Process(unfiltered)
fmt.Println(fltr.About() + ":\n\t", filtered)
return filtered
}

func main() {
numbers := []int{12, 7, 21, 12, 12, 26, 25, 21, 30}
fmt.Println("过滤之前：\n\t", numbers)

	// 三个非接口值被包裹在一个Filter切片
	// 的三个接口元素中。
	filters := []Filter{
		UniqueFilter{},
		MultipleFilter(2),
		MultipleFilter(3),
	}

	// 每个切片元素将被赋值给类型为Filter的
	// 循环变量fltr。每个元素中的动态值也将
	// 被同时复制并被包裹在循环变量fltr中。
	for _, fltr := range filters {
		numbers = filteAndPrint(fltr, numbers)
	}
}
输出结果：
过滤之前：
[12 7 21 12 12 26 25 21 30]
删除重复的数字:
[12 7 21 26 25 30]
保留2的倍数:
[12 26 30]
保留3的倍数:
[12 30]
在上面这个例子中，多态使得我们不必为每个过滤器类型写一个单独的filteAndPrint函数。

除了上述这个好处，多态也使得一个代码包的开发者可以在此代码包中声明一个接口类型并声明一个拥有此接口类型参数的函数（或者方法），从而此代码包的一个用户可以在用户包中声明一个实现了此接口类型的用户类型，并且将此用户类型的值做为实参传递给此代码包中声明的函数（或者方法）的调用。 此代码包的开发者并不用关心一个用户类型具体是如何声明的，只要此用户类型满足此代码包中声明的接口类型规定的行为即可。

事实上，多态对于一个语言来说并非一个不可或缺的特性。我们可以通过其它途径来实现多态的作用。 但是，多态可以使得我们的代码更加简洁和优雅。

反射（reflection）
一个接口值中存储的动态类型信息可以被用来检视此接口值的动态值和操纵此动态值所引用的值。 这称为反射。

本篇文章将不介绍reflect标准包中提供的各种反射功能。 请阅读后面的Go中的反射一文来了解如何使用此包。 本文下面将只介绍Go中的内置反射机制。在Go中，内置反射机制包括类型断言（type assertion）和type-switch流程控制代码块。

类型断言
Go中有四种接口相关的类型转换情形：
将一个非接口值转换为一个接口类型。在这样的转换中，此非接口值的类型必须实现了此接口类型。
将一个接口值转换为另一个接口类型（前者接口值的类型实现了后者目标接口类型）。
将一个接口值转换为一个非接口类型（此非接口类型必须实现了此接口值的接口类型）。
将一个接口值转换为另一个接口类型（前者接口值的类型未实现后者目标接口类型，但是前者的动态类型有可能实现了目标接口类型）。
前两种情形已经在前面几节中介绍过了。这两种情形都要求源值的类型必须实现了目标接口类型。 它们都是通过普通类型转换（无论是隐式的还是显式的）来达成的。这两种情形的合法性是在编译时刻验证的。

本节将介绍后两种情形。这两种情形的合法性是在运行时刻通过类型断言来验证的。 事实上，类型断言也适用于上面列出的第二种情形。

一个类型断言表达式的语法为i.(T)，其中i为一个接口值，T为一个类型名或者类型字面表示。 类型T可以为
任意一个非接口类型。
或者一个任意接口类型。
在一个类型断言表达式i.(T)中，i称为断言值，T称为断言类型。 一个断言可能成功或者失败。
对于T是一个非接口类型的情况，如果断言值i的动态类型存在并且此动态类型和T为同一类型，则此断言将成功；否则，此断言失败。 当此断言成功时，此类型断言表达式的估值结果为断言值i的动态值的一个复制。 我们可以把此种情况看作是一次拆封动态值的尝试。
对于T是一个接口类型的情况，当断言值i的动态类型存在并且此动态类型实现了接口类型T，则此断言将成功；否则，此断言失败。 当此断言成功时，此类型断言表达式的估值结果为一个包裹了断言值i的动态值的一个复制的T值。
一个失败的类型断言的估值结果为断言类型的零值。

按照上述规则，如果一个类型断言中的断言值是一个零值nil接口值，则此断言必定失败。

对于大多数场合，一个类型断言被用做一个单值表达式。 但是，当一个类型断言被用做一个赋值语句中的唯一源值时，此断言可以返回一个可选的第二个结果并被视作为一个多值表达式。 此可选的第二个结果为一个类型不确定的布尔值，用来表示此断言是否成功了。

注意：如果一个断言失败并且它的可选的第二个结果未呈现，则此断言将造成一个恐慌。

一个展示了如何使用类型断言的例子（断言类型为非接口类型）：
package main

import "fmt"

func main() {
// 编译器将把123的类型推断为内置类型int。
var x interface{} = 123

	// 情形一：
	n, ok := x.(int)
	fmt.Println(n, ok) // 123 true
	n = x.(int)
	fmt.Println(n) // 123

	// 情形二：
	a, ok := x.(float64)
	fmt.Println(a, ok) // 0 false

	// 情形三：
	a = x.(float64) // 将产生一个恐慌
}
另一个展示了如何使用类型断言的例子（断言类型为接口类型）：
package main

import "fmt"

type Writer interface {
Write(buf []byte) (int, error)
}

type DummyWriter struct{}
func (DummyWriter) Write(buf []byte) (int, error) {
return len(buf), nil
}

func main() {
var x interface{} = DummyWriter{}
// y的动态类型为内置类型string。
var y interface{} = "abc"
var w Writer
var ok bool

	// DummyWriter既实现了Writer，也实现了interface{}。
	w, ok = x.(Writer)
	fmt.Println(w, ok) // {} true
	x, ok = w.(interface{})
	fmt.Println(x, ok) // {} true

	// y的动态类型为string。string类型并没有实现Writer。
	w, ok = y.(Writer)
	fmt.Println(w, ok) // <nil> false
	w = y.(Writer)     // 将产生一个恐慌
}
事实上，对于一个动态类型为T的接口值i，方法调用i.m(...)等价于i.(T).m(...)。

type-switch流程控制代码块
type-switch流程控制的语法或许是Go中最古怪的语法。 它可以被看作是类型断言的增强版。它和switch-case流程控制代码块有些相似。 一个type-switch流程控制代码块的语法如下所示：
switch aSimpleStatement; v := x.(type) {
case TypeA:
...
case TypeB, TypeC:
...
case nil:
...
default:
...
}
其中aSimpleStatement;部分是可选的。 aSimpleStatement必须是一个简单语句。 x必须为一个估值结果为接口值的表达式，它称为此代码块中的断言值。 v称为此代码块中的断言结果，它必须出现在一个短变量声明形式中。

在一个type-switch代码块中，每个case关键字后可以跟随预声明的nil标识符或者一个由逗号分割的若干个类型名和类型字面表示形式组成的类型列表。 在同一个type-switch代码块中，这些跟随在所有case关键字后的条目不可重复。

如果跟随在某个case关键字后的条目为一个非接口类型（用一个类型名或类型字面表示），则此非接口类型必须实现了断言值x的（接口）类型。

下面是一个使用了type-switch代码块的例子：
package main

import "fmt"

func main() {
values := []interface{}{
456, "abc", true, 0.33, int32(789),
[]int{1, 2, 3}, map[int]bool{}, nil,
}
for _, x := range values {
// 这里，虽然变量v只被声明了一次，但是它在
// 不同分支中可以表现为多个类型的变量值。
switch v := x.(type) {
case []int: // 一个类型字面表示
// 在此分支中，v的类型为[]int。
fmt.Println("int slice:", v)
case string: // 一个类型名
// 在此分支中，v的类型为string。
fmt.Println("string:", v)
case int, float64, int32: // 多个类型名
// 在此分支中，v的类型为x的类型interface{}。
fmt.Println("number:", v)
case nil:
// 在此分支中，v的类型为x的类型interface{}。
fmt.Println(v)
default:
// 在此分支中，v的类型为x的类型interface{}。
fmt.Println("others:", v)
}
// 注意：在最后的三个分支中，v均为接口值x的一个复制。
}
}
输出结果：
number: 456
string: abc
others: true
number: 0.33
number: 789
int slice: [1 2 3]
others: map[]
<nil>
上面这个例子程序在逻辑上等价于下面这个：
package main

import "fmt"

func main() {
values := []interface{}{
456, "abc", true, 0.33, int32(789),
[]int{1, 2, 3}, map[int]bool{}, nil,
}
for _, x := range values {
if v, ok := x.([]int); ok {
fmt.Println("int slice:", v)
} else if v, ok := x.(string); ok {
fmt.Println("string:", v)
} else if x == nil {
v := x
fmt.Println(v)
} else {
_, isInt := x.(int)
_, isFloat64 := x.(float64)
_, isInt32 := x.(int32)
if isInt || isFloat64 || isInt32 {
v := x
fmt.Println("number:", v)
} else {
v := x
fmt.Println("others:", v)
}
}
}
}
如果我们不关心一个type-switch代码块中的断言结果，则此type-switch代码块可简写为switch x.(type) {...}。

type-switch代码块和switch-case代码块有很多共同点：
在一个type-switch代码块中，最多只能有一个default分支存在。
在一个type-switch代码块中，如果default分支存在，它可以为最后一个分支、第一个分支或者中间的某个分支。
一个type-switch代码块可以不包含任何分支，它可以被视为一个空操作。
但是，和switch-case代码块不一样，fallthrough语句不能使用在type-switch代码块中。

更多接口相关的内容
接口值相关的比较
接口值相关的比较有两种情形：
比较一个非接口值和接口值；
比较两个接口值。
对于第一种情形，非接口值的类型必须实现了接口值的类型（假设此接口类型为I），所以此非接口值可以被隐式转化为（包裹到）一个I值中。 这意味着非接口值和接口值的比较可以转化为两个接口值的比较。所以下面我们只探讨两个接口值比较的情形。

比较两个接口值其实是比较这两个接口值的动态类型和和动态值。

下面是（使用==比较运算符）比较两个接口值的步骤：
如果其中一个接口值是一个nil接口值，则比较结果为另一个接口值是否也为一个nil接口值。
如果这两个接口值的动态类型不一样，则比较结果为false。
对于这两个接口值的动态类型一样的情形，
如果它们的动态类型为一个不可比较类型，则将产生一个恐慌。
否则，比较结果为它们的动态值的比较结果。
简而言之，两个接口值的比较结果只有在下面两种任一情况下才为true：
这两个接口值都为nil接口值。
这两个接口值的动态类型相同、动态类型为可比较类型、并且动态值相等。
根据此规则，两个包裹了不同非接口类型的nil零值的接口值是不相等的。 一个例子：
package main

import "fmt"

func main() {
var a, b, c interface{} = "abc", 123, "a"+"b"+"c"
fmt.Println(a == b) // 第二步的情形。输出"false"。
fmt.Println(a == c) // 第三步的情形。输出"true"。

	var x *int = nil
	var y *bool = nil
	var ix, iy interface{} = x, y
	var i interface{} = nil
	fmt.Println(ix == iy) // 第二步的情形。输出"false"。
	fmt.Println(ix == i)  // 第一步的情形。输出"false"。
	fmt.Println(iy == i)  // 第一步的情形。输出"false"。

	var s []int = nil // []int为一个不可比较类型。
	i = s
	fmt.Println(i == nil) // 第一步的情形。输出"false"。
	fmt.Println(i == i)   // 第三步的情形。将产生一个恐慌。
}
接口值的内部结构
对于标准编译器/运行时，空接口值和非空接口值是使用两种内部结构来表示的。 详情请阅读值部一文。

指针动态值和非指针动态值
标准编译器/运行时对接口值的动态值为指针类型的情况做了特别的优化。 此优化使得接口值包裹指针动态值比包裹非指针动态值的效率更高。 对于小尺寸值，此优化的作用不大； 但是对于大尺寸值，包裹它的指针比包裹此值本身的效率高得多。 对于类型断言，此结论亦成立。

所以尽量避免在接口值中包裹大尺寸值。对于大尺寸值，应该尽量包裹它的指针。

一个[]T类型的值不能直接被转换为类型[]I，即使类型T实现了接口类型I
比如，我们不能直接将一个[]string值转换为类型[]interface{}。 我们必须使用一个循环来实现此转换：
package main

import "fmt"

func main() {
words := []string{
"Go", "is", "a", "high",
"efficient", "language.",
}

	// fmt.Println函数的原型为：
	// func Println(a ...interface{}) (n int, err error)
	// 所以words...不能传递给此函数的调用。

	// fmt.Println(words...) // 编译不通过

	// 将[]string值转换为类型[]interface{}。
	iw := make([]interface{}, 0, len(words))
	for _, w := range words {
		iw = append(iw, w)
	}
	fmt.Println(iw...) // 编译没问题
}
一个接口类型每个指定的每一个方法都对应着一个隐式声明的函数
如果接口类型I指定了一个名为m的方法描述，则编译器将隐式声明一个与之对应的函数名为I.m的函数。 此函数比m的方法描述中的参数多一个。此多出来的参数为函数I.m的第一个参数，它的类型为I。 对于一个类型为I的值i，方法调用i.m(...)和函数调用I.m(i, ...)是等价的。

一个例子：
package main

import "fmt"

type I interface {
m(int)bool
}

type T string
func (t T) m(n int) bool {
return len(t) > n
}

func main() {
var i I = T("gopher")
fmt.Println(i.m(5))                          // true
fmt.Println(I.m(i, 5))                       // true
fmt.Println(interface {m(int) bool}.m(i, 5)) // true

	// 下面这几行被执行的时候都将会产生一个恐慌。
	I(nil).m(5)
	I.m(nil, 5)
	interface {m(int) bool}.m(nil, 5)
}

## 类型内嵌
类型内嵌语法
下面是一个使用了类型内嵌的例子：
package main

import "net/http"

func main() {
type P = *bool
type M = map[int]int
var x struct {
string // 一个具名非指针类型
error  // 一个具名接口类型
*int   // 一个无名指针类型
P      // 一个无名指针类型的别名
M      // 一个无名类型的别名

		http.Header // 一个具名映射类型
	}
	x.string = "Go"
	x.error = nil
	x.int = new(int)
	x.P = new(bool)
	x.M = make(M)
	x.Header = http.Header{}
}
在上面这个例子中，有六个类型被内嵌在了一个结构体类型中。每个类型内嵌形成了一个内嵌字段（embedded field）。

因为历史原因，内嵌字段有时也称为匿名字段。但是，事实上，每个内嵌字段有一个（隐式的）名字。 此字段的非限定（unqualified）类型名即为此字段的名称。 比如，上例中的六个内嵌字段的名称分别为string、error、int、P、M和Header。

哪些类型可以被内嵌？
当前的Go白皮书（1.20）规定：
An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type.
翻译过来：
一个内嵌字段必须被声明为形式T或者一个基类型为非接口类型的指针类型*T，其中T为一个类型名但是T不能表示一个指针类型。
此规则描述在Go 1.9之前是精确的。但是随着从Go 1.9引入的自定义类型别名概念，此描述有些过时和不太准确了。 比如，此描述没有包括上一节的例子中的P内嵌字段的情形。

这里，本文试图使用一个更精确的描述：
一个类型名T只有在它既不表示一个具名指针类型也不表示一个基类型为指针类型或者接口类型的指针类型的情况下才可以被用做内嵌字段。
一个指针类型*T只有在T为一个类型名并且T既不表示一个指针类型也不表示一个接口类型的时候才能被用做内嵌字段。
下面列出了一些可以被或不可以被内嵌的类型或别名：
type Encoder interface {Encode([]byte) []byte}
type Person struct {name string; age int}
type Alias = struct {name string; age int}
type AliasPtr = *struct {name string; age int}
type IntPtr *int
type AliasPP = *IntPtr

// 这些类型或别名都可以被内嵌。
Encoder
Person
*Person
Alias
*Alias
AliasPtr
int
*int

// 这些类型或别名都不能被内嵌。
AliasPP          // 基类型为一个指针类型
*Encoder         // 基类型为一个接口类型
*AliasPtr        // 基类型为一个指针类型
IntPtr           // 具名指针类型
*IntPtr          // 基类型为一个指针类型
*chan int        // 基类型为一个无名类型
struct {age int} // 无名非指针类型
map[string]int   // 无名非指针类型
[]int64          // 无名非指针类型
func()           // 无名非指针类型
一个结构体类型中不允许有两个同名字段，此规则对匿名字段同样适用。 根据上述内嵌字段的隐含名称规则，一个无名指针类型不能和它的基类型同时内嵌在同一个结构体类型中。 比如，int和*int类型不能同时内嵌在同一个结构体类型中。

一个结构体类型不能内嵌（无论间接还是直接）它自己。

一般说来，只有内嵌含有字段或者拥有方法的类型才有意义（后续几节将阐述原因），尽管很多既没有字段也没有方法的类型也可以被内嵌。

类型内嵌的意义是什么？
类型内嵌的主要目的是为了将被内嵌类型的功能扩展到内嵌它的结构体类型中，从而我们不必再为此结构体类型重复实现被内嵌类型的功能。

很多其它流行面向对象的编程语言都是用继承来实现上述目的。两种实现方式有它们各自的利弊。 这里，此篇文章将不讨论哪种方式更好一些，我们只需知道Go选择了类型内嵌这种方式。 这两种方式有一个很大的不同点：
如果类型T继承了另外一个类型，则类型T获取了另外一个类型的能力。 同时，一个T类型的值也可以被当作另外一个类型的值来使用。
如果一个类型T内嵌了另外一个类型，则另外一个类型变成了类型T的一部分。 类型T获取了另外一个类型的能力，但是T类型的任何值都不能被当作另外一个类型的值来使用。
下面是一个展示了如何通过类型内嵌来扩展类型功能的例子：
package main

import "fmt"

type Person struct {
Name string
Age  int
}
func (p Person) PrintName() {
fmt.Println("Name:", p.Name)
}
func (p *Person) SetAge(age int) {
p.Age = age
}

type Singer struct {
Person // 通过内嵌Person类型来扩展之
works  []string
}

func main() {
var gaga = Singer{Person: Person{"Gaga", 30}}
gaga.PrintName() // Name: Gaga
gaga.Name = "Lady Gaga"
(&gaga).SetAge(31)
(&gaga).PrintName()   // Name: Lady Gaga
fmt.Println(gaga.Age) // 31
}
从上例中，当类型Singer内嵌了类型Person之后，看上去类型Singer获取了类型Person所有的字段和方法， 并且类型*Singer获取了类型*Person所有的方法。此结论是否正确？随后几节将给出答案。

注意，类型Singer的一个值不能被当作Person类型的值用。下面的代码编译不通过：
var gaga = Singer{}
var _ Person = gaga
当一个结构体类型内嵌了另一个类型，此结构体类型是否获取了被内嵌类型的字段和方法？
下面这个程序使用反射列出了上一节的例子中的Singer类型的字段和方法，以及*Singer类型的方法。
package main

import (
"fmt"
"reflect"
)

... // 为节省篇幅，上一个例子中声明的类型在这里省略了。

func main() {
t := reflect.TypeOf(Singer{}) // the Singer type
fmt.Println(t, "has", t.NumField(), "fields:")
for i := 0; i < t.NumField(); i++ {
fmt.Print(" field#", i, ": ", t.Field(i).Name, "\n")
}
fmt.Println(t, "has", t.NumMethod(), "methods:")
for i := 0; i < t.NumMethod(); i++ {
fmt.Print(" method#", i, ": ", t.Method(i).Name, "\n")
}

	pt := reflect.TypeOf(&Singer{}) // the *Singer type
	fmt.Println(pt, "has", pt.NumMethod(), "methods:")
	for i := 0; i < pt.NumMethod(); i++ {
		fmt.Print(" method#", i, ": ", pt.Method(i).Name, "\n")
	}
}
输出结果：
main.Singer has 2 fields:
field#0: Person
field#1: works
main.Singer has 1 methods:
method#0: PrintName
*main.Singer has 2 methods:
method#0: PrintName
method#1: SetAge
从此输出结果中，我们可以看出类型Singer确实拥有一个PrintName方法，以及类型*Singer确实拥有两个方法：PrintName和SetAge。 但是类型Singer并不拥有一个Name字段。那么为什么选择器表达式gaga.Name是合法的呢？ 毕竟gaga是Singer类型的一个值。 请阅读下一节以获取原因。

选择器的缩写形式
从前面的结构体和方法两篇文章中，我们得知，对于一个值x，x.y称为一个选择器，其中y可以是一个字段名或者方法名。 如果y是一个字段名，那么x必须为一个结构体值或者结构体指针值。 一个选择器是一个表达式，它表示着一个值。 如果选择器x.y表示一个字段，此字段也可能拥有自己的字段（如果此字段的类型为另一个结构体类型）和方法，比如x.y.z，其中z可以是一个字段名，也可是一个方法名。

在Go中，（不考虑下面将要介绍的选择器碰撞和遮挡），如果一个选择器中的中部某项对应着一个内嵌字段，则此项可被省略掉。 因此内嵌字段又被称为匿名字段。

一个例子：
package main

type A struct {
x int
}

func (a A) MethodA() {}

type B struct {
*A
}

type C struct {
B
}

func main() {
var c = &C{B: B{A: &A{FieldX: 5}}}

	// 这几行是等价的。
	_ = c.B.A.FieldX
	_ = c.B.FieldX
	_ = c.A.FieldX // A是类型C的一个提升字段
	_ = c.FieldX   // FieldX也是一个提升字段

	// 这几行是等价的。
	c.B.A.MethodA()
	c.B.MethodA()
	c.A.MethodA()
	c.MethodA() // MethodA是类型C的一个提升方法
}
这就是为什么在上一节的例子中选择器表达式gaga.Name是合法的， 因为它只不过是gaga.Person.Name的一个缩写形式。

类似的，选择器gaga.PrintName可以被看作是gaga.Person.PrintName的缩写形式。 但是，我们也可以不把它看作是一个缩写。毕竟，类型Singer确实拥有一个PrintName方法， 尽管此方法是被隐式声明的（请阅读下下节以获得详情）。 同样的原因，选择器(&gaga).PrintName和(&gaga).SetAge可以看作（也可以不看作）是(&gaga.Person).PrintName和(&gaga.Person).SetAge的缩写。

Name被称为类型Singer的一个提升字段（promoted field）。 PrintName被称为类型Singer的一个提升方法（promoted method）。

注意：我们也可以使用选择器gaga.SetAge，但是只有在gaga是一个可寻址的类型为Singer的值的情况下。 它只不过是(&gaga).SetAge的一个语法糖。

在上面的例子中，c.B.A.FieldX称为选择器表达式c.FieldX、c.B.FieldX和c.A.FieldX的完整形式。 类似的，c.B.A.MethodA可以称为c.MethodA、c.B.MethodA和c.A.MethodA的完整形式。

如果一个选择器的完整形式中的所有中部项均对应着一个内嵌字段，则中部项的数量称为此选择器的深度。 比如，上面的例子中的选择器c.MethodA的深度为2，因为此选择器的完整形式为c.B.A.MethodA，并且B和A都对应着一个内嵌字段。

选择器遮挡和碰撞
一个值x（这里我们总认为它是可寻址的）可能同时拥有多个最后一项相同的选择器，并且这些选择器的中间项均对应着一个内嵌字段。 对于这种情形（假设最后一项为y）：
只有深度最浅的一个完整形式的选择器（并且最浅者只有一个）可以被缩写为x.y。 换句话说，x.y表示深度最浅的一个选择器。其它完整形式的选择器被此最浅者所遮挡（压制）。
如果有多个完整形式的选择器同时拥有最浅深度，则任何完整形式的选择器都不能被缩写为x.y。 我们称这些同时拥有最浅深度的完整形式的选择器发生了碰撞。
如果一个方法选择器被另一个方法选择器所遮挡，并且它们对应的方法描述是一致的，那么我们可以说第一个方法被第二个覆盖（overridden）了。

举个例子，假设A、B和C为三个定义类型：
type A struct {
x string
}
func (A) y(int) bool {
return false
}

type B struct {
y bool
}
func (B) x(string) {}

type C struct {
B
}
下面这段代码编译不通过，原因是选择器v1.A.x和v1.B.x的深度一样，所以它们发生了碰撞，结果导致它们都不能被缩写为v1.x。 同样的情况发生在选择器v1.A.y和v1.B.y身上。
var v1 struct {
A
B
}

func f1() {
_ = v1.x // error: 模棱两可的v1.x
_ = v1.y // error: 模棱两可的v1.y
}
下面的代码编译没问题。选择器v2.C.B.x被另一个选择器v2.A.x遮挡了，所以v2.x实际上是选择器v2.A.x的缩写形式。 因为同样的原因，v2.y是选择器v2.A.y（而不是选择器v2.C.B.y）的缩写形式。
var v2 struct {
A
C
}

func f2() {
fmt.Printf("%T \n", v2.x) // string
fmt.Printf("%T \n", v2.y) // func(int) bool
}
一个被遮挡或者碰撞的选择器并不妨碍更深层的选择器被提升，如下例所示中的.M和.z：
package main

type x string
func (x) M() {}

type y struct {
z byte
}

type A struct {
x
}
func (A) y(int) bool {
return false
}

type B struct {
y
}
func (B) x(string) {}

func main() {
var v struct {
A
B
}
//_ = v.x // error: 模棱两可的v.x
//_ = v.y // error: 模棱两可的v.y
_ = v.M // ok. <=> v.A.x.M
_ = v.z // ok. <=> v.B.y.z
}
一个不寻常的但需要注意的细节是：来自不同库包的两个非导出方法（或者字段）将总是被认为是两个不同的标识符，即使它们的名字完全一致。 因此，当它们的属主类型被同时内嵌在同一个结构体类型中的时候，它们绝对不会相互碰撞或者遮挡。 举个例子，下面这个含有两个库包的Go程序编译和运行都没问题。 但是，如果将其中所有出现的m()改为M()，则此程序将编译不过。 原因是A.M和B.M碰撞了，导致c.M为一个非法的选择器。
package foo // import "x.y/foo"

import "fmt"

type A struct {
n int
}

func (a A) m() {
fmt.Println("A", a.n)
}

type I interface {
m()
}

func Bar(i I) {
i.m()
}
package main

import "fmt"
import "x.y/foo"

type B struct {
n bool
}

func (b B) m() {
fmt.Println("B", b.n)
}

type C struct{
foo.A
B
}

func main() {
var c C
c.m()      // B false
foo.Bar(c) // A 0
}
为内嵌了其它类型的结构体类型声明的隐式方法
上面已经提到过，类型Singer和*Singer都有一个PrintName方法，并且类型*Singer还有一个SetAge方法。 但是，我们从没有为这两个类型声明过这几个方法。这几个方法从哪来的呢？

事实上，假设结构体类型S内嵌了一个类型（或者类型别名）T，并且此内嵌是合法的，
对内嵌类型T的每一个方法，如果此方法对应的选择器既不和其它选择器碰撞也未被其它选择器遮挡，则编译器将会隐式地为结构体类型S声明一个同样描述的方法。 继而，编译器也将为指针类型*S隐式声明一个相应的方法。
对类型*T的每一个方法，如果此方法对应的选择器既不和其它选择器碰撞也未被其它选择器遮挡，则编译器将会隐式地为类型*S声明一个同样描述的方法。
简单说来，
类型struct{T}和*struct{T}均将获取类型T的所有方法。
类型*struct{T}、struct{*T}和*struct{*T}都将获取类型*T的所有方法。
下面展示了编译器为类型Singer和*Singer隐式声明的三个（提升）方法：
// 注意：这些声明不是合法的Go语法。这里这样表示只是为了
// 解释目的。它们有助于解释提升方法值是如何被估值的。
func (s Singer) PrintName = s.Person.PrintName
func (s *Singer) PrintName = s.Person.PrintName
func (s *Singer) SetAge = s.Person.SetAge
右边的部分为各个提升方法相应的完整形式选择器形式。

从方法一文中，我们得知我们不能为无名的结构体类型（和基类型为无名结构体类型的指针类型）声明方法。 但是，通过类型内嵌，这样的类型也可以拥有方法。

如果一个结构体类型内嵌了一个实现了一个接口类型的类型（此内嵌类型可以是此接口类型自己），则一般说来，此结构体类型也实现了此接口类型，除非发生了选择器碰撞和遮挡。 比如，上例中的结构体类型和以它为基类型的指针类型均实现了接口类型I。

请注意：一个类型将只会获取它（直接或者间接）内嵌了的类型的方法。 换句话说，一个类型的方法集由为类型直接（显式或者隐式）声明的方法和此类型的底层类型的方法集组成。 比如，在下面的例子中，
类型Age没有方法，因为代码中既没有为它声明任何方法，它也没有内嵌任何类型，。
类型X有两个方法：IsOdd和Double。 其中IsOdd方法是通过内嵌类型MyInt而得来的。
类型Y没有方法，因为它所内嵌的类型Age没有方法，另外代码中也没有为它声明任何方法。
类型Z只有一个方法：IsOdd。 此方法是通过内嵌类型MyInt而得来的。 它没有获取到类型X的Double方法，因为它并没有内嵌类型X。
type MyInt int
func (mi MyInt) IsOdd() bool {
return mi%2 == 1
}

type Age MyInt

type X struct {
MyInt
}
func (x X) Double() MyInt {
return x.MyInt + x.MyInt
}

type Y struct {
Age
}

type Z X
提升方法值的正规化和估值
假设v.m是一个合法的提升方法表达式，在编译时刻，编译器将把此提升方法表达式正规化。 正规化过程分为两步：首先找出此提升方法表达式的完整形式；然后将此完整形式中的隐式取地址和解引用操作均转换为显式操作。

和其它方法值估值的规则一样，对于一个已经正规化的方法值表达式v.m，在运行时刻，当v.m被估值的时候，属主实参v的估值结果的一个副本将被存储下来以供后面调用此方法值的时候使用。

以下面的代码为例：
提升方法表达式s.M1的完整形式为s.T.X.M1。 将此完整形式中的隐式取地址和解引用操作转换为显式操作之后的结果为(*s.T).X.M1。 在运行时刻，属主实参(*s.T).X被估值并且估值结果的一个副本被存储下来以供后用。 此估值结果为1，这就是为什么调用f()总是打印出1。
提升方法表达式s.M2的完整形式为s.T.X.M2。 将此完整形式中的隐式取地址和解引用操作转换为显式操作之后的结果为(&(*s.T).X).M2。 在运行时刻，属主实参&(*s.T).X被估值并且估值结果的一个副本被存储下来以供后用。 此估值结果为提升字段s.X（也就是(*s.T).X）的地址。 任何对s.X的修改都可以通过解引用此地址而反映出来，但是对s.T的修改是不会通过此地址反映出来的。 这就是为什么两个g()调用都打印出了2。
package main

import "fmt"

type X int

func (x X) M1() {
fmt.Println(x)
}

func (x *X) M2() {
fmt.Println(*x)
}

type T struct { X }

type S struct { *T }

func main() {
var t = &T{X: 1}
var s = S{T: t}
var f = s.M1 // <=> (*s.T).X.M1
var g = s.M2 // <=> (&(*s.T).X).M2
s.X = 2
f() // 1
g() // 2
s.T = &T{X: 3}
f() // 1
g() // 2
}
接口类型内嵌接口类型
不但结构体类型可以内嵌类型，接口类型也可以内嵌类型。但是接口类型只能内嵌接口类型。 详情请阅读接口一文。

一个有趣的类型内嵌的例子
在本文的最后，让我们来看一个有趣的例子。 此例子程序将陷入死循环并会因堆栈溢出而崩溃退出。 如果你已经理解了多态和类型内嵌，那么就不难理解为什么此程序将死循环。
package main

type I interface {
m()
}

type T struct {
I
}

func main() {
var t T
var i = &t
t.I = i
i.m() // 将调用t.m()，然后再次调用i.m()，......
}

## 非类型安全指针
非类型安全指针
我们已经从Go中的指针一文中学习到关于指针的各种概念和规则。 从那篇文章中，我们得知，相对于C指针，Go指针有很多限制。 比如，Go指针不支持算术运算，并且对于任意两个指针值，很可能它们不能转换到对方的类型。

事实上，在那篇文章中解释的指针的完整称呼应该为类型安全指针。 虽然类型安全指针有助于我们轻松写出安全的代码，但是有时候施加在类型安全指针上的限制也确实导致我们不能写出最高效的代码。

实际上，Go也支持限制较少的非类型安全指针。 非类型安全指针和C指针类似，它们都很强大，但同时也都很危险。 在某些情形下，通过非类型安全指针的帮助，我们可以写出效率更高的代码； 但另一方面，使用非类型安全指针也导致我们可能轻易地写出潜在的不安全的代码，这些潜在的不安全点很难在它们产生危害之前被及时发现。

使用非类型安全指针的另外一个较大的风险是Go中目前提供的非类型安全指针机制并不受到Go 1 兼容性保证的保护。 使用了非类型安全指针的代码可能从今后的某个Go版本开始将不再能编译通过，或者运行行为发生了变化。

如果出于种种原因，你确实希望在你的代码中使用非类型安全指针，你不仅需要提防上述风险，你还需遵守Go官方文档中列出的非类型安全指针使用模式，并清楚地知晓使用非类型安全指针带来的效果。否则，你很难使用非类型安全指针写出安全的代码。

关于unsafe标准库包
非类型安全指针在Go中为一种特别的类型。 我们必须引入unsafe标准库包来使用非类型安全指针。 非类型安全指针unsafe.Pointer被声明定义为：
type Pointer *ArbitraryType
当然，这不是一个普通的类型定义。这里的ArbitraryType仅仅是暗示unsafe.Pointer类型值可以被转换为任意类型安全指针（反之亦然）。换句话说，unsafe.Pointer类似于C语言中的void*。

非类型安全指针是指底层类型为unsafe.Pointer的类型。

非类型安全指针的零值也使用预声明的nil标识符来表示。

在Go 1.17之前，unsafe标准库包只提供了三个函数：
func Alignof(variable ArbitraryType) uintptr。 此函数用来取得一个值在内存中的地址对齐保证（address alignment guarantee）。 注意，同一个类型的值做为结构体字段和非结构体字段时地址对齐保证可能是不同的。 当然，这和具体编译器的实现有关。对于目前的标准编译器，同一个类型的值做为结构体字段和非结构体字段时的地址对齐保证总是相同的。 gccgo编译器对这两种情形是区别对待的。
func Offsetof(selector ArbitraryType) uintptr。 此函数用来取得一个结构体值的某个字段的地址相对于此结构体值的地址的偏移。 在一个程序中，对于同一个结构体类型的不同值的对应相同字段，此函数的返回值总是相同的。
func Sizeof(variable ArbitraryType) uintptr。 此函数用来取得一个值的尺寸（亦即此值的类型的尺寸）。 在一个程序中，对于同一个类型的不同值，此函数的返回值总是相同的。
注意：
这三个函数的返回值的类型均为内置类型uintptr。下面我们将了解到uintptr类型的值可以转换为非类型安全指针（反之亦然）。
尽管这三个函数之一的任何调用的返回结果在同一个编译好的程序中总是一致的，但是这样的一个调用在不同架构的操作系统中（或者使用不同的编译器编译时）的返回值可能是不一样的。
这三个函数的调用总是在编译时刻被估值，估值结果为类型为uintptr的常量。
传递给Offsetof函数的实参必须为一个字段选择器形式value.field。 此选择器可以表示一个内嵌字段，但此选择器的路径中不能包含指针类型的隐式字段。
一个使用了这三个函数的例子：
package main

import "fmt"
import "unsafe"

func main() {
var x struct {
a int64
b bool
c string
}
const M, N = unsafe.Sizeof(x.c), unsafe.Sizeof(x)
fmt.Println(M, N) // 16 32

	fmt.Println(unsafe.Alignof(x.a)) // 8
	fmt.Println(unsafe.Alignof(x.b)) // 1
	fmt.Println(unsafe.Alignof(x.c)) // 8

	fmt.Println(unsafe.Offsetof(x.a)) // 0
	fmt.Println(unsafe.Offsetof(x.b)) // 8
	fmt.Println(unsafe.Offsetof(x.c)) // 16
}
下面是一个展示了上面提到的最后一个注意点的例子：
package main

import "fmt"
import "unsafe"

func main() {
type T struct {
c string
}
type S struct {
b bool
}
var x struct {
a int64
*S
T
}

	fmt.Println(unsafe.Offsetof(x.a)) // 0
	
	fmt.Println(unsafe.Offsetof(x.S)) // 8
	fmt.Println(unsafe.Offsetof(x.T)) // 16
	
	// 此行可以编译过，因为选择器x.c中的隐含字段T为非指针。
	fmt.Println(unsafe.Offsetof(x.c)) // 16
	
	// 此行编译不过，因为选择器x.b中的隐含字段S为指针。
	//fmt.Println(unsafe.Offsetof(x.b)) // error
	
	// 此行可以编译过，但是它将打印出字段b在x.S中的偏移量.
	fmt.Println(unsafe.Offsetof(x.S.b)) // 0
}
注意，上面程序中的注释所暗示的输出结果是此程序在AMD64架构上使用标准编译器1.20版本编译时的结果。

unsafe包提供的这三个函数看上去并不怎么危险。 它们的原型在以后的Go 1版本中几乎不可能会发生改变。 Rob Pike甚至曾经将这几个函数挪到其它包中。 unsafe包的危险性基本上来自于非类型安全指针。它们和C指针一样危险，这是Go安全指针千方百计设法去避免的。

Go 1.17引入了一个新类型和两个新函数。 此新类型为IntegerType。它的定义如下。 此类型不代表着一个具体类型，它只是表示任意整数类型（有点泛型的意思）。
type IntegerType int
Go 1.17引入的两个函数为：
func Add(ptr Pointer, len IntegerType) Pointer。 此函数在一个（非安全）指针表示的地址上添加一个偏移量，然后返回表示新地址的一个指针。 此函数以一种更正规的形式部分地覆盖了下面将要介绍的使用模式3中展示的合法用法。
func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType。 此函数用来从一个任意（安全）指针派生出一个指定长度的切片。
Go 1.20进一步引入了三个函数：
func String(ptr *byte, len IntegerType) string。 此函数用来从一个任意（安全）byte指针派生出一个指定长度的字符串。
func StringData(str string) *byte。 此函数用来获取一个字符串底层字节序列中的第一个byte的指针。
func SliceData(slice []ArbitraryType) *ArbitraryType。 此函数用来获取一个切片底层元素序列中的第一个元素的指针。
Go 1.17之后引入的这些函数具有一定的危险性，需谨慎使用。 下面是使用了Go 1.17引入的两个函数的一个例子。
package main

import (
"fmt"
"unsafe"
)

func main() {
a := [16]int{3: 3, 9: 9, 11: 11}
fmt.Println(a)
eleSize := int(unsafe.Sizeof(a[0]))
p9 := &a[9]
up9 := unsafe.Pointer(p9)
p3 := (*int)(unsafe.Add(up9, -6 * eleSize))
fmt.Println(*p3) // 3
s := unsafe.Slice(p9, 5)[:3]
fmt.Println(s) // [9 0 11]
fmt.Println(len(s), cap(s)) // 3 5

	t := unsafe.Slice((*int)(nil), 0)
	fmt.Println(t == nil) // true

	// 下面是两个不正确的调用。因为它们
	// 的返回结果引用了未知的内存块。
	_ = unsafe.Add(up9, 7 * eleSize)
	_ = unsafe.Slice(p9, 8)
}
下面这两个函数使用了非类型安全的方式实现了字符串和字节切片之间的类型转换。 和类型安全方式相比，它们不用复制字符串和字节切片的底层字节序列，因此效率更高。
import "unsafe"

func String2ByteSlice(str string) []byte {
if str == "" {
return nil
}
return unsafe.Slice(unsafe.StringData(str), len(str))
}

func ByteSlice2String(bs []byte) string {
if len(bs) == 0 {
return ""
}
return unsafe.String(unsafe.SliceData(bs), len(bs))
}
非类型安全指针相关的类型转换
目前（Go 1.20），Go支持下列和非类型安全指针相关的类型转换：
一个类型安全指针值可以被显式转换为一个非类型安全指针类型，反之亦然。
一个uintptr值可以被显式转换为一个非类型安全指针类型，反之亦然。 但是，注意，一个nil非类型安全指针类型不应该被转换为uintptr并进行算术运算后再转换回来。
通过使用这些转换规则，我们可以将任意两个类型安全指针转换为对方的类型，我们也可以将一个安全指针值和一个uintptr值转换为对方的类型。

然而，尽管这些转换在编译时刻是合法的，但是它们中一些在运行时刻并非是合法和安全的。 这些转换摧毁了Go的类型系统（不包括非类型安全指针部分）精心设立的内存安全屏障。 我们必须遵循本文后面要介绍的一些用法指示来使用非类型安全指针才能写出合法并安全的代码。

我们需要知道的一些事实
在开始介绍合法的非类型安全指针使用模式之前，我们需要知道一些事实。

事实一：非类型安全指针值是指针但uintptr值是整数
每一个非零安全或者不安全指针值均引用着另一个值。但是一个uintptr值并不引用任何值，它被看作是一个整数，尽管常常它存储的是一个地址的数字表示。

Go是一门支持垃圾回收的语言。 当一个Go程序在运行中，Go运行时（runtime）将不时地检查哪些内存块将不再被程序中的任何仍在使用中的值所引用并且回收这些内存块。 指针在这一过程中扮演着重要的角色。值与值之间和内存块与值之间的引用关系是通过指针来表征的。

既然一个uintptr值是一个整数，那么它可以参与算术运算。

下一节中的例子将展示指针和uintptr值的不同。

事实二：不再被使用的内存块的回收时间点是不确定的
在运行时刻，一次新的垃圾回收过程可能在一个不确定的时间启动，并且此过程可能需要一段不确定的时长才能完成。 所以一个不再被使用的内存块的回收时间点是不确定的。

一个例子：
import "unsafe"

// 假设此函数不会被内联（inline）。
//go:noinline
func createInt() *int {
return new(int)
}

func foo() {
p0, y, z := createInt(), createInt(), createInt()
var p1 = unsafe.Pointer(y) // 和y一样引用着同一个值
var p2 = uintptr(unsafe.Pointer(z))

	// 此时，即使z指针值所引用的int值的地址仍旧存储
	// 在p2值中，但是此int值已经不再被使用了，所以垃圾
	// 回收器认为可以回收它所占据的内存块了。另一方面，
	// p0和p1各自所引用的int值仍旧将在下面被使用。

	// uintptr值可以参与算术运算。
	p2 += 2; p2--; p2--

	*p0 = 1                         // okay
	*(*int)(p1) = 2                 // okay
	*(*int)(unsafe.Pointer(p2)) = 3 // 危险操作！
}
在上面这个例子中，值p2仍旧在使用这个事实并不能保证曾经被z指针值所引用的int值所占的内存块一定还没有被回收。 换句话说，当*(*int)(unsafe.Pointer(p2)) = 3被执行的时候，此内存块有可能已经被回收了。 所以，继续通过解引用值p2中存储的地址是非常危险的，因为此内存块可能已经被重新分配给其它值使用了。

事实三：一个值的地址在程序运行中可能改变
详情请阅读内存块一文（见链接所指一节的尾部）。 这里我们只需要知道当一个协程的栈的大小改变时，开辟在此栈上的内存块需要移动，从而相应的值的地址将改变。

事实四：一个值的生命范围可能并没有代码中看上去的大
比如中下面这个例子，值t仍旧在使用中并不能保证被值t.y所引用的值仍在被使用。

type T struct {
x int
y *[1<<23]byte
}

func bar() {
t := T{y: new([1<<23]byte)}
p := uintptr(unsafe.Pointer(&t.y[0]))

	... // 使用t.x和t.y

	// 一个聪明的编译器能够觉察到值t.y将不会再被用到，
	// 所以认为t.y值所占的内存块可以被回收了。

	*(*byte)(unsafe.Pointer(p)) = 1 // 危险操作！

	println(t.x) // ok。继续使用值t，但只使用t.x字段。
}
事实五：*unsafe.Pointer是一个类型安全指针类型
是的，类型*unsafe.Pointer是一个类型安全指针类型。 它的基类型为unsafe.Pointer。 既然它是一个类型安全指针类型，根据上面列出的类型转换规则，它的值可以转换为类型unsafe.Pointer，反之亦然。

一个例子：
package main

import "unsafe"

func main() {
x := 123                // 类型为int
p := unsafe.Pointer(&x) // 类型为unsafe.Pointer
pp := &p                // 类型为*unsafe.Pointer
p = unsafe.Pointer(pp)
pp = (*unsafe.Pointer)(p)
}
如何正确地使用非类型安全指针？
unsafe标准库包的文档中列出了六种非类型安全指针的使用模式。 下面将对它们逐一进行讲解。

使用模式一：将类型*T1的一个值转换为非类型安全指针值，然后将此非类型安全指针值转换为类型*T2。
利用前面列出的非类型安全指针相关的转换规则，我们可以将一个*T1值转换为类型*T2，其中T1和T2为两个任意类型。 然而，我们只有在T1的尺寸不小于T2并且此转换具有实际意义的时候才应该实施这样的转换。

通过将一个*T1值转换为类型*T2，我们也可以将一个T1值转换为类型T2。

一个这样的例子是math标准库包中的Float64bits函数。 此函数将一个float64值转换为一个uint64值。 在此转换过程中，此float64值在内存中的每个位（bit）都保持不变。 函数math.Float64frombits为此转换的逆转换。
func Float64bits(f float64) uint64 {
return *(*uint64)(unsafe.Pointer(&f))
}

func Float64frombits(b uint64) float64 {
return *(*float64)(unsafe.Pointer(&b))
}
请注意，函数调用math.Float64bits(aFloat64)的结果和显式转换uint64(aFloat64)的结果不同。

在下面这个例子中，我们使用此模式将一个[]MyString值和一个[]string值转换为对方的类型。 结果切片和被转换的切片将共享底层元素。（这样的转换是不可能通过安全的方式来实现的。）
package main

import (
"fmt"
"unsafe"
)

func main() {
type MyString string
ms := []MyString{"C", "C++", "Go"}
fmt.Printf("%s\n", ms)  // [C C++ Go]
// ss := ([]string)(ms) // 编译错误
ss := *(*[]string)(unsafe.Pointer(&ms))
ss[1] = "Zig"
fmt.Printf("%s\n", ms) // [C Zig Go]
// ms = []MyString(ss) // 编译错误
ms = *(*[]MyString)(unsafe.Pointer(&ss))
}
顺便说一句，从Go 1.17开始，我们也可以使用unsafe.Slice函数来实现这样的转换：
func main() {
...

	ss = unsafe.Slice((*string)(&ms[0]), len(ms))
	ms = unsafe.Slice((*MyString)(&ss[0]), len(ss))
}
此模式在实践中的另一个应用是将一个不再使用的字节切片转换为一个字符串（从而避免对底层字节序列的一次开辟和复制）。如下例所示：
func ByteSlice2String(bs []byte) string {
return *(*string)(unsafe.Pointer(&bs))
}
此实现借鉴于strings标准库包中的Builder类型的String方法的实现。 字节切片的尺寸比字符串的尺寸要大，并且它们的底层结构类似，所以此转换（对于当前的主流Go编译器来说）是安全的。 即使这样，此实现也只推荐在标准库中使用，而不推荐在用户代码中使用。 从Go 1.20开始，在用户代码中，最好尽量使用本文前面介绍的使用unsafe.String函数的实现。

反过来，下面这个例子中的转换是非法的，因为字符串的尺寸比字节切片的尺寸小。
func String2ByteSlice(s string) []byte {
return *(*[]byte)(unsafe.Pointer(&s)) // 危险
}
在后面的模式六中展示了一种合法的（无需复制底层字节序列即可）将一个字符串转换为字节切片的实现。

注意：当运用上面展示的使用非类型安全指针将一个字节切片转换为字符串的技巧时，请确保结果字符串在使用过程中绝对不修改此字节切片中的字节值。

使用模式二：将一个非类型安全指针值转换为一个uintptr值，然后使用此uintptr值。
此模式不是很有用。一般我们将最终的转换结果uintptr值输出到日志中用来调试，但是有很多其它安全并且简洁的途径也可以实现此目的。

一个例子：
package main

import "fmt"
import "unsafe"

func main() {
type T struct{a int}
var t T
fmt.Printf("%p\n", &t)                          // 0xc6233120a8
println(&t)                                     // 0xc6233120a8
fmt.Printf("%x\n", uintptr(unsafe.Pointer(&t))) // c6233120a8
}
输出地址在每次运行中可能都会不同。

使用模式三：将一个非类型安全指针转换为一个uintptr值，然后此uintptr值参与各种算术运算，再将算术运算的结果uintptr值转回非类型安全指针。
转换前后的非类型安全指针必须指向同一个内存块。一个例子：
package main

import "fmt"
import "unsafe"

type T struct {
x bool
y [3]int16
}

const N = unsafe.Offsetof(T{}.y)
const M = unsafe.Sizeof(T{}.y[0])

func main() {
t := T{y: [3]int16{123, 456, 789}}
p := unsafe.Pointer(&t)
// "uintptr(p) + N + M + M"为t.y[2]的内存地址。
ty2 := (*int16)(unsafe.Pointer(uintptr(p)+N+M+M))
fmt.Println(*ty2) // 789
}
其实，对于这样地址加减运算，更推荐使用上面介绍的Go 1.17中引入的unsafe.Add函数来完成。

注意：在上面这个例子中，转换unsafe.Pointer(uintptr(p) + N + M + M)不应该像下面这样被拆成两行。 请阅读下面的代码中的注释以获取原因。
func main() {
t := T{y: [3]int16{123, 456, 789}}
p := unsafe.Pointer(&t)
// ty2 := (*int16)(unsafe.Pointer(uintptr(p)+N+M+M))
addr := uintptr(p) + N + M + M

	// ...（一些其它操作）
	
	// 从这里到下一行代码执行之前，t值将不再被任何值
	// 引用，所以垃圾回收器认为它可以被回收了。一旦
	// 它真地被回收了，下面继续使用t.y[2]值的曾经
	// 的地址是非法和危险的！另一个危险的原因是
	// t的地址在执行下一行之前可能改变（见事实三）。
	// 另一个潜在的危险是：如果在此期间发生了一些
	// 操作导致协程堆栈大小改变的情况，则记录在addr
	// 中的地址将失效。
	ty2 := (*int16)(unsafe.Pointer(addr))
	fmt.Println(*ty2)
}
这样的bug是非常微妙和很难被觉察到的，并且爆发出来的几率是相当得低。 一旦这样的bug爆发出来，将很让人摸不到头脑。这也是使用非类型安全指针被认为是危险操作的原因之一。

中间uintptr值可以参与&^清位运算来进行内存对齐计算，只要保证转换前后的非类型安全指针同时指向同一个内存块，整个转换就是合法安全的。

另一个需要注意的细节是最好不要将一个内存块的结尾边界地址存储在一个（安全或非安全）指针中。 这样做将导致紧随着此内存块的另一个内存块因为被引用而不会被垃圾回收掉，或者因为形成非法指针而导致程序崩溃（取决于具体编译器实现）。 请阅读这个问答以获取更多解释。

使用模式四：将非类型安全指针值转换为uintptr值并传递给syscall.Syscall函数调用。
通过对上一个使用模式的解释，我们知道像下面这样含有uintptr类型的参数的函数定义是危险的。
// 假设此函数不会被内联。
func DoSomething(addr uintptr) {
// 对处于传递进来的地址处的值进行读写...
}
上面这个函数是危险的原因在于此函数本身不能保证传递进来的地址处的内存块一定没有被回收。 如果此内存块已经被回收了或者被重新分配给了其它值，那么此函数内部的操作将是非法和危险的。

然而，syscall标准库包中的Syscall函数的原型为：
func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
那么此函数是如何保证处于传递给它的地址参数值a1、a2和a3处的内存块在此函数执行过程中一定没有被回收和被移动呢？ 此函数无法做出这样的保证。事实上，是编译器做出了这样的保证。 这是syscall.Syscall这样的函数的特权。其它自定义函数无法享受到这样的待遇。

我们可以认为编译器针对每个syscall.Syscall函数调用中的每个被转换为uintptr类型的非类型安全指针实参添加了一些指令，从而保证此非类型安全指针所引用着的内存块在此调用返回之前不会被垃圾回收和移动。

注意：在Go 1.15之前，类型转换表达式uintptr(anUnsafePointer)可以呈现为相关实参的子表达式。 但是，从Go 1.15开始，使用此模式的要求变得略加严格：相关实参必须呈现为uintptr(anUnsafePointer)这种形式。

下面这个调用是安全的：
syscall.Syscall(syscall.SYS_READ, uintptr(fd),
uintptr(unsafe.Pointer(p)), uintptr(n))
但下面这个调用则是危险的：
u := uintptr(unsafe.Pointer(p))
// 被p所引用着的值在此时有可能会被回收掉，
// 或者它的地址已经发生了改变。
syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))

// 相关实参必须呈现为"uintptr(anUnsafePointer)"
// 这种形式。事实上，Go 1.15之前，此调用是合法的；
// 但是Go 1.15略改了一点规则。
syscall.Syscall(SYS_XXX, uintptr(uintptr(fd)),
uint(uintptr(unsafe.Pointer(p))), uintptr(n))
注意：此使用模式也适用于Windows系统中的syscall.Proc.Call和syscall.LazyProc.Call系统调用。

再提醒一次，此使用模式不适用于其它自定义函数。

使用模式五：将reflect.Value.Pointer或者reflect.Value.UnsafeAddr方法的uintptr返回值立即转换为非类型安全指针。
reflect标准库包中的Value类型的Pointer和UnsafeAddr方法都返回一个uintptr值，而不是一个unsafe.Pointer值。 这样设计的目的是避免用户不引用unsafe标准库包就可以将这两个方法的返回值（如果是unsafe.Pointer类型）转换为任何类型安全指针类型。

这样的设计需要我们将这两个方法的调用的uintptr结果立即转换为非类型安全指针。 否则，将出现一个短暂的可能导致处于返回的地址处的内存块被回收掉的时间窗。 此时间窗是如此短暂以至于此内存块被回收掉的几率非常之低，因而这样的编程错误造成的bug的重现几率亦十分得低。

比如，下面这个调用是安全的：
p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))
而下面这个调用是危险的：
u := reflect.ValueOf(new(int)).Pointer()
// 在这个时刻，处于存储在u中的地址处的内存块
// 可能会被回收掉。
p := (*int)(unsafe.Pointer(u))
注意：Go 1.19引入了一个新的方法：reflect.Value.UnsafePointer()。 官方推荐以后使用此方法来替换上述两个方法。也就说，承认了原来的设计思路并不太对路。 UnsafePointer()放回一个unsafe.Pointer值。

使用模式六：将一个reflect.SliceHeader或者reflect.StringHeader值的Data字段转换为非类型安全指针，以及其逆转换。
和上一小节中提到的同样的原因，reflect标准库包中的SliceHeader和StringHeader类型的Data字段的类型被指定为uintptr，而不是unsafe.Pointer。

我们可以将一个字符串的指针值转换为一个*reflect.StringHeader指针值，从而可以对此字符串的内部进行修改。 类似地，我们可以将一个切片的指针值转换为一个*reflect.SliceHeader指针值，从而可以对此切片的内部进行修改。

一个使用reflect.StringHeader的例子：
package main

import "fmt"
import "unsafe"
import "reflect"

func main() {
a := [...]byte{'G', 'o', 'l', 'a', 'n', 'g'}
s := "Java"
hdr := (*reflect.StringHeader)(unsafe.Pointer(&s))
hdr.Data = uintptr(unsafe.Pointer(&a))
hdr.Len = len(a)
fmt.Println(s) // Golang
// 现在，字符串s和切片a共享着底层的byte字节序列，
// 从而使得此字符串中的字节变得可以修改。
a[2], a[3], a[4], a[5] = 'o', 'g', 'l', 'e'
fmt.Println(s) // Google
}
一个使用了reflect.SliceHeader的例子：
package main

import (
"fmt"
"unsafe"
"reflect"
)

func main() {
a := [6]byte{'G', 'o', '1', '0', '1'}
bs := []byte("Golang")
hdr := (*reflect.SliceHeader)(unsafe.Pointer(&bs))
hdr.Data = uintptr(unsafe.Pointer(&a))

	hdr.Len = 2
	hdr.Cap = len(a)
	fmt.Printf("%s\n", bs) // Go
	bs = bs[:cap(bs)]
	fmt.Printf("%s\n", bs) // Go101
}
一般说来，我们只应该从一个已经存在的字符串值得到一个*reflect.StringHeader指针， 或者从一个已经存在的切片值得到一个*reflect.SliceHeader指针， 而不应该从一个全新的StringHeader值生成一个字符串，或者从一个全新的SliceHeader值生成一个切片。 比如，下面的代码是不安全的：
var hdr reflect.StringHeader
hdr.Data = uintptr(unsafe.Pointer(new([5]byte)))
// 在此时刻，上一行代码中刚开辟的数组内存块已经不再被任何值
// 所引用，所以它可以被回收了。
hdr.Len = 5
s := *(*string)(unsafe.Pointer(&hdr)) // 危险！
下面是一个展示了如何通过使用非类型安全途径将一个字符串转换为字节切片的例子。 和使用类型安全途径进行转换不同，使用非类型安全途径避免了复制一份底层字节序列。
package main

import (
"fmt"
"reflect"
"strings"
"unsafe"
)

func String2ByteSlice(str string) (bs []byte) {
strHdr := (*reflect.StringHeader)(unsafe.Pointer(&str))
sliceHdr := (*reflect.SliceHeader)(unsafe.Pointer(&bs))
sliceHdr.Data = strHdr.Data
sliceHdr.Cap = strHdr.Len
sliceHdr.Len = strHdr.Len
return
}

func main() {
// str := "Golang"
// 对于官方标准编译器来说，上面这行将使str中的字节
// 开辟在不可修改内存区。所以这里我们使用下面这行。
str := strings.Join([]string{"Go", "land"}, "")
s := String2ByteSlice(str)
fmt.Printf("%s\n", s) // Goland
s[5] = 'g'
fmt.Println(str) // Golang
}
注意：当使用上面展示的使用非类型安全指针将一个字符串转换为字节切片时，请确保结果此源字符串的生命期内务必不要修改结果字节切片中的字节值（上面的例子违背了此原则）。 事实上，更为推荐的是最好永远不要修改结果字节切片中的字节值。此非类型安全方式的目的主要是为了在局部感知范围内避免一次内存开辟，而不是一种通用的方式。

我们可以使用类似的实现（如下所示）来将一个字节切片转换为字符串。 此实现被模式一中展示的方法略为安全一些（但是也更慢一些）。
func ByteSlice2String(bs []byte) (str string) {
sliceHdr := (*reflect.SliceHeader)(unsafe.Pointer(&bs))
strHdr := (*reflect.StringHeader)(unsafe.Pointer(&str))
strHdr.Data = sliceHdr.Data
strHdr.Len = sliceHdr.Len
return
}
同样地，请确保结果此结果字符串的生命期内务必不要修改实参字节切片中的字节值。

最后，顺便举一个违背了模式三的使用原则的例子：
package main

import (
"fmt"
"reflect"
"unsafe"
)

func Example_Bad() *byte {
var str = "godoc"
hdr := (*reflect.StringHeader)(unsafe.Pointer(&str))
pbyte := (*byte)(unsafe.Pointer(hdr.Data + 2))
return pbyte // *pbyte == 'd'
}

func main() {
fmt.Println(string(*Example_Bad()))
}
下面是两个正确的实现：
func Example_Good1() *byte {
var str = "godoc"
hdr := (*reflect.StringHeader)(unsafe.Pointer(&str))
pbyte := (*byte)(unsafe.Pointer(
uintptr(unsafe.Pointer(hdr.Data)) + 2))
return pbyte
}

// 从Go 1.17开始也可以使用此实现。
func Example_Good2() *byte {
var str = "godoc"
hdr := (*reflect.StringHeader)(unsafe.Pointer(&str))
pbyte := (*byte)(unsafe.Add(unsafe.Pointer(hdr.Data), 2))
return pbyte
}
上面这几个例子借鉴自Bryan C. Mills在slack中发表的一个留言。

reflect标准库包中SliceHeader和StringHeader类型的文档提到这两个结构体类型的定义不保证在以后的版本中不发生改变。 这也可以看作是使用非类型安全指针的另一个（较低的）潜在风险。 好在目前（Go 1.20）的两个主流Go编译器（标准编译器和gccgo编译器）都认可当前版本中的定义。

Go核心开发团队也意识到了这两个类型的使用不方便并且容易出错，因此，这两个类型从Go 1.20开始已经被不再被推荐使用了（它们已经在Go 1.21中被宣布为废弃了）。 取而代之，我们应该尽量使用本文前面介绍的unsafe.String、unsafe.StringData、unsafe.Slice和unsafe.SliceData这几个函数。

总结一下
从上面解释中，我们得知，对于某些情形，非类型安全机制可以帮助我们写出运行效率更高的代码。 但是，使用非类型安全指针也使得我们可能轻易地写出一些重现几率非常低的微妙的bug。 一个含有这样的bug的程序很可能在很长一段时间内都运行正常，但是突然变得不正常甚至崩溃。 这样的bug很难发现和调试。

我们只应该在不得不使用非类型安全机制的时候才使用它们。 特别地，当我们使用非类型安全机制时，请务必遵循上面列出的使用模式。

重申一次，我们应该知晓当前的非类型安全机制规则和使用模式可能在以后的Go版本中完全失效。 当然，目前没有任何迹象表明这种变化将很快会来到。 但是，一旦发生这种变化，本文中列出的当前是正确的代码将变得不再安全甚至编译不通过。 所以，在实践中，请尽量保证能够将使用了非类型安全机制的代码轻松改为使用安全途径实现。

最后值得提一下的是，Go官方工具链1.14中加入了一个-gcflags=all=-d=checkptr编译器动态分析选项（在Windows平台上推荐使用工具链1.15+）。 当此选项被使用的时候，编译出的程序在运行时会监测到很多（但并非所有）非类型安全指针的错误使用。一旦错误的使用被监测到，恐慌将产生。 感谢Matthew Dempsky实现了此特性。

## 泛型
在Go 1.18以前，Go只支持内置泛型。 从Go 1.18开始，Go也支持自定义泛型。 本文只介绍内置泛型。

Go通过各种一等公民组合类型来实现内置泛型。 我们可以用各种一等公民组合类型来组合出无穷个类型。 本文将展示一些自定义组合类型的例子并解释如何解读这些自定义类型。

一些复杂组合类型的例子
Go中的组合类型字面表示设计得非常直观和易于解读。 即使对于一些非常复杂的类型，我们也几乎不可能在解读它们的字面形式中迷失。 下面将从简单到复杂列出一些自定义组合类型的例子并进行解读。

先看一个简单的例子：
[3][4]int
当解读一个类型的字面形式时，我们应该从左到右进行解读。 左边开头的[3]表示着这个类型为一个数组类型，它右边的整个部分为它的元素类型。 对于这个例子，它的元素类型为另外一个数组类型[4]int。 此另外一个数组类型的元素类型为内置类型int。 第一个数组类型可以被看作是一个二维数组类型。

一个使用此数组类型的例子：
package main

import (
"fmt"
)

func main() {
matrix := [3][4]int{
{1, 0, 0, 1},
{0, 1, 0, 1},
{0, 0, 1, 1},
}

	matrix[1][1] = 3
	a := matrix[1] // 变量a的类型为[4]int
	fmt.Println(a) // [0 3 0 1]
}
类似的，
[][]string是一个元素类型为另一个切片类型[]string的切片类型。
**bool是一个基类型为另一个指针类型*bool的指针类型。
chan chan int是一个元素类型为另一个通道类型的chan int的通道类型。
map[int]map[int]string是一个元素类型为另一个映射类型map[int]string的映射类型。 这两个映射类型的键值类型均为内置类型int。
func(int32) func(int32)是一个只有一个输入参数和一个返回值的函数类型，此返回值的类型为一个只有一个输入参数的函数类型。 这两个函数类型的输入参数的类型均为内置类型int32。
下面是另一个自定义组合类型：
chan *[16]byte
最左边的chan关键字表明此类型是一个通道类型。 chan关键字右边的整个部分*[16]byte表示此通道类型的元素类型，此元素类型是一个指针类型。 此指针类型的基类型为*右边的整个部分：[16]byte，此基类型为一个数组类型。 此数组类型的元素类型为内置类型byte。

一个使用此通道类型的例子：
package main

import (
"fmt"
"time"
"crypto/rand"
)

func main() {
c := make(chan *[16]byte)

	go func() {
		// 使用两个数组以避免数据竞争。
		var dataA, dataB = new([16]byte), new([16]byte)
		for {
			_, err := rand.Read(dataA[:])
			if err != nil {
				close(c)
			} else {
				c <- dataA
				dataA, dataB = dataB, dataA
			}
		}
	}()

	for data := range c {
		fmt.Println((*data)[:])
		time.Sleep(time.Second / 2)
	}
}
类似的，类型map[string][]func(int) int为一个映射类型。 此映射类型的键值类型为内置类型string，右边剩余的部分为此映射类型的元素类型。 []表明此映射的元素类型为一个切片类型，此切片类型的元素类型为一个函数类型func(int) int。

一个使用了此映射类型的例子：
package main

import "fmt"

func main() {
addone := func(x int) int {return x + 1}
square := func(x int) int {return x * x}
double := func(x int) int {return x + x}

	transforms := map[string][]func(int) int {
		"inc,inc,inc": {addone, addone, addone},
		"sqr,inc,dbl": {square, addone, double},
		"dbl,sqr,sqr": {double, double, square},
	}

	for _, n := range []int{2, 3, 5, 7} {
		fmt.Println(">>>", n)
		for name, transfers := range transforms {
			result := n
			for _, xfer := range transfers {
				result = xfer(result)
			}
			fmt.Printf(" %v: %v \n", name, result)
		}
	}
}
下面是一个看上去有些复杂的类型：
[]map[struct {
a int
b struct {
x string
y bool
}
}]interface {
Build([]byte, struct {x string; y bool}) error
Update(dt float64)
Destroy()
}
让我们从左到右解读此类型。 最左边开始的[]表明这是一个切片类型，紧跟着的map关键字表明此切片类型的元素为一个映射类型。 map关键字后紧跟的一对方括号[]中的结构体类型字面形式表明此映射的键值类型为一个结构体类型。 此中括号右边的整个部分表明此映射的元素类型为一个接口类型。此接口类型指定了三个方法。 此映射的键值结构体类型有两个字段，第一个字段的名称和类型为a和内置类型int； 第二个字段的名称为b，它的类型为另外一个结构体类型struct {x string; y bool}。 此另外一个结构体类型也有两个字段：内置string类型的字段x和内置bool类型的字段y。

请注意第二个结构体类型也被用做刚提及的接口类型所指定的其中一个方法中的其中一个参数类型。

我们经常将复杂类型的各个组成部分单独提前声明为一个类型名，从而获得更高的可读性。 下面的代码中的类型别名T和上面刚解读的类型表示同一个类型。
type B = struct {
x string
y bool
}

type K = struct {
a int
b B
}

type E = interface {
Build([]byte, B) error
Update(dt float64)
Destroy()
}

type T = []map[K]E
内置泛型函数
Go中当前的内置泛型除了上述类型组合，还有一些支持泛型的内置函数。 比如，内置函数len可以用来获取各种容器值的长度。 unsafe标准库包中的函数也可以被看作是支持泛型的内置函数。 这些函数在前面的各篇文章中已经一一介绍过了。

## 反射
反射概述
Go中提供的反射功能带来了很多动态特性。 很多标准库，比如fmt和很多encoding包，均十分依赖于反射机制。

我们可以通过reflect库包中Type和Value两个类型提供的功能来观察不同的Go值。 本文下面的内容将介绍如何使用这两个类型。

Go反射机制设计的目标之一是任何非反射操作都可以通过反射机制来完成。 由于各种各样的原因，此目标并没有得到100%的实现。 但是，目前大部分的非反射操作都可以通过反射机制来完成。 另一方面，通过反射，我们也可以完成一些使用非反射操作不可能完成的操作。 不能或者只能通过反射完成的操作将在下面的讲解中提及。

reflect.Type类型和值
通过调用reflect.TypeOf函数，我们可以从一个任何非接口类型的值创建一个reflect.Type值。 此reflect.Type值表示着此非接口值的类型。通过此值，我们可以得到很多此非接口类型的信息。 当然，我们也可以将一个接口值传递给一个reflect.TypeOf函数调用，但是此调用将返回一个表示着此接口值的动态类型的reflect.Type值。 实际上，reflect.TypeOf函数的唯一参数的类型为interface{}， reflect.TypeOf函数将总是返回一个表示着此唯一接口参数值的动态类型的reflect.Type值。 那如何得到一个表示着某个接口类型的reflect.Type值呢？ 我们必须通过下面将要介绍的一些间接途径来达到这一目的。

类型reflect.Type为一个接口类型，它指定了若干方法。 通过这些方法，我们能够观察到一个reflect.Type值所表示的Go类型的各种信息。 这些方法中的有些适用于所有种类的类型，有些只适用于一种或几种类型。 通过不合适的reflect.Type属主值调用某个方法将在运行时产生一个恐慌。 请阅读reflect代码库中各个方法的文档来获取如何正确地使用这些方法。

一个例子：
package main

import "fmt"
import "reflect"

func main() {
type A = [16]int16
var c <-chan map[A][]byte
tc := reflect.TypeOf(c)
fmt.Println(tc.Kind())    // chan
fmt.Println(tc.ChanDir()) // <-chan
tm := tc.Elem()
ta, tb := tm.Key(), tm.Elem()
fmt.Println(tm.Kind(), ta.Kind(), tb.Kind()) // map array slice
tx, ty := ta.Elem(), tb.Elem()

	// byte是uint8类型的别名。
	fmt.Println(tx.Kind(), ty.Kind()) // int16 uint8
	fmt.Println(tx.Bits(), ty.Bits()) // 16 8
	fmt.Println(tx.ConvertibleTo(ty)) // true
	fmt.Println(tb.ConvertibleTo(ta)) // false

	// 切片类型和映射类型都是不可比较类型。
	fmt.Println(tb.Comparable()) // false
	fmt.Println(tm.Comparable()) // false
	fmt.Println(ta.Comparable()) // true
	fmt.Println(tc.Comparable()) // true
}
目前，Go支持26种种类的类型。

在上面这个例子中，我们使用方法Elem来得到某些类型的元素类型。 实际上，此方法也可以用来得到一个指针类型的基类型。一个例子：
package main

import "fmt"
import "reflect"

type T []interface{m()}
func (T) m() {}

func main() {
tp := reflect.TypeOf(new(interface{}))
tt := reflect.TypeOf(T{})
fmt.Println(tp.Kind(), tt.Kind()) // ptr slice

	// 使用间接的方法得到表示两个接口类型的reflect.Type值。
	ti, tim := tp.Elem(), tt.Elem()
	fmt.Println(ti.Kind(), tim.Kind()) // interface interface

	fmt.Println(tt.Implements(tim))  // true
	fmt.Println(tp.Implements(tim))  // false
	fmt.Println(tim.Implements(tim)) // true

	// 所有的类型都实现了任何空接口类型。
	fmt.Println(tp.Implements(ti))  // true
	fmt.Println(tt.Implements(ti))  // true
	fmt.Println(tim.Implements(ti)) // true
	fmt.Println(ti.Implements(ti))  // true
}
上面这个例子同时也展示了如何通过间接的途径得到一个表示一个接口类型的reflect.Type值。

我们可以通过反射列出一个类型的所有方法和一个结构体类型的所有（导出和非导出）字段的类型。 我们也可以通过反射列出一个函数类型的各个输入参数和返回结果类型。
package main

import "fmt"
import "reflect"

type F func(string, int) bool
func (f F) m(s string) bool {
return f(s, 32)
}
func (f F) M() {}

type I interface{m(s string) bool; M()}

func main() {
var x struct {
F F
i I
}
tx := reflect.TypeOf(x)
fmt.Println(tx.Kind())        // struct
fmt.Println(tx.NumField())    // 2
fmt.Println(tx.Field(1).Name) // i
// 包路径（PkgPath）是非导出字段（或者方法）的内在属性。
fmt.Println(tx.Field(0).PkgPath) //
fmt.Println(tx.Field(1).PkgPath) // main

	tf, ti := tx.Field(0).Type, tx.Field(1).Type
	fmt.Println(tf.Kind())               // func
	fmt.Println(tf.IsVariadic())         // false
	fmt.Println(tf.NumIn(), tf.NumOut()) // 2 1
	t0, t1, t2 := tf.In(0), tf.In(1), tf.Out(0)
	// 下一行打印出：string int bool
	fmt.Println(t0.Kind(), t1.Kind(), t2.Kind())

	fmt.Println(tf.NumMethod(), ti.NumMethod()) // 1 2
	fmt.Println(tf.Method(0).Name)              // M
	fmt.Println(ti.Method(1).Name)              // m
	_, ok1 := tf.MethodByName("m")
	_, ok2 := ti.MethodByName("m")
	fmt.Println(ok1, ok2) // false true
}
从上面这个例子我们可以看出：
对于非接口类型，reflect.Type.NumMethod方法只返回一个类型的所有导出的方法（包括通过内嵌得来的隐式方法）的个数，并且 方法reflect.Type.MethodByName不能用来获取一个类型的非导出方法； 而对于接口类型，则并无这些限制（Go 1.16之前的文档对这两个方法的描述不准确，并没有体现出这个差异）。 此情形同样存在于下一节将要介绍的reflect.Value类型上的相应方法。
虽然reflect.Type.NumField方法返回一个结构体类型的所有字段（包括非导出字段）的数目，但是不推荐使用方法reflect.Type.FieldByName来获取非导出字段。
我们可以通过反射来检视结构体字段的标签信息。 结构体字段标签的类型为reflect.StructTag，它的方法Get和Lookup用来检视字段标签中的键值对。 一个例子：
package main

import "fmt"
import "reflect"

type T struct {
X    int  `max:"99" min:"0" default:"0"`
Y, Z bool `optional:"yes"`
}

func main() {
t := reflect.TypeOf(T{})
x := t.Field(0).Tag
y := t.Field(1).Tag
z := t.Field(2).Tag
fmt.Println(reflect.TypeOf(x)) // reflect.StructTag
// v的类型为string
v, present := x.Lookup("max")     
fmt.Println(len(v), present)      // 2 true
fmt.Println(x.Get("max"))         // 99
fmt.Println(x.Lookup("optional")) //  false
fmt.Println(y.Lookup("optional")) // yes true
fmt.Println(z.Lookup("optional")) // yes true
}
注意：
键值对中的键不能包含空格（Unicode值为32）、双引号（Unicode值为34）和冒号（Unicode值为58）。
为了形成键值对，所设想的键值对形式中的冒号的后面不能紧跟着空格字符。所以
`optional: "yes"`不形成键值对。
键值对中的值中的空格不会被忽略。所以
`json:"author, omitempty“`、
`json:" author,omitempty“`以及
`json:"author,omitempty“`各不相同。
每个字段标签应该呈现为单行才能使它的整个部分都对键值对的形成有贡献。
reflect代码包也提供了一些其它函数来动态地创建出来一些无名组合类型。
package main

import "fmt"
import "reflect"

func main() {
ta := reflect.ArrayOf(5, reflect.TypeOf(123))
fmt.Println(ta) // [5]int
tc := reflect.ChanOf(reflect.SendDir, ta)
fmt.Println(tc) // chan<- [5]int
tp := reflect.PtrTo(ta)
fmt.Println(tp) // *[5]int
ts := reflect.SliceOf(tp)
fmt.Println(ts) // []*[5]int
tm := reflect.MapOf(ta, tc)
fmt.Println(tm) // map[[5]int]chan<- [5]int
tf := reflect.FuncOf([]reflect.Type{ta},
[]reflect.Type{tp, tc}, false)
fmt.Println(tf) // func([5]int) (*[5]int, chan<- [5]int)
tt := reflect.StructOf([]reflect.StructField{
{Name: "Age", Type: reflect.TypeOf("abc")},
})
fmt.Println(tt)            // struct { Age string }
fmt.Println(tt.NumField()) // 1
}
上面的例子并未展示和reflect.Type相关的所有函数和方法。 请阅读reflect标准库代码包的文档以获取如何使用这些函数和方法。

注意，到目前为止（Go 1.20），我们无法通过反射动态创建一个接口类型。这是Go反射目前的一个限制。

另一个限制是使用反射动态创建结构体类型的时候可能会有各种不完美的情况出现。

第三个限制是我们无法通过反射来声明一个新的类型。

reflect.Value类型和值
类似的，我们可以通过调用reflect.ValueOf函数，从一个非接口类型的值创建一个reflect.Value值。 此reflect.Value值代表着此非接口值。 和reflect.TypeOf函数类似，reflect.ValueOf函数也只有一个interface{}类型的参数。 当我们将一个接口值传递给一个reflect.ValueOf函数调用时，此调用返回的是代表着此接口值的动态值的一个reflect.Value值。 我们必须通过间接的途径获得一个代表一个接口值的reflect.Value值。

被一个reflect.Value值代表着的值常称为此reflect.Value值的底层值（underlying value）。

reflect.Value类型有很多方法。 我们可以调用这些方法来观察和操纵一个reflect.Value属主值表示的Go值。 这些方法中的有些适用于所有种类类型的值，有些只适用于一种或几种类型的值。 通过不合适的reflect.Value属主值调用某个方法将在运行时产生一个恐慌。 请阅读reflect代码库中各个方法的文档来获取如何正确地使用这些方法。

一个reflect.Value值的CanSet方法将返回此reflect.Value值代表的Go值是否可以被修改（可以被赋值）。 如果一个Go值可以被修改，则我们可以调用对应的reflect.Value值的Set方法来修改此Go值。 注意：reflect.ValueOf函数直接返回的reflect.Value值都是不可修改的。

一个例子：
package main

import "fmt"
import "reflect"

func main() {
n := 123
p := &n
vp := reflect.ValueOf(p)
fmt.Println(vp.CanSet(), vp.CanAddr()) // false false
vn := vp.Elem() // 取得vp的底层指针值引用的值的代表值
fmt.Println(vn.CanSet(), vn.CanAddr()) // true true
vn.Set(reflect.ValueOf(789)) // <=> vn.SetInt(789)
fmt.Println(n)               // 789
}
一个结构体值的非导出字段不能通过反射来修改。
package main

import "fmt"
import "reflect"

func main() {
var s struct {
X interface{} // 一个导出字段
y interface{} // 一个非导出字段
}
vp := reflect.ValueOf(&s)
// 如果vp代表着一个指针，下一行等价于"vs := vp.Elem()"。
vs := reflect.Indirect(vp)
// vx和vy都各自代表着一个接口值。
vx, vy := vs.Field(0), vs.Field(1)
fmt.Println(vx.CanSet(), vx.CanAddr()) // true true
// vy is addressable but not modifiable.
fmt.Println(vy.CanSet(), vy.CanAddr()) // false true
vb := reflect.ValueOf(123)
vx.Set(vb)     // okay, 因为vx代表的值是可修改的。
// vy.Set(vb)  // 会造成恐慌，因为vy代表的值是不可修改的。
fmt.Println(s) // {123 <nil>
fmt.Println(vx.IsNil(), vy.IsNil()) // false true
}
上例中同时也展示了如何间接地获取底层值为接口值的reflect.Value值。

从上两例中，我们可以得知有两种方法获取一个代表着一个指针所引用着的值的reflect.Value值：
通过调用代表着此指针值的reflect.Value值的Elem方法。
将代表着此指针值的reflect.Value值的传递给一个reflect.Indirect函数调用。 （如果传递给一个reflect.Indirect函数调用的实参不代表着一个指针值，则此调用返回此实参的一个复制。）
注意：reflect.Value.Elem方法也可以用来获取一个代表着一个接口值的动态值的reflect.Value值，比如下例中所示。
package main

import "fmt"
import "reflect"

func main() {
var z = 123
var y = &z
var x interface{} = y
v := reflect.ValueOf(&x)
vx := v.Elem()
vy := vx.Elem()
vz := vy.Elem()
vz.Set(reflect.ValueOf(789))
fmt.Println(z) // 789
}
reflect标准库包中也提供了一些对应着内置函数或者各种非反射功能的函数。 下面这个例子展示了如何利用这些函数将一个（效率不高的）自定义泛型函数绑定到不同的类型的函数值上。
package main

import "fmt"
import "reflect"

func InvertSlice(args []reflect.Value) []reflect.Value {
inSlice, n := args[0], args[0].Len()
outSlice := reflect.MakeSlice(inSlice.Type(), 0, n)
for i := n-1; i >= 0; i-- {
element := inSlice.Index(i)
outSlice = reflect.Append(outSlice, element)
}
return []reflect.Value{outSlice}
}

func Bind(p interface{},
f func ([]reflect.Value) []reflect.Value) {
// invert代表着一个函数值。
invert := reflect.ValueOf(p).Elem()
invert.Set(reflect.MakeFunc(invert.Type(), f))
}

func main() {
var invertInts func([]int) []int
Bind(&invertInts, InvertSlice)
fmt.Println(invertInts([]int{2, 3, 5})) // [5 3 2]

	var invertStrs func([]string) []string
	Bind(&invertStrs, InvertSlice)
	fmt.Println(invertStrs([]string{"Go", "C"})) // [C Go]
}
如果一个reflect.Value值的底层值为一个函数值，则我们可以调用此reflect.Value值的Call方法来调用此函数。 每个Call方法调用接受一个[]reflect.Value类型的参数（表示传递给相应函数调用的各个实参）并返回一个同类型结果（表示相应函数调用返回的各个结果）。
package main

import "fmt"
import "reflect"

type T struct {
A, b int
}

func (t T) AddSubThenScale(n int) (int, int) {
return n * (t.A + t.b), n * (t.A - t.b)
}

func main() {
t := T{5, 2}
vt := reflect.ValueOf(t)
vm := vt.MethodByName("AddSubThenScale")
results := vm.Call([]reflect.Value{reflect.ValueOf(3)})
fmt.Println(results[0].Int(), results[1].Int()) // 21 9

	neg := func(x int) int {
		return -x
	}
	vf := reflect.ValueOf(neg)
	fmt.Println(vf.Call(results[:1])[0].Int()) // -21
	fmt.Println(vf.Call([]reflect.Value{
		vt.FieldByName("A"), // 如果是字段b，则造成恐慌
	})[0].Int()) // -5
}
请注意：非导出结构体字段值不能用做反射函数调用中的实参。 如果上例中的vt.FieldByName("A")被替换为vt.FieldByName("b")，则将产生一个恐慌。

下面是一个使用映射反射值的例子。
package main

import "fmt"
import "reflect"

func main() {
valueOf := reflect.ValueOf
m := map[string]int{"Unix": 1973, "Windows": 1985}
v := valueOf(m)
// 第二个实参为Value零值时，表示删除一个映射条目。
v.SetMapIndex(valueOf("Windows"), reflect.Value{})
v.SetMapIndex(valueOf("Linux"), valueOf(1991))
for i := v.MapRange(); i.Next(); {
fmt.Println(i.Key(), "\t:", i.Value())
}
}
注意：方法reflect.Value.MapRange方法是从Go 1.12开始才支持的。

下面是一个使用通道反射值的例子。
package main

import "fmt"
import "reflect"

func main() {
c := make(chan string, 2)
vc := reflect.ValueOf(c)
vc.Send(reflect.ValueOf("C"))
succeeded := vc.TrySend(reflect.ValueOf("Go"))
fmt.Println(succeeded) // true
succeeded = vc.TrySend(reflect.ValueOf("C++"))
fmt.Println(succeeded) // false
fmt.Println(vc.Len(), vc.Cap()) // 2 2
vs, succeeded := vc.TryRecv()
fmt.Println(vs.String(), succeeded) // C true
vs, sentBeforeClosed := vc.Recv()
fmt.Println(vs.String(), sentBeforeClosed) // Go true
vs, succeeded = vc.TryRecv()
fmt.Println(vs.String()) // <$1>
fmt.Println(succeeded)   // false
}
reflect.Value类型的TrySend和TryRecv方法对应着只有一个case分支和一个default分支的select流程控制代码块。

我们可以使用reflect.Select函数在运行时刻来模拟具有不定case分支数量的select流程控制代码块。
package main

import "fmt"
import "reflect"

func main() {
c := make(chan int, 1)
vc := reflect.ValueOf(c)
succeeded := vc.TrySend(reflect.ValueOf(123))
fmt.Println(succeeded, vc.Len(), vc.Cap()) // true 1 1

	vSend, vZero := reflect.ValueOf(789), reflect.Value{}
	branches := []reflect.SelectCase{
		{Dir: reflect.SelectDefault, Chan: vZero, Send: vZero},
		{Dir: reflect.SelectRecv, Chan: vc, Send: vZero},
		{Dir: reflect.SelectSend, Chan: vc, Send: vSend},
	}
	selIndex, vRecv, sentBeforeClosed := reflect.Select(branches)
	fmt.Println(selIndex)         // 1
	fmt.Println(sentBeforeClosed) // true
	fmt.Println(vRecv.Int())      // 123
	vc.Close()
	// 再模拟一次select流程控制代码块。因为vc已经关闭了，
	// 所以需将最后一个case分支去除，否则它可能会造成一个恐慌。
	selIndex, _, sentBeforeClosed = reflect.Select(branches[:2])
	fmt.Println(selIndex, sentBeforeClosed) // 1 false
}
一些reflect.Value值可能表示着不合法的Go值。 这样的值为reflect.Value类型的零值（即没有底层值的reflect.Value值）。
package main

import "reflect"
import "fmt"

func main() {
var z reflect.Value // 一个reflect.Value零值
fmt.Println(z)      // <$1>
v := reflect.ValueOf((*int)(nil)).Elem()
fmt.Println(v)      // <$1>
fmt.Println(v == z) // true
var i = reflect.ValueOf([]interface{}{nil}).Index(0)
fmt.Println(i)             // <nil>
fmt.Println(i.Elem())      // <$1>
fmt.Println(i.Elem() == z) // true
}
从上面的例子中，我们知道，使用空接口interface{}值做为中介，一个Go值可以转换为一个reflect.Value值。 逆过程类似，通过调用一个reflect.Value值的Interface方法得到一个interface{}值，然后将此interface{}断言为原来的Go值。 但是，请注意，调用一个代表着非导出字段的reflect.Value值的Interface方法将导致一个恐慌。
package main

import (
"fmt"
"reflect"
"time"
)

func main() {
vx := reflect.ValueOf(123)
vy := reflect.ValueOf("abc")
vz := reflect.ValueOf([]bool{false, true})
vt := reflect.ValueOf(time.Time{})

	x := vx.Interface().(int)
	y := vy.Interface().(string)
	z := vz.Interface().([]bool)
	m := vt.MethodByName("IsZero").Interface().(func() bool)
	fmt.Println(x, y, z, m()) // 123 abc [false true] true

	type T struct {x int}
	t := &T{3}
	v := reflect.ValueOf(t).Elem().Field(0)
	fmt.Println(v)             // 3
	fmt.Println(v.Interface()) // panic
}
Value.IsZero方法是Go 1.13中引进的，此方法用来查看一个值是否为零值。

从Go 1.17开始，一个切片可以被转化为一个相同元素类型的数组的指针类型。 但是如果在这样的一个转换中数组类型的长度过长，将导致恐慌产生。 因此Go 1.17同时引入了一个Value.CanConvert(T Type)方法，用来检查一个转换是否会成功（即不会产生恐慌）。

一个使用了CanConvert方法的例子：
package main

import (
"fmt"
"reflect"
)

func main() {
s := reflect.ValueOf([]int{1, 2, 3, 4, 5})
ts := s.Type()
t1 := reflect.TypeOf(&[5]int{})
t2 := reflect.TypeOf(&[6]int{})
fmt.Println(ts.ConvertibleTo(t1)) // true
fmt.Println(ts.ConvertibleTo(t2)) // true
fmt.Println(s.CanConvert(t1))     // true
fmt.Println(s.CanConvert(t2))     // false
}